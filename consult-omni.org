
* consult-omni
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./consult-omni.el
:END:
** Header
#+begin_src emacs-lisp
;;; consult-omni.el --- Emacs Omni Search Package -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni is a package for getting search results from one or
;; several custom sources (web search engines, AI assistants,
;; elfeed database, org notes, local files, desktop applications,
;; mail servers, ...) directly in Emacs minibuffer.

;; consult-omni provides wrappers and macros around
;; consult (https://github.com/minad/consult), to make it easier
;; for users to get results from different sources and combine
;; local and web sources in an omni-style search.
;; In other words, consult-omni enables getting consult-style
;; multi-source or dynamically completed results in minibuffer for
;; a wide range of sources including Emacs functions/packages
;; (e.g. Emacs buffers, org files, elfeed,...), command-line programs
;; (e.g. grep, find, gh, ...), or web search engines (Google, Bing, ...).

;;; Code:

#+end_src

** Requirements
#+begin_src emacs-lisp
;;; Requirements
(eval-when-compile
  (require 'json)
  (require 'request nil t)
  (require 'plz nil t))
(require 'consult)
(require 'url)
(require 'url-queue)

#+end_src


** Define Group, Customs, Vars, Etc.
*** group
#+begin_src emacs-lisp
;;; Group
(defgroup consult-omni nil
  "Consulting omni sources."
  :group 'convenience
  :group 'minibuffer
  :group 'consult
  :group 'web
  :group 'search
  :prefix "consult-omni-")

#+end_src

*** customization variables
#+begin_src emacs-lisp
;;; User Options (a.k.a. Custom Variables)
;;  The following user options modify the behavior of consult-omni.

(defcustom consult-omni-sources-modules-to-load  (list)
  "List of source modules/features to load.

This variable is a list of symbols;
each symbol being a source featue (e.g. consult-omni-brave)"
  :group 'consult-omni
  :type '(repeat :tag "list of source modules/features to load" symbol))

(defcustom consult-omni-intereactive-commands-type 'both
  "Type of interactive commands to make?

This variable can be a  symbol:
  \='static  only make static commands
  \='dynamic only make dynamic commands
  otherwise make both commands

dynamic commands are dynamically completed  in the minibuffer.
static commands fetch search results once without dynamic completion"
  :group 'consult-omni
  :type '(choice (const :tag "(Default) Make both static and dynamic commands" both)
                 (const :tag "Only make DYNAMIC interactive commands" dynamic)
                 (const :tag "Only make STATIC interactive commands" static)))

(defcustom consult-omni-default-browse-function #'browse-url
  "Default function when selecting a link."
  :group 'consult-omni
  :type '(choice (function :tag "(Default) Browse URL" browse-url)
                 (function :tag "Custom Function")))

(defcustom consult-omni-default-new-function #'consult-omni-external-search
  "Default function when selecting a non-existing new candidate."
  :group 'consult-omni
  :type '(choice (function :tag "(Default) Search in External Browser" consult-omni-external-search)
                 (function :tag "Custom Function")))

(defcustom consult-omni-alternate-browse-function #'eww-browse-url
  "Default function when selecting a link."
  :group 'consult-omni
  :type '(choice (function :tag "(Default) EWW" eww-browse-url)
                 (function :tag "Custom Function")))

(defcustom consult-omni-default-search-engine nil
  "Default search engine name."
  :group 'consult-omni
  :type '(choice (string :tag "Bing" "Bing")
                 (string :tag "Brave" "Brave")
                 (string :tag "DuckDuckGo" "DuckDuckGo")
                 (string :tag "Google" "Google")
                 (string :tag "Perplexity" "Perplexity")
                 (string :tag "PubMed" "PubMed")
                 (string :tag "Wikipedia" "Wikipedia")
                 (string :tag "YouTube" "YouTube")))

(defcustom consult-omni-default-preview-function #'eww-browse-url
  "Default function when previewing a link."
  :group 'consult-omni
  :type '(choice (function :tag "(Default) EWW" eww-browse-url)
                 (function :tag "Custom Function")))


(defcustom consult-omni-show-preview nil
  "Should consult-omni show previews?

This turns previews on/off globally for all consult-omni sources."
  :group 'consult-omni
  :type 'boolean)

(defcustom consult-omni-preview-key consult-preview-key
  "Preview key for consult-omni.

This is similar to `consult-preview-key' but explicitly For consult-omni."
  :group 'consult-omni
  :type '(choice (const :tag "Any Key" Any)
                 (List :tag "Debounced"
                       (const :Debounce)
                       (Float :tag "Seconds" 0.1)
                       (const Any))
                 (const :tag "No Preview" nil)
                 (Key :tag "Key")
                 (repeat :tag "List Of Keys" Key)))


(defcustom consult-omni-default-format-candidate #'consult-omni--highlight-format-candidate
  "Default function when selecting a link."
  :group 'consult-omni
  :type '(choice (function :tag "(Default) Adds Metadata and Highlights Query" #'consult-omni--highlight-format-candidate)
                 (function :tag "Simple and Fast Foramting (No Metadata)" #'consult-omni--simple-format-candidate)
                 (function :tag "Custom Function")))

(defcustom consult-omni-default-count 5
  "Number Of search results to retrieve."
  :group 'consult-omni
  :type 'integer)

(defcustom consult-omni-default-page 0
  "Offset of search results to retrieve.

If this is set to N, the first N “pages” \(or other first N items,
depending on the source search capabilities\) of the search results are
omitted and the rest are shown."
  :group 'consult-omni
  :type 'integer)

(defcustom consult-omni-default-timeout 30
  "Default timeout in seconds for synchronous requests."
  :group 'consult-omni
  :type 'integer)

(defcustom consult-omni-url-use-queue nil
  "Use `url-queue-retrieve'?"
  :group 'consult-omni
  :type 'boolean)

(defcustom consult-omni-url-queue-parallel-processes 15
  "The number of concurrent `url-queue-retrieve' processes."
  :group 'consult-omni
  :type 'integer)

(defcustom consult-omni-url-queue-timeout 120
  "How long to let a job live once it's started (in seconds)."
  :group 'consult-omni
  :type '(integer :tag "Timeout in seconds"))

(defcustom consult-omni-log-buffer-name " *consult-omni-log*"
  "String for consult-omni-log buffer name."
  :group 'consult-omni
  :type 'string)

(defcustom consult-omni-log-level nil
  "How to make logs for consult-omni requests?

This can be set to:
  \='nil:   Does not log anything
  \='info:  Logs URLs and http response header.
  \='debug: Logs URLs and the entire http response.

When non-nil, information is logged to `consult-omni-log-buffer-name'."
  :group 'consult-omni
  :type '(choice
          (const :tag "No Logging" nil)
          (const :tag "Just HTTP Header" info)
          (const :tag "Full Response" debug)))

(defcustom consult-omni-group-by :source
  "What field to use to group the results in the minibuffer?

By default it is set to :source.  but can be any of:

  nil       Do not group
  :title    group by candidate's string
  :url      group by URL
  :domain   group by the domain of the URL
  :source   group by source name
  symbol    group by another property of the candidate"
  :group 'consult-omni
  :type '(radio (const :tag "URL path" :url)
                (const :tag "Domain of URL path":domain)
                (const :tag "Name of the search engine or source" :source)
                (const :tag "Custom other field (constant)" :any)
                (const :tag "Do not group" nil)))

(defcustom consult-omni-multi-sources nil
  "List of sources used by `consult-omni-multi'.

This variable is a list of strings or symbols;
 - strings can be name of a source, a key from `consult-omni--sources-alist',
   which can be made with the convinient macro `consult-omni-define-source'
   or by using `consult-omni--make-source-from-consult-source'.
 - symbols can be other consult sources
   (see `consult-buffer-sources' for example.)"
  :group 'consult-omni
  :type '(choice (repeat :tag "list of source names" string)))

(defcustom consult-omni-highlight-matches-in-minibuffer t
  "Should `consult-omni' highlight search queries in the minibuffer?"
  :group 'consult-omni
  :type 'boolean)

(defcustom consult-omni-highlight-matches-in-file t
  "Should `consult-omni' highlight search queries in files (preview or return)?"
  :group 'consult-omni
  :type 'boolean)

(defcustom consult-omni-highlight-match-ignore-case t
  "Should `consult-omni' ignore case when highlighting matches?"
  :group 'consult-omni
  :type 'boolean)

(defcustom consult-omni-default-interactive-command #'consult-omni-multi
  "Which command should `consult-omni' call?"
  :group 'consult-omni
  :type '(choice (function :tag "(Default) multi-source dynamic search"  consult-omni-multi)
                 (function :tag "multi-source static search" consult-omni-multi-static)
                 (function :tag "Other custom interactive command")))

(defcustom consult-omni-http-retrieve-backend 'url
  "Which backend should `consult-omni' use for http requests?"
  :group 'consult-omni
  :type   '(choice
            (const :tag "(Default) Built-in Emacs's url-retrive" url)
            (const :tag "`emacs-request' backend" request)
            (const :tag "`plz' backend" plz)))

(defcustom consult-omni-default-autosuggest-command nil
  "Which command should `consult-omni' use for auto suggestion on search input?"
  :group 'consult-omni
  :type '(choice (const :tag "(Default) no autosuggestion" nil)
                 (function :tag "Brave autosuggestion (i.e. `consult-omni-brave-autosuggest')" consult-omni-brave-autosuggest)
                 (function :tag "Google autosuggestion (i.e. `consult-omni-dynamic-google-autosuggest')" consult-omni-dynamic-google-autosuggest)
                 (function :tag "Other custom interactive command")))

(defcustom consult-omni-dynamic-input-debounce consult-async-input-debounce
  "Input debounce for dynamic commands.

The dynamic collection process is started only when
there has not been new input for consult-omni-dynamic-input-debounce seconds.
This is similarto `consult-async-input-debounce' but
specifically for consult-omni dynamic commands.

By default inherits from `consult-async-input-debounce'."
  :group 'consult-omni
  :type '(float :tag "delay in seconds"))

(defcustom consult-omni-dynamic-input-throttle consult-async-input-throttle
  "Input throttle for dynamic commands.

The dynamic collection process is started only every
`consult-omni-dynamic-input-throttle' seconds.  This is similar
to `consult-async-input-throttle' but specifically for
consult-omni dynamic commands.

By default inherits from `consult-async-input-throttle'."
  :group 'consult-omni
  :type '(float :tag "delay in seconds"))

(defcustom consult-omni-dynamic-refresh-delay consult-async-refresh-delay
  "Refreshing delay of the completion UI or dynamic commands.

The completion UI is only updated every
`consult-omni-dynamic-refresh-delay' seconds.
This is similar to `consult-async-refresh-delay' but specifically
for consult-omni dynamic commands.

By default inherits from `consult-async-refresh-delay'."
  :group 'consult-omni
  :type '(float :tag "delay in seconds"))

(defcustom consult-omni-search-engine-alist '(("Bing" . "https://www.bing.com/search?q=%s")
                                            ("Brave" .  "https://search.brave.com/search?q=%s")
                                            ("DuckDuckGo" . "https://duckduckgo.com/?q=%s")
                                            ("Google" . "https://www.google.com/search?q=%s")
                                            ("Perplexity" .  "https://www.perplexity.ai/search?q=%s")
                                            ("PubMed" . "https://pubmed.ncbi.nlm.nih.gov/?q=%s")
                                            ("Wikipedia" . "https://en.wikipedia.org/wiki/Special:Search/%s")
                                            ("YouTube" . "https://www.youtube.com/search?q=%s")
                                            ("gptel" . #'consult-omni--gptel-preview)
                                            ("Other" . #'consult-omni--choose-other-source-for-new))
"Alist of search engine names and URLs.

car of each item is the name of the engine
cdr of items must be either:
- a search url string with %s for the query
- an elisp funciton that takes a single string input for query"
  :group 'consult-omni
  :type '(alist :key-type string :value-type (choice (string :tag "a search url string with %s for the query")
                                                      (function :tag " an elisp funciton that takes a single string input for query"))))

#+end_src

*** other variables
**** categories
#+begin_src emacs-lisp
;;; Other Variables

;;  The following variables define search categories.

(defvar consult-omni-sources--all-modules-list (list)
  "List of all source modules.")

(defvar consult-omni-category 'consult-omni
  "Category symbol for the consult-omni seach.")

(defvar consult-omni-scholar-category 'consult-omni-scholar
  "Category symbol for scholar search.")

(defvar consult-omni-apps-category 'consult-omni-apps
  "Category symbol for app launcher.")

(defvar consult-omni-calc-category 'consult-omni-calc
  "Category symbol for calculators.")

(defvar consult-omni-video-category 'consult-omni-video
  "Category symbol for video search.")

(defvar consult-omni-dictionary-category 'consult-omni-dictionary
  "Category symbol for dictionary search.")

#+end_src

**** history variables
#+begin_src emacs-lisp
;;  The following history variables store search histories for
;;  different categories.

(defvar consult-omni--selection-history (list)
  "History variable that keeps selected items.")

(defvar consult-omni--search-history (list)
  "History variable that keeps search terms.")

(defvar consult-omni--email-select-history (list)
  "History variable that keeps selected email result.")

(defvar consult-omni--calc-select-history (list)
  "History variable that keeps selected calculator result.")

(defvar consult-omni--apps-select-history (list)
  "History variable that keeps list of apps launched.")

#+end_src
**** others
#+begin_src emacs-lisp
;;  The following variables are generally for internal use

(defvar consult-omni--sources-alist (list)
  "Alist of all sources.

This is an alist mapping source names to source property lists.
This alist is used to define how to process data form
a source (e.g. format data) or find what commands to run on
selecting candidates from a source, etc.

You can use the convinient macro `consult-omni-define-source'
or the command `consult-omni--make-source-from-consult-source'
to add to this alist.")

(defvar consult-omni--hidden-buffers-list (list)
  "List of currently open hidden buffers.")

(defvar consult-omni--override-group-by nil
  "Override grouping in `consult-group' based on user input.

This is used in dynamic collection to change grouping.")

(defconst consult-omni--http-end-of-headers-regexp
  (rx (or "\r\n\r\n" "\n\n"))
  "Regular expression matching the end of HTTP headers.")

(defvar consult-omni--async-processes (list)
  "List of processes for async candidates colleciton.")

(defvar consult-omni--dynamic-timers (list)
  "List of timers for dynamic candidates colleciton.")

(defvar consult-omni--async-log-buffer " *consult-omni--async-log*"
  "Name of buffer for logging async processes info.")

(defvar consult-omni--async-log-buffer " *consult-omni--async-log*"
  "Name of buffer for logging async processes info.")

(defvar consult-omni--min-timeout 2
  "Minimum timeout in seconds for `consult-omni--multi-static'.")

(defvar consult-omni--max-timeout 120
  "Maximum timeout in seconds for `consult-omni--multi-static'.")

(defvar consult-omni--slow-warning-message "Give me a few seconds to sort it out in this big mess!"
  "The message to show when collection takes a long time.")

#+end_src

*** define faces
#+begin_src emacs-lisp
;;; Faces

(defface consult-omni-default-face
  `((t :inherit 'default))
  "Face used for items in minibuffer.")

(defface consult-omni-prompt-face
  `((t :inherit 'font-lock-variable-use-face))
  "Face used for prompts in minibuffer.")

(defface consult-omni-warning-face
  `((t :inherit 'font-lock-warning-face))
  "Face used for notes source types in minibuffer.")

(defface consult-omni-engine-title-face
  `((t :inherit 'font-lock-variable-use-face))
  "Face used for search engine source types in minibuffer.")

(defface consult-omni-ai-title-face
  `((t :inherit 'font-lock-operator-face))
  "Face used for AI assistant source types in minibuffer.")

(defface consult-omni-files-title-face
  `((t :inherit 'consult-file))
  "Face used for file source types in minibuffer.")

(defface consult-omni-notes-title-face
  `((t :inherit 'font-lock-bracket-face))
  "Face used for notes source types in minibuffer.")

(defface consult-omni-scholar-title-face
  `((t :inherit 'font-lock-function-call-face))
  "Face used for academic literature source types in minibuffer.")

(defface consult-omni-source-type-face
  `((t :inherit 'font-lock-comment-face))
  "Face used for source annotation in minibuffer.")

(defface consult-omni-date-face
  `((t :inherit 'font-lock-preprocessor-face))
  "Face used for date annotation in minibuffer.")

(defface consult-omni-domain-face
  `((t :inherit 'font-lock-string-face))
  "Face used for domain annotation in minibuffer.")

(defface consult-omni-path-face
  `((t :inherit 'font-lock-string-face))
  "Face used for path annotation in minibuffer.")

(defface consult-omni-snippet-face
  `((t :inherit 'font-lock-doc-face))
  "Face used for source annotation in minibuffer.")

(defface consult-omni-keyword-face
  `((t :inherit 'font-lock-keyword-face))
  "Face used for keyword annotation in minibuffer.")

(defface consult-omni-comment-face
  `((t :inherit 'font-lock-comment-face))
  "Face used for source annotation in minibuffer.")

(defface consult-omni-highlight-match-face
  `((t :inherit 'consult-highlight-match))
  "Face used for highlighting matches in minibuffer.")

(defface consult-omni-preview-match-face
  `((t :inherit 'consult-preview-match))
  "Face used for hilighlighting matches in preview buffer.")

#+end_src
** Define Backend Functions
*** general utility
**** properties to plist
#+begin_src emacs-lisp
;;; Backend Functions
;;  These functions are meant for internal use and/or programmers

(defun consult-omni-properties-to-plist (string &optional ignore-keys)
  "Return a plist of the text properties of STRING.

Ommits keys in IGNORE-KEYS."
  (let ((properties (text-properties-at 0 string))
        (pl nil))
    (cl-loop for k in properties
             when (keywordp k)
             do (unless (member k ignore-keys) (push (list k (plist-get properties k)) pl)))
    (apply #'append pl)))

#+end_src
**** propertize with plist
#+begin_src emacs-lisp
(defun consult-omni-propertize-by-plist (item props &optional beg end)
  "Propertize ITEM by PROPS plist.

When BEG and or END are non-nil, adds properties to positions BEG to END."
  (if (stringp item)
      (if (or beg end)
          (let ((beg (or beg 0))
                (end (if (and end (< end 0))
                         (+ (length item) end)
                       (and end (min end (length item))))))
            (add-text-properties beg end props item)
            item)
        (apply #'propertize item props))
    nil))

#+end_src

**** formatting strings
***** fix string length
****** set string width
#+begin_src emacs-lisp

(defun consult-omni--set-string-width (string width &optional truncate-pos add-pos)
  "Set the STRING width to a fixed value, WIDTH.

Set the string with depedning on the following conditions:
- If the STRING is longer than WIDTH, truncate the STRING and add
ellipsis, \"...\".
- If the STRING is shorter than WIDTH, add whitespace to the STRING.
- If TRUNCATE-POS is non-nil, truncate from position TRUNCATE-POS in the
STRING.
- If ADD-POS is non-nil, add whitespace to psition ADD-POS in the STRING."
  (let* ((string (format "%s" string))
         (w (length string)))
    (when (< w width)
      (if (and add-pos (< add-pos w))
          (setq string (format "%s%s%s" (substring string 0 add-pos) (consult-omni-propertize-by-plist (make-string (- width w) ?\s) (text-properties-at add-pos string)) (substring string add-pos)))
        (setq string (format "%s%s" (substring string) (make-string (- width w) ?\s)))))
    (when (> w width)
      (if (and truncate-pos (< truncate-pos (- width 3)) (>= truncate-pos 0))
          (setq string (format "%s%s%s" (substring string 0 truncate-pos) (propertize (substring string truncate-pos (+ truncate-pos 3)) 'display "...") (substring string (- 0 (- width truncate-pos 3)))))
        (setq string (format "%s%s%s"
                             (substring string 0 (- width 3))
                             (propertize  (substring string (- width 3) width) 'display "...")
                             (propertize (substring string width) 'invisible t)))))
    string))

#+end_src
****** justify left
#+begin_src emacs-lisp
(defun consult-omni--justify-left (string prefix maxwidth)
  "Set the width of STRING+PREFIX justified from left.

It uses `consult-omni--set-string-width' and sets the width
of the concatenate of STRING+PREFIX (e.g. `(concat PREFIX STRING)`)
within MAXWIDTH.

This can be used for aligning marginalia info in minibuffer."
  (let ((s (length string))
        (w (length prefix)))
    (if (> maxwidth w)
        (consult-omni--set-string-width string (- maxwidth w) 0)
      string)))

#+end_src
***** shorten url
#+begin_src emacs-lisp
(defun consult-omni--set-url-width (domain path width)
  "Set the length of DOMAIN+PATH to fit within WIDTH."
  (when (stringp domain)
    (let* ((result)
           (path-width (and (stringp path) (length path)))
           (path-target-width (- width (length domain))))
      (cond
       ((<= path-target-width 0)
        (setq result (consult-omni--set-string-width domain width)))
       ((and (integerp path-target-width) (> path-target-width 10))
        (setq result (concat domain (consult-omni--set-string-width path path-target-width (floor (/ path-target-width 2))))))
       (t
        (setq result (consult-omni--set-string-width (concat domain path) width))))
      result)))

#+end_src
***** highlight match with text-properties
#+begin_src emacs-lisp

(defun consult-omni--highlight-match (regexp str ignore-case)
  "Highlight REGEXP in STR.

Case is ignored, if IGNORE-CASE is non-nil.
If a regular expression contains capturing groups, only these are
highlighted.  If no capturing groups are used, highlight the whole match.

\(This is adapted from `consult--highlight-regexps'.\)"
  (save-match-data
    (let ((i 0))
      (while (and (let ((case-fold-search ignore-case))
                    (string-match regexp str i))
                  (> (match-end 0) i))
        (let ((m (match-data)))
          (setq i (cadr m)
                m (or (cddr m) m))
          (while m
            (when (car m)
              (add-face-text-property (car m) (cadr m)
                                      'consult-omni-highlight-match-face nil str))
            (setq m (cddr m)))))))
  str)

#+end_src

***** highlight match with overlay
#+begin_src emacs-lisp

(defun consult-omni--overlay-match (match-str buffer ignore-case)
  "Highlight MATCH-STR in BUFFER using an overlay.

Case is ignored when IGNORE-CASE is non-nil.
This is provided for convinience, if needed in formating candidates
or preview buffers."
  (let ((buffer (or (and buffer (get-buffer buffer)) (current-buffer))))
    (when (buffer-live-p buffer)
      (with-current-buffer buffer
        (save-match-data
          (save-mark-and-excursion
            (remove-overlays (point-min) (point-max) 'consult-omni-overlay t)
            (goto-char (point-min))
            (let ((case-fold-search ignore-case)
                  (consult-omni-overlays (list)))
              (while (search-forward match-str nil t)
                (when-let* ((m (match-data))
                            (beg (car m))
                            (end (cadr m))
                            (overlay (make-overlay beg end)))
                  (overlay-put overlay 'consult-omni-overlay t)
                  (overlay-put overlay 'face 'consult-omni-highlight-match-face))))))))))

(defun consult-omni-overlays-toggle (&optional buffer)
  "Toggle highlight overlays in BUFFER.

BUFFER defaults to the current buffer."
  (interactive)
  (let ((buffer (or buffer (current-buffer))))
    (with-current-buffer buffer
      (dolist (o (overlays-in (point-min) (point-max)))
        (when (overlay-get o 'consult-omni-overlay)
          (if (and (overlay-get o 'face) (eq (overlay-get o 'face) 'consult-omni-highlight-match-face))
              (overlay-put o 'face nil)
            (overlay-put o 'face 'consult-omni-highlight-match-face)))))))
#+end_src
***** hunman-readable numbers
#+begin_src emacs-lisp
(defun consult-omni--numbers-human-readable (number &optional unit separator base prefixes)
  "Convert NUMBER to  a human-redable string.

SEPARATOR is a string placed between unmber and unit
UNIT is a string used as unit
BASE is the number base used to derive prefix
PREFIXES is a list of chars for each magnitude
\(e.g. \='(“” “K” “M” “G” ...\) for none, kilo, mega, giga, ...

adapted from `file-size-human-readable'."
  (let* ((power (if (and base (numberp base)) (float base) 1000.0))
	 (prefixes (or prefixes '("" "k" "M" "G" "T" "P" "E" "Z" "Y" "R" "Q")))
         (number (pcase number
                   ((pred numberp)
                    number)
                   ((pred stringp)
                    (string-to-number number))
                   (_ 0))))
    (while (and (>= number power) (cdr prefixes))
      (setq number (/ number power)
	    prefixes (cdr prefixes)))
    (let* ((prefix (car-safe prefixes)))
      (format (if (and (< number 10)
                       (>= (mod number 1.0) 0.05)
                       (< (mod number 1.0) 0.95))
                  "%.1f%s%s%s"
	        "%.0f%s%s%s")
	      number
              prefix
              (or separator " ")
              unit))))

#+end_src

**** make url with params
#+begin_src emacs-lisp
(defun consult-omni--make-url-string (url params &optional ignore-keys)
  "Add key value pairs in PARAMS to URL as “&key=val”.

PARAMS should be an alist with keys and values to add to the URL.
key in IGNORE-KEYS list will be ignored."

  (let* ((url (if (equal (substring-no-properties url -1 nil) "?")
                  url
                (concat url "?")))
         (list (append (list url) (cl-loop for (key . value) in params
                                           collect
                                           (unless (member key ignore-keys)
                                             (format "&%s=%s" key value))))))
    (mapconcat #'identity list)))

#+end_src
**** hashtable-to-plist
#+begin_src emacs-lisp
(defun consult-omni-hashtable-to-plist (hashtable &optional ignore-keys)
  "Convert a HASHTABLE to a plist.

Ommits keys in IGNORE-KEYS."
  (let ((pl nil))
    (maphash
     (lambda (k v)
       (unless (member k ignore-keys)
         (push (list k v) pl)))
     hashtable)
    (apply #'append pl)))

#+end_src

**** expand function in variable
#+begin_src emacs-lisp
(defun consult-omni-expand-variable-function (var)
  "Call the function if VAR is a function."
  (if (functionp var)
      (funcall var)
    var))

#+end_src
**** pulse
***** pulse-regexp
#+begin_src emacs-lisp
(defun consult-omni--pulse-regexp (regexp &optional delay)
  "Find and pulses REGEXP for DELAY seconds.

DELAY defaults to `pulse-delay'."
  (goto-char (point-min))
  (while (re-search-forward regexp nil t)
    (when-let* ((m (match-data))
                (beg (car m))
                (end (cadr m))
                (ov (make-overlay beg end))
                (pulse-delay (or delay 0.075)))
      (pulse-momentary-highlight-overlay ov 'highlight))))

#+end_src
***** pulse-region
#+begin_src emacs-lisp
(defun consult-omni--pulse-region (beg end &optional delay)
  "Find and pulses region from BEG to END for DELAY seconds.

DELAY defaults to `pulse-delay'."
  (let ((ov (make-overlay beg end))
        (pulse-delay (or delay 0.075)))
    (pulse-momentary-highlight-overlay ov 'highlight)))

#+end_src
***** pulse line
#+begin_src emacs-lisp
(defun consult-omni--pulse-line (&optional delay)
  "Pulse line at point momentarily for DELAY seconds.

DELAY defaults to `pulse-delay'."
  (let* ((pulse-delay (or delay 0.075))
         (ov (make-overlay (car (bounds-of-thing-at-point 'line)) (cdr (bounds-of-thing-at-point 'line)))))
    (pulse-momentary-highlight-overlay ov 'highlight)))
#+end_src

*** http requests
**** backends
***** url retrieve  backend
****** log
#+begin_src emacs-lisp
(defun consult-omni--url-log (string)
  "Insert STRING in the buffer `consult-omni-log-buffer-name'.

This is used for logging the response form `consult-omni-url-retrieve-sync'."
  (with-current-buffer (get-buffer-create consult-omni-log-buffer-name)
    (goto-char (point-min))
    (insert "**********************************************\n")
    (goto-char (point-min))
    (insert (format-time-string "%F - %T%n" (current-time)))
    (insert string)
    (insert "\n")
    (goto-char (point-min))
    (insert "\n\n**********************************************\n")))

#+end_src
****** parse http response
#+begin_src emacs-lisp
(defun consult-omni--parse-http-response (&optional buffer)
  "Parse the first header line in BUFFER.

BUFFER defaults to the current buffer.
This would for example be “HTTP/1.1 200 OK” from an HTTP response."
  (with-current-buffer (or buffer (current-buffer))
    (save-excursion
      (goto-char (point-min))
      (when (re-search-forward "\\=[ \t\n]*HTTP/\\(?1:[0-9\\.]+\\) +\\(?2:[0-9]+\\)" url-http-end-of-headers t)
        `(:http-version ,(match-string 1) :code ,(string-to-number (match-string 2)))))))

#+end_src
****** get the response body
#+begin_src emacs-lisp
(defun consult-omni--url-response-body (response-data)
  "Extract the body from RESPONSE-DATA."
  (plist-get response-data :data))

#+end_src

****** error-handler
#+begin_src emacs-lisp
(defun consult-omni--url-retrieve-error-handler (&rest _args)
  "Handle errors for consult-omni-url-retrieve functions."
  (message "consult-omni: url-retrieve got an error: %s" (consult-omni--parse-http-response)))

#+end_src
****** url retrieve
#+begin_src emacs-lisp
(cl-defun consult-omni-url-retrieve (url &rest settings &key (sync 'nil) (type "GET") params headers data parser callback error timeout &allow-other-keys)
  "Retrieve URL with SETTINGS.

Passes all the arguments to `url-retrieve', `url-retrieve-queue' or
`url-retrieve-snchronously'.

Description of Arguments:
  SYNC     when non-nil, retrieve URL sunchronously
           (see `url-retrieve-synchronously'.)
  TYPE     http request type (e.g. “GET”, “POST”)
  PARAMS   key values pairs added to the base url
           using `consult-omni--make-url-string'.
  HEADERS  key value pairs passed to headers
           (e.g `url-request-extra-headers').
  DATA     are http request data passed to data (e.g. `url-request-data').
  PARSER   a function that is executed in the `url-retrieve' response and
           the results are passed to CALLBACK.  It is called
           without any arguments in the response buffer
           \(i.e. (funcall PARSER) \) This is for example suitable for
           `json-read'.
  CALLBACK a function that is executed when the request is complete.
           It takes one argument, PARSED-DATA which is the output of the
           PARSER above \(i.e. (funcall CALLBACK (funcall PARSER))\).
  ERROR    a function that handles errors.  It is called without any
           arguments in the response buffer.
  TIMEOUT  is the time in seconds for timing out synchronous requests.
           This is ignored in async requests.

Note that  when `consult-omni-url-use-queue' is set to t, this function
uses `url-queue-retrieve', and sets `url-queue-parallel-processes' and
`url-queue-timeout' to `consult-omni-url-queue-parallel-processes' and
`consult-omni-url-queue-timeout', respectively."
  (let* ((url-request-method type)
         (url-request-extra-headers headers)
         (url-request-data data)
         (url-with-params (consult-omni--make-url-string url params))
         (url-debug (if consult-omni-log-level t nil))
         (url-queue-parallel-processes consult-omni-url-queue-parallel-processes)
         (url-queue-timeout consult-omni-url-queue-timeout)
         (retriever (if consult-omni-url-use-queue #'url-queue-retrieve #'url-retrieve))
         (response-data '(:status nil :data nil))
         (buffer (if sync
                     (if timeout
                         (with-timeout
                             (timeout
                              (setf response-data (plist-put response-data :status 'timeout))
                              nil)
                           (url-retrieve-synchronously url-with-params 'silent nil timeout))
                       (url-retrieve-synchronously url-with-params 'silent nil timeout))
                   (funcall retriever url-with-params
                            (lambda (status &rest args)
                              (let* ((parsed-data (condition-case nil
                                                      (if parser (funcall parser) (buffer-substring (point-min) (point-max)))
                                                    (error (funcall error)))))
                                (setf response-data (plist-put response-data :status status))
                                (when parsed-data
                                  (setf response-data (plist-put response-data :data (funcall callback parsed-data)))))) nil 'silent))))
    (when (and buffer (buffer-live-p buffer))
      (add-to-list 'consult-omni--hidden-buffers-list buffer)
      (if sync
          (with-current-buffer buffer
            (save-excursion
              (goto-char (point-min))
              (let* ((end-of-headers (if (and (bound-and-true-p url-http-end-of-headers)
                                              (number-or-marker-p url-http-end-of-headers))
                                         url-http-end-of-headers
                                       (point-min)))
                     (response (buffer-substring (point-min) (pos-eol)))
                     (header (buffer-substring (point-min) end-of-headers))
                     (body (buffer-substring end-of-headers (point-max))))
                (when consult-omni-log-level
                  (cond
                   ((eq consult-omni-log-level 'info)
                    (consult-omni--url-log (format "URL: %s\nRESPONSE: %s" url response)))
                   ((eq consult-omni-log-level 'debug)
                    (consult-omni--url-log (format "URL: %s\n\nRESPONSE-HEADER:\n%s\n\nRESPONSE-BODY: %s\n" url header body)))))
                (setf response-data (plist-put response-data :status response))
                (delete-region (point-min) (+ end-of-headers 1))
                (goto-char (point-min))
                (if-let* ((parsed-data (condition-case nil
                                           (funcall parser)
                                         (error (funcall error)))))
                    (setf response-data (plist-put response-data :data (funcall callback parsed-data)))))))))
    response-data))

#+end_src
***** request backend
****** error-handler
#+begin_src emacs-lisp
(cl-defun consult-omni--request-error-handler (&rest args &key symbol-status error-thrown &allow-other-keys)
  "Handle errors for request backend.

See `request' for more details on ARGS, SYMBOL-STATUS and ERROR-THROWN."
  (message "consult-omni: <request>  %s - %s" symbol-status error-thrown))
#+end_src
****** consult-omni--request-sync
#+begin_src emacs-lisp

(cl-defun consult-omni--request-sync (url &rest args &key params headers data parser placeholder error encoding &allow-other-keys)
  "Convinient wrapper for `request'.

Fetch URL *synchronously* using `request'.
Refer to `request' documents for details on ARGS, PARAMS, HEADERS, DATA,
PARSER, PLACEHOLDER, ERROR, and ENCODING."
  (unless (functionp 'request)
    (error "Request backend not available.  Either install the package “emacs-request” or change the custom variable `consult-omni-retrieve-backend'"))
  (let (candidates)
    (request
      url
      :sync t
      :params params
      :headers headers
      :parser parser
      :error (or error #'consult-omni--request-error-handler)
      :data data
      :encoding (or encoding 'utf-8)
      :success (cl-function (lambda (&key data &allow-other-keys)
                              (setq candidates data))))
    candidates))

#+end_src
***** plz
****** error-handler
#+begin_src emacs-lisp
(cl-defun consult-omni--plz-error-handler (plz-error &rest _args)
  "Handle errors for `plz' backend.

Refer to `plz' documentation for more details on PLZ-ERROR."
  (message "consult-omni: <plz> %s" plz-error))

#+end_src
**** universal
***** parse buffer
#+begin_src emacs-lisp
(defun consult-omni--json-parse-buffer ()
  "Default json parser used in consult-omni."
  (let ((end-of-headers (if (and (bound-and-true-p url-http-end-of-headers)
                                 (number-or-marker-p url-http-end-of-headers))
                            url-http-end-of-headers
                          (point-min))))
    (goto-char end-of-headers)
    (json-parse-buffer :object-type 'hash-table :array-type 'list :false-object :false :null-object :null)))

#+end_src
***** fetch url
#+begin_src emacs-lisp
(cl-defun consult-omni--fetch-url (url backend &rest args &key type params headers data parser callback error encoding timeout sync &allow-other-keys)
  "Retrieve URL with BACKEND.

This is a wrapper that passes the ARGS to the corresponding
BACKEND function.  \(i.e. `consult-omni-url-retrieve',
`request', `plz', ...\).  See backend functions for details.

Description of Arguments:
  SYNC     if non-nil, retrieve URL sunchronously.
  TYPE     http request type \(e.g. “GET”, “POST”\)
  PARAMS   key value pairs added to the base url using
           `consult-omni--make-url-string'.
  HEADERS  key value pairs passed to headers
           \(e.g. `url-request-extra-headers'\).
  DATA     http request data passed to data \(e.g. `url-request-data'\).
  PARSER   a function that is executed in the `url-retrieve' buffer,
           and the results are passed to CALLBACK.
           See `consult-omni-url-retrieve', `request', or `plz' for more
           info.
  CALLBACK a function that is executed when the request is complete.
           It takes one argument, PARSED-DATA \(e.g. the output of
           the PARSER above.\)
           It is called by (funcall CALLBACK (funcall PARSER)).  See
           `consult-omni-url-retrieve', `request', or `plz' for more info.
  ERROR    a function that handles errors.  It is called without any
           arguments in the response buffer.
  ENCODING is the encoding used for the request backend (e.g. \='utf-8)
  TIMEOUT  is the time in seconds for timing out synchronous requests.
           This is ignored in async requests."
  (cond
   ((eq backend 'plz)
    (if sync
        (funcall callback (funcall #'plz (or type 'get) (consult-omni--make-url-string url params)
                                   :headers headers
                                   :as parser
                                   :then 'sync
                                   :else (or error #'consult-omni--plz-error-handler)
                                   :timeout (or timeout consult-omni-default-timeout)))
      (funcall #'plz (or type 'get) (consult-omni--make-url-string url params)
               :headers headers
               :as parser
               :then callback
               :else (or error #'consult-omni--plz-error-handler)
               :timeout (or timeout consult-omni-default-timeout))))
   ((eq backend 'url)
    (if sync
        (consult-omni--url-response-body
         (funcall #'consult-omni-url-retrieve url
                  :sync sync
                  :type (or type "GET")
                  :params params
                  :headers headers
                  :parser parser
                  :data data
                  :error (or error #'consult-omni--url-retrieve-error-handler)
                  :callback (or callback #'identity)
                  :timeout (or timeout consult-omni-default-timeout)))
      (funcall #'consult-omni-url-retrieve url
               :sync sync
               :type (or type "GET")
               :params params
               :headers headers
               :parser parser
               :data data
               :error (or error #'consult-omni--url-retrieve-error-handler)
               :callback (or callback #'identity)
               :timeout (or timeout consult-omni-default-timeout))))
   ((eq backend 'request)
    (if sync
        (funcall callback
                 (request-response-data
                  (funcall #'request url
                           :sync sync
                           :params params
                           :headers headers
                           :parser parser
                           :data data
                           :error (or error #'consult-omni--request-error-handler)
                           :encoding (or encoding 'utf-8)
                           :timeout (or timeout consult-omni-default-timeout))))
      (funcall #'request url
               :params params
               :headers headers
               :parser parser
               :data data
               :error (or error #'consult-omni--request-error-handler)
               :encoding (or encoding 'utf-8)
               :timeout (or timeout consult-omni-default-timeout)
               :complete (cl-function (lambda (&key data &allow-other-keys)
                                        (funcall (or callback #'identity) data))))))))

#+end_src
*** consult-omni backend
**** utilities
***** kill hidden buffer
#+begin_src emacs-lisp
(defun consult-omni--kill-hidden-buffers ()
  "Kill all open preview buffers.

Kills the buffers stored in`consult-gh--preview-buffers-list'.
Ask for confirmation if the buffer is modified and remove the buffers that
are killed from the list."
  (interactive)
  (when consult-omni--hidden-buffers-list
    (mapc (lambda (buff) (if (and (buffer-live-p buff) (not (get-buffer-process buff)))
                             (kill-buffer buff))) consult-omni--hidden-buffers-list))
  (setq consult-omni--hidden-buffers-list nil))

#+end_src

***** kill dead buffers
#+begin_src emacs-lisp
(defun consult-omni--kill-url-dead-buffers ()
  "Kill buffers in `url-dead-buffer-list'."
  (interactive)
  (when url-dead-buffer-list
    (mapc (lambda (buff) (if  (and (buffer-live-p buff) (not (get-buffer-process buff)))
                             (kill-buffer buff)))
          url-dead-buffer-list))
  (setq url-dead-buffer-list nil))

#+end_src

***** log
****** consult-omni-async-log
#+begin_src emacs-lisp
(defun consult-omni--async-log (formatted &rest args)
  "Log FORMATTED ARGS to variable `consult-omni--async-log-buffer'."
  (with-current-buffer (get-buffer-create consult-omni--async-log-buffer)
    (goto-char (point-max))
    (insert (apply #'format formatted args))))

#+end_src


***** get source prop
#+begin_src emacs-lisp
(defun consult-omni--get-source-prop (source prop)
  "Get PROP for SOURCE from `consult-omni--sources-alist'."
  (plist-get (cdr (assoc source consult-omni--sources-alist)) prop))

#+end_src
***** thing at point
#+begin_src emacs-lisp
(defun consult-omni-dynamic--split-thingatpt (thing &optional split-initial)
  "Return THING at point.

If SPLIT-INITIAL is non-nil use `consult--async-split-initial'
to format the string."
  (when-let (str (thing-at-point thing t))
    (if split-initial
        (consult--async-split-initial (format "%s" str))
      str)))
#+end_src
***** read search string
#+begin_src emacs-lisp
(defun consult-omni--read-search-string (&optional initial)
  "Read a string from the minibuffer with INITIAL.

This is used to get initial input for static commands, when
`consult-omni-default-autosuggest-command' is nil."
  (consult--read nil
                 :prompt "Search: "
                 :initial initial
                 :category 'consult-omni
                 :history 'consult-omni--search-history
                 :add-history (consult-omni--add-history '(symbol))))

#+end_src
**** format / annotate candidates
***** simple no highlighting and metadata
#+begin_src emacs-lisp
(cl-defun consult-omni--simple-format-candidate (&rest args &key source query url search-url title snippet &allow-other-keys)
  "Return a simple formatted string for candidates with ARGS.

Description of Arguments:
  SOURCE     the name string of the source for candidate
  QUERY      the query string used for searching
  URL        a string pointing to url of the candidate
  SEARCH-URL a string pointing to the url for
             the search results of QUERY on the SOURCE website
  TITLE      the title of the candidate
  SNIPPET    a string containing a snippet/description of candidate"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (title-str (consult-omni--set-string-width title (* 5 frame-width-percent))))
    (concat title-str
            (when source (concat "\t" source)))))

#+end_src

***** with highlighted query and searchable metadata
#+begin_src emacs-lisp
(cl-defun consult-omni--highlight-format-candidate (&rest args &key source query url search-url title snippet face &allow-other-keys)
  "Return a highlighted formatted string for candidates with ARGS.

Description of Arguments:
  SOURCE      the name string of the source for candidate
  QUERY       the query string used for searching
  URL         a string pointing to url of the candidate
  SEARCH-URL  a string pointing to the url for
              the search results of QUERY on the SOURCE website
  TITLE       the title of the candidate
  SNIPPET     a string containing a snippet/description of candidate
  FACE        the face used for the title"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (and (stringp source) (propertize source 'face 'consult-omni-source-type-face)))
         (match-str (and (stringp query) (not (equal query ".*")) (consult--split-escaped query)))
         (face (or (consult-omni--get-source-prop source :face) face 'consult-omni-default-face))
         (title-str (propertize title 'face face))
         (title-str (consult-omni--set-string-width title-str (* 4 frame-width-percent)))
         (snippet (and (stringp snippet) (consult-omni--set-string-width snippet (* 3 frame-width-percent))))
         (snippet (and (stringp snippet) (propertize snippet 'face 'consult-omni-snippet-face)))
         (urlobj (and url (url-generic-parse-url url)))
         (domain (and (url-p urlobj) (url-domain urlobj)))
         (domain (and (stringp domain) (propertize domain 'face 'consult-omni-domain-face)))
         (path (and (url-p urlobj) (url-filename urlobj)))
         (path (and (stringp path) (propertize path 'face 'consult-omni-path-face)))
         (url-str (consult-omni--set-url-width domain path (* frame-width-percent 2)))
         (str (concat title-str
                      (when url-str (concat "\s" url-str))
                      (when snippet (concat "\s\s" snippet))
                      (when source (concat "\t" source)))))
    (if consult-omni-highlight-matches-in-minibuffer
        (cond
         ((listp match-str)
          (mapc (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-omni--highlight-match match-str str t)))))
    str))

#+end_src

**** group candidates based on a keyword

#+begin_src emacs-lisp
(defun consult-omni--group-function (sources cand transform &optional group-by)
  "Group CAND, in the minibuffer according to GROUP-BY category.

CAND is a candiate in a list of candidates from SOURCES, a list
of all sources for the candidates.  GROUP-BY is a keyword.  If TRANSFORM
is non-nil, the string of CAND is used as the group name.

This is passed as GROUP to `consult--read' on candidates
and is used to define the grouping for CAND."
  (if transform (substring cand)
    (let* ((group-by (or consult-omni--override-group-by group-by consult-omni-group-by))
           (group-by (if (not (keywordp group-by)) (intern (concat ":" (format "%s" group-by))) group-by)))
      (cond
       ((equal group-by :domain)
        (if-let* ((url (get-text-property 0 :url cand))
                  (urlobj (if url (url-generic-parse-url url) nil))
                  (domain (if (url-p urlobj) (url-domain urlobj))))
            domain
          nil))
       ((member group-by '(:nil :none :no :not))
        nil)
       (group-by
        (if-let ((group (get-text-property 0 group-by cand)))
            (format "%s" group)
          "N/A"))
       (t
        (if-let* ((source (plist-get (consult--multi-source sources cand) :name)))
            source
          nil))))))

#+end_src


**** add-history
#+begin_src emacs-lisp
(defun consult-omni--add-history (&optional things &rest _args)
  "Make a list for added history based on THINGS at point.

THINGS should be a list of item types \(e.g. \='(url number word sexp)\).
Each of the THINGS at point willbe added as a separate item to
the history in consul-omni's minibuffer completion."
  (delq nil
        (cl-remove-duplicates
         (append
          (when (region-active-p) (list (consult--async-split-initial (buffer-substring (region-beginning) (region-end)))))
          (mapcar (lambda (thing) (consult-omni-dynamic--split-thingatpt thing t))
                  (or things (list 'number 'word 'sexp 'symbol 'url 'filename 'sentence 'line)))
          (list (consult--async-split-initial isearch-string))))))

#+end_src
**** lookup function
#+begin_src emacs-lisp
(defun consult-omni--lookup-function ()
  "Lookup function for `consult-omni' minibuffer candidates.

This is passed as LOOKUP to `consult--read' on candidates
and is used to format the output when a candidate is selected."
  (lambda (sel cands &rest args)
    (let* ((info (or (car (member sel cands)) ""))
           (title (get-text-property 0 :title info))
           (url (get-text-property 0 :url info)))
      (consult-omni-propertize-by-plist (or title url "nil") (or (text-properties-at 0 info) (list))))))

#+end_src
**** preview
#+begin_src emacs-lisp
(defun consult-omni--default-url-preview (cand)
  "Default function to use for previewing CAND."
  (when (listp cand) (setq cand (car-safe cand)))
  (when-let* ((url (get-text-property 0 :url cand))
              (buff (funcall consult-omni-default-preview-function url)))
    (funcall (consult--buffer-preview) 'preview buff)))

#+end_src
**** state
***** make state
#+begin_src emacs-lisp
(cl-defun consult-omni--make-state-function (&rest args &key setup preview exit return &allow-other-keys)
  "Convinient wrapper to make custom state functions with ARGS.

This can be passed as STATE to `consult--read' on candidates and is
used to define actions when setting up, previewing or selecting a
candidate.  SETUP, PREVIEW, EXIT, and RETURN are functions that take one
input argument, the selected candidate.

Refer to `consult--read' documentation for more details."
  (lambda (action cand &rest args)
    (if cand
        (pcase action
          ('setup
           (funcall setup cand))
          ('preview
           (funcall preview cand))
          ('exit
           (funcall exit cand))
          ('return
           (funcall return cand))))))

#+end_src
***** dynamic state function
#+begin_src emacs-lisp
(defun consult-omni--dynamic-state-function ()
  "Dynamically make state function for the candidate at point.

This makes a STATE function to be passed to `consult--read' based on the
source of the candidate at point.  The \='setup, \='preview, \='return and
\='exit actions for a specific source is looked up in
`consult-omni--sources-alist'."
  (lambda (action cand &rest args)
    (if cand
        (let* ((source (get-text-property 0 :source cand))
               (state (consult-omni--get-source-prop source :state))
               (preview (consult-omni--get-source-prop source :on-preview))
               (return (consult-omni--get-source-prop source :on-return))
               (exit (consult-omni--get-source-prop source :on-exit)))
          (if state
              (funcall state action cand args)
            (pcase action
              ('preview
               (if preview (funcall preview cand) (consult-omni--default-url-preview cand)))
              ('return
               (if return (funcall return cand) cand))
              ('exit
               (funcall (consult--buffer-preview) 'exit cand))))))))

#+end_src
**** callback
#+begin_src emacs-lisp
(defun consult-omni--default-callback (cand)
  "Default CALLBACK for CAND.

The CALLBACK is called when a CAND is selected.

When making consult-omni sources, if a CALLBACK is not provided, this
CALLBACK is used as a fall back option."
  (when (listp cand) (setq cand (car-safe cand)))
  (if-let ((url (get-text-property 0 :url cand)))
      (funcall consult-omni-default-browse-function url)))

#+end_src
**** new
***** external search
#+begin_src emacs-lisp
(defun consult-omni-external-search (cand &optional engine)
  "Search for CAND on the search engine, ENGINE.

ENGINE is cons, where the car is the nae of the search engine, and the cdr
is the url string or a function.  See `consult-omni-search-engine-alist'
for some examples."
  (interactive (list (consult--read nil :prompt "Search: ")))
  (let* ((cand (or (and (stringp cand) (propertize cand :query (substring-no-properties cand) :title cand)) cand))
         (engine (or engine consult-omni-default-search-engine (consult--read consult-omni-search-engine-alist :prompt "Select Search Engine: ")))
         (func (cdr (assoc engine consult-omni-search-engine-alist)))
         (search-url (if (stringp func) func nil))
         (url (if (stringp search-url) (format search-url (url-hexify-string cand)) nil)))
    (cond
     (url (funcall consult-omni-default-browse-function url))
     ((functionp (cadr func)) (funcall (cadr func) cand)))))

#+end_src
***** external search with engine
#+begin_src emacs-lisp
(defun consult-omni-external-search-with-engine (engine &optional cand)
  "Run `consult-omni-external-search' on CAND with a specific ENGINE."
  (funcall #'consult-omni-external-search cand engine))

#+end_src
***** choose other source for new
#+begin_src emacs-lisp
(defun consult-omni--choose-other-source-for-new (cand)
  "Choose a source to use for non-existing CAND."
  (interactive)
  (let* ((sources (cl-remove-duplicates (delq nil (mapcar (lambda (item)
                                                            (when-let ((new (consult-omni--get-source-prop item :on-new))
                                                                       (name (consult-omni--get-source-prop item :name)))
                                                              (when (not (eq new #'consult-omni--default-new))
                                                                (cons name new))))
                                                          consult-omni-multi-sources))))
         (action (consult--read sources
                                :prompt "Create a new item on source: "
                                :lookup #'consult--lookup-cdr
                                )))
    (if (functionp action)
        (funcall action cand)
      (error "Do not know how to make a new item for that source!"))))

#+end_src
***** consult-omni--default-new
#+begin_src emacs-lisp
(defun consult-omni--default-new (cand)
  "Call `consult-omni-default-new-function' with CAND as the argument."
  (funcall consult-omni-default-new-function cand))

#+end_src
**** dynamic/async collection
***** get key value pair from opt
#+begin_src emacs-lisp
(defun consult-omni--extract-opt-pair (opt opts ignore-opts)
  "Extract a pair of (OPT . value) from a list of OPTS.

value is the next element after OPT in OPTS.
IGNORE-OPTS is a list of opts to exclude.

This is useful for example to extract key value pairs
from command-line options in a list of strings"
  (unless (member opt ignore-opts)
    (let* ((key (cond
                 ((string-match-p "-.*$" opt)
                  (intern (concat ":" (replace-regexp-in-string "--" "" opt))))
                 ((string-match-p ":.*$" opt)
                  (intern opt))
                 (t nil)))
           (val (or (cadr (member opt opts)) "nil")))
      (when key
        (cons key val)))))

#+end_src
***** split-command
#+begin_src emacs-lisp
(defun consult-omni--split-command (input &rest args)
  "Append command argument and options list in INPUT string to ARGS.

INPUT is a string, for example the user's input from the minibuffer.
command line arguments and options \(e.g. count, page, ...\) in the INPUT
string are extracted and appended to the ARGS list.  If there is a
grouping option in INPUT \(e.g. “:group source”\), it is used to set
`consult-omni--override-group-by'."
  (pcase-let* ((`(,query . ,opts) (consult--command-split input))
               (args (if (member (flatten-list args) (list nil (list nil))) nil args)))
    (if (and opts (listp opts) (> (length opts) 0))
        (progn
          (setq opts (cl-substitute ":count" ":n" opts :test 'equal))
          (setq opts (cl-substitute ":count" "-n" opts :test 'equal))
          (setq opts (cl-substitute ":page" ":p" opts :test 'equal))
          (setq opts (cl-substitute ":page" "-p" opts :test 'equal))
          (setq opts (cl-substitute ":group" ":g" opts :test 'equal))
          (setq opts (cl-substitute ":group" "-g" opts :test 'equal))
          (if (member ":group" opts)
              (setq consult-omni--override-group-by (cadr (member ":group" opts)))
            (setq consult-omni--override-group-by nil))
          (cl-loop for opt in opts
                   do (pcase-let* ((`(,key . ,val) (consult-omni--extract-opt-pair opt opts (list ":group"))))
                        (when key
                          (setq args (append args (list key val)))))))
      (setq consult-omni--override-group-by nil))
    (list (or query input) args)))

#+end_src
***** filter by minibuffer content
#+begin_src emacs-lisp
(defun consult-omni--match-minibuffer-content-p (cand)
  "Check if CAND matches minibuffer content.

Use regexp to only keep candidates in the minbuffer that match the current
content of the minibuffer \(e.g. user input\).  This is useful when using
a sync source in an async/dynamic fashion to filter the candidates from
the sync source and ony keep the ones that match user's input."
  (let* ((win (active-minibuffer-window))
         (buffer (window-buffer win))
         (split-char (plist-get (consult--async-split-style) :initial)))
    (with-current-buffer buffer
      (if (minibuffer-window-active-p win)
          (string-match (concat ".*" (string-trim (car-safe (consult-omni--split-command (minibuffer-contents-no-properties))) split-char "\n") ".*") (substring-no-properties cand))))))

#+end_src
***** async builders
#+begin_src emacs-lisp
(defun consult-omni--async-builder (input command-args)
  "Build command line from INPUT.

  COMMAND-ARGS are commandline args (e.g. “grep”)"
  (pcase-let ((`(,arg . ,opts) (consult--command-split input)))
    (unless (string-blank-p arg)
      (cons (append (consult--build-args command-args)
                    (consult--split-escaped arg) opts)
            (cdr (consult--default-regexp-compiler input 'basic t))))))

#+end_src
**** consult-omni-multi-static
***** static collect synchronous candidates
#+begin_src emacs-lisp
(defun consult-omni--multi-static-sync-candidates (source idx input &rest args)
  "Synchronously collect candidates for INPUT from a “sync” SOURCE.

This returns a list of candidates with properties suitable
for use in a static (not dynamically updated) multi-source command.

Description of Arguments:
  INPUT  a string; the user's input
  SOURCE a plist with properties that define the source to search.
         for example see `consult-omni-sources-alist'.
  ARGS   list of ARGS to pass to the collecting function
         \(e.g. the function defined by :items field in the SOURCE plist\)
  IDX    is passed to `consult-omni--multi-propertize'."
  (let* ((name (plist-get source :name))
         (face (and (plist-member source :face) `(face ,(plist-get source :face))))
         (cat (plist-get source :category))
         (transform (consult-omni--get-source-prop name :transform))
         (fun (plist-get source :items))
         (items))
    (when (functionp fun)
      (cond
       ((and (integerp (cdr (func-arity fun))) (< (cdr (func-arity fun)) 1))
        (setq items (funcall fun)))
       (t
        (setq items (funcall fun input args)))))
    (when (and items transform)
      (setq items (funcall transform items input)))
    (and items (consult-omni--multi-propertize items cat idx face))))

#+end_src

***** static collect dynamic candidates
#+begin_src emacs-lisp
(defun consult-omni--multi-static-dynamic-candidates (source idx input &rest args)
  "Synchronously collect candidates for INPUT from a “dynamic” SOURCE.

This returns a list of candidates with properties suitable
for use in a static (not dynamically updated) multi-source command

Description of Arguments:
  INPUT  a string; the user's input
  SOURCE a plist with properties that define the source to search.
         for example see `consult-omni-sources-alist'.
  ARGS   list of ARGS to pass to the collecting function
         \(e.g. the function defined by :items field in the SOURCE plist\)
  IDX    is passed to `consult-omni--multi-propertize'."
  (let* ((name (plist-get source :name))
         (face (and (plist-member source :face) `(face ,(plist-get source :face))))
         (cat (plist-get source :category))
         (name (plist-get source :name))
         (transform (consult-omni--get-source-prop name :transform))
         (fun (plist-get source :items))
         (items)
         (current))
    (when (functionp fun)
      (funcall fun input
               :callback (lambda (response-items)
                           (if response-items
                               (progn
                                 (when transform (setq response-items (funcall transform response-items input)))
                                 (setq current
                                       (and response-items (consult-omni--multi-propertize
                                                            response-items cat idx face))))
                             (setq current t)))
               args)
      (with-timeout
          (consult-omni-default-timeout
           current)
        (while (not current)
          (sit-for 0.05)))
      current)))

#+end_src



***** static collect async candidates
#+begin_src emacs-lisp
(defun consult-omni--multi-static-async-candidates (source idx input &rest args)
  "Synchronously collect candidates for INPUT from an “async” SOURCE.

This returns a list of candidates with properties suitable
for use in a static (not dynamically updated) multi-source command

Description of Arguments:
  INPUT  a string; the user's input
  SOURCE a plist with properties that define the source to search.
         for example see `consult-omni-sources-alist'.
  ARGS   list of ARGS to pass to the collecting function
         \(e.g. the function defined by :items field in the SOURCE plist\)
  IDX    is passed to `consult-omni--multi-propertize'."
  (let* ((name (plist-get source :name))
         (builder (plist-get source :items))
         (transform (consult-omni--get-source-prop name :transform))
         (filter (consult-omni--get-source-prop name :filter))
         (props (seq-drop-while (lambda (x) (not (keywordp x))) args))
         (proc)
         (proc-buf)
         (face (and (plist-member source :face) `(face ,(plist-get source :face))))
         (consult-omni--async-log-buffer (concat " *consult-omni-async-log--" name "*"))
         (cat (plist-get source :category))
         (query (car (consult-omni--split-command input)))
         (cmd (funcall builder input))
         (items))
    (unless (stringp (car cmd))
      (setq cmd (car cmd)))
    (when cmd
      (let* ((lines)
             (process-adaptive-read-buffering nil)
             (out (with-temp-buffer
                    (set-buffer-file-coding-system 'cp1047)
                    (list (apply 'call-process (car cmd) nil (current-buffer) nil (cdr cmd))
                          (replace-regexp-in-string "\r" "\n"
                                                    (buffer-string))))))
        (if (eq (car out) 0)
            (progn
              (setq lines (mapcar (lambda (line) (propertize line :source name :title line :query query)) (split-string (cadr out) "[\r\n]+" t)))
              (when (and lines filter (functionp filter)) (setq lines (funcall filter lines query)))
              (when (and lines transform (functionp transform)) (setq lines (funcall transform lines query))))
          (message "process %s returned error with code %s and message %s" name (car out) (cdr out)))
        (consult-omni--multi-propertize lines cat idx face)))))

#+end_src

***** multi-candidates-static
#+begin_src emacs-lisp
(defun consult-omni--multi-candidates-static (sources &optional input &rest args)
  "Return candidates for INPUT and ARGS from SOURCES.

This is used for `consult-omni--multi-static'."
  (let* ((candidates)
         (idx 0))
    (seq-doseq (src sources)
      (let* ((name (and (plist-member src :name) (plist-get src :name)))
             (face (and (plist-member src :face) `(face ,(plist-get src :face))))
             (cat (plist-get src :category))
             (items (plist-get src :items))
             (narrow (plist-get src :narrow))
             (async-type (and name (consult-omni--get-source-prop name :type)))
             (narrow-type (or (car-safe narrow) narrow -1))
             (err (if consult-omni-log-level 'err nil)))
        (when (or (eq consult--narrow narrow-type)
                  (not (or consult--narrow (plist-get src :hidden))))
          (condition-case err
              (progn
                (when (functionp items)
                  (cond
                   (; sync source, append candidates right away
                    (eq async-type 'sync)
                    (push (consult-omni--multi-static-sync-candidates src idx input args) candidates))
                   (; dynamic source, append candidates and wait for it to populate
                    (eq async-type 'dynamic)
                    (push (consult-omni--multi-static-dynamic-candidates src idx input args) candidates))
                   (; async source, append candidates from process
                    (eq async-type 'async)
                    (push (consult-omni--multi-static-async-candidates src idx input args) candidates))
                   (t
                    (message "source %s needs a :type keyword. See the documentation for `consult-omni-define-source'." name)))))
            (wrong-type-argument nil)
            (error
             (message (if consult-omni-log-level
                          (format "error in calling :items of %s source - %s" name (error-message-string err))
                        (format "error in calling :items of %s source" name)))
             nil))))
      (cl-incf idx))
    (apply #'append candidates)))

#+end_src


***** consult-omni--multi-static
#+begin_src emacs-lisp
(defun consult-omni--multi-static (sources input args &rest options)
  "Read candidates from SOURCES with static interface.

This is similar to `consult--multi' but accepts async/dynamic sources
as well.  See `consult--multi' for more info.

Description of Arguments:
  SOURCES is list of sources to use
  INPUT   is the user's input string
  ARGS    are sent as additional args to each SOURCE's
          collection function.
  OPTIONS are similar to options in `consult--multi'."
  (let* ((sources (consult--multi-enabled-sources sources))
         (timeout (max consult-omni--min-timeout (min (* (length sources) consult-omni-default-timeout) consult-omni--max-timeout)))
         (candidates (with-timeout ((or timeout 30) nil)
                       (setq candidates (consult--slow-operation consult-omni--slow-warning-message (consult-omni--multi-candidates-static sources input args)))))
         (selected (if (or (not candidates) (and (listp candidates) (= (length candidates) 0)))
                       (progn (message (concat (propertize "no results were found with the input " 'face 'consult-omni-prompt-face)  (propertize (format "%s" input) 'face 'warning)))
                              nil)
                     (apply #'consult--read
                            candidates
                            (append
                             options
                             (list
                              :sort        nil
                              :history     'consult-omni--selection-history
                              :category    'multi-category
                              :predicate   (apply-partially #'consult-omni--multi-predicate sources)
                              :annotate    (apply-partially #'consult-omni--multi-annotate sources)
                              :group       (apply-partially #'consult-omni--multi-group sources)
                              :lookup      (apply-partially #'consult-omni--multi-lookup sources)
                              :preview-key (consult--multi-preview-key sources)
                              :narrow      (consult--multi-narrow sources)
                              :state       (consult--multi-state sources)))))))
    (if (and (listp selected) (plist-member (cdr selected) :match))
        (when-let (fun (plist-get (cdr selected) :new))
          (funcall fun (car selected))
          (plist-put (cdr selected) :match 'new))
      (when-let (fun (plist-get (cdr selected) :action))
        (funcall fun (car selected)))
      (setq selected `(,(car selected) :match t ,@(cdr selected))))
    selected))

#+end_src

**** consult-omni-multi-dynamic
***** multi-lookup
#+begin_src emacs-lisp
(defun consult-omni--multi-lookup (sources selected candidates _input narrow &rest _)
  "Lookup SELECTED in CANDIDATES given SOURCES, with potential NARROW.

Adopted from `consult--multi-lookup'."
  (if (or (string-blank-p selected)
          (not (consult--tofu-p (aref selected (1- (length selected))))))
      ;; Non-existing candidate without Tofu or default submitted (empty string)
      (let* ((src (cond
                   (narrow (seq-find (lambda (src)
                                       (let ((n (plist-get src :narrow)))
                                         (eq (or (car-safe n) n -1) narrow)))
                                     sources))
                   ((seq-find (lambda (src) (plist-get src :default)) sources))
                   ((seq-find (lambda (src) (not (plist-get src :hidden))) sources))
                   ((aref sources 0))))
             (idx (seq-position sources src))
             (def (and (string-blank-p selected) ;; default candidate
                       (seq-find (lambda (cand) (eq idx (consult--tofu-get cand))) candidates))))
        (if def
            (cons (cdr (get-text-property 0 'multi-category def)) src)
          `(,selected :match nil ,@src)))
    (let* ((found (member selected candidates))
           (info (if found (or (car found) "") ""))
           (title (get-text-property 0 :title info))
           (url (get-text-property 0 :url info)))
      (if found
          ;; Existing candidate submitted
          (cons (apply #'propertize (or title url "nil") (or (text-properties-at 0 info) (list)))
                (consult--multi-source sources selected))
        ;; Non-existing Tofu'ed candidate submitted, e.g., via Embark
        `(,(substring selected 0 -1) :match nil ,@(consult--multi-source sources selected))))))

#+end_src
***** muli-group
#+begin_src emacs-lisp
(defun consult-omni--multi-group (sources cand &optional transform)
  "Return group string of candidate CAND.

Returns the group string for candidate or transforms it
for all the candidates given SOURCES.

Adopted from `consult--multi-group'."
  (if transform
      cand
    (let* ((fun (and (plist-member (consult--multi-source sources cand) :group)
                     (plist-get (consult--multi-source sources cand) :group))))
      (cond
       ((functionp fun)
        (let ((argnum (cdr (func-arity fun))))
          (cond
           ((or (stringp argnum) (and (numberp argnum) (> argnum 2)))
            (funcall fun sources cand transform))
           ((and (numberp argnum) (= argnum 2))
            (funcall fun cand transform))
           ((and (numberp argnum) (= argnum 1))
            (funcall fun cand)))))
       ((stringp fun)
        fun)
       ((eq fun 'nil)
        nil)
       (t
        (plist-get (consult--multi-source sources cand) :name))))))

#+end_src
***** multi-predicate
#+begin_src emacs-lisp
(defun consult-omni--multi-predicate (sources cand)
  "Predicate function called for each candidate CAND given SOURCES.

Adopted from `consult--multi-predicate'."
  (let* ((src (consult--multi-source sources cand))
         (narrow (or (plist-get src :narrow) -1))
         (pred (plist-get src :predicate))
         (show t))
    (if pred
        (cond
         ((booleanp pred)
          (setq show pred))
         ((and (functionp pred) (> (car (func-arity pred)) 0))
          (setq show (funcall pred cand)))))
    (and show
          (or (pcase narrow
                (`((,_ . ,_) . ,_) (assq consult--narrow narrow))
                (`(,k . ,_) (eq consult--narrow k))
                (k (eq consult--narrow k)))
              (not (or consult--narrow (plist-get src :hidden)))))))

#+end_src

***** multi-enabled
#+begin_src emacs-lisp
(defun consult-omni--multi-enabled-sources (sources)
  "Return vector of enabled SOURCES.

Adopted from `consult--multi-enabled-sources'."
  (vconcat
   (seq-filter (lambda (src)
                 (if-let (pred (plist-get src :enabled))
                     (cond
                      ((functionp pred)
                       (funcall pred))
                      (t
                       pred))
                   t))
               (mapcar (lambda (src)
                         (if (symbolp src) (symbol-value src) src))
                       sources))))

#+end_src
***** multi-propertize
#+begin_src emacs-lisp
(defun consult-omni--multi-propertize (response-items category pos &optional face)
  "Propertize RESPONSE-ITEMS with the multi-category datum and FACE.

POS and CATEGORY are the group ID and category for these items.

Adopted from `consult--multi-candidates'."
  (let ((annotated-items))
    (dolist (item response-items annotated-items)
      (if (consp item) (setq item (or (car-safe item) item)))
      (let* ((cand (consult--tofu-append item pos)))
        ;; Preserve existing `multi-category' datum of the candidate.
        (if (get-text-property 0 'multi-category cand)
            (when face (add-text-properties 0 (length item) face cand))
          ;; Attach `multi-category' datum and face.
          (add-text-properties 0 (length item)
                               `(multi-category (,category . ,item) ,@face) cand))
        (push cand annotated-items)))))

#+end_src
***** multi-annotate
#+begin_src emacs-lisp
(defun consult-omni--multi-annotate (sources cand)
  "Annotate candidate CAND from multi SOURCES.

Adopted from `consult--multi-annotate'."
  (let ((src (consult--multi-source sources cand)))
    (if-let ((fun (plist-get src :annotate)))
        (cond
         ((functionp fun)
          (funcall fun (cdr (get-text-property 0 'multi-category cand))))
         ((and (symbolp fun) (functionp (eval fun)))
          (funcall (eval fun) (cdr (get-text-property 0 'multi-category cand))))))))

#+end_src
***** update candidates for synchronous sources (sync elisp)
#+begin_src emacs-lisp
(defun consult-omni--multi-update-sync-candidates (async source idx input &rest args)
  "Asynchronously collect candidates for INPUT from a “sync” SOURCE.

This returns a list of candidates with properties suitable
for use in a dynamically updated multi-source command

Description of Arguments:
  ASYNC  a funciton; the sink function that updates the minibuffer
         candidates list
  SOURCE a plist with properties that define the source to search.
         for example see `consult-omni-sources-alist'.
  INPUT  a string; the user's input to pass to the collecting function
         \(e.g. the value of :items field in the SOURCE plist\)
  ARGS   list of ARGS to pass to the collecting function
         \(e.g. the value of :items field in the SOURCE plist\)
  IDX    is passed to `consult-omni--multi-propertize'."
  (let* ((name (plist-get source :name))
         (face (and (plist-member source :face) `(face ,(plist-get source :face))))
         (cat (plist-get source :category))
         (transform (consult-omni--get-source-prop name :transform))
         (fun (plist-get source :items))
         (items))
    (when (functionp fun)
      (cond
       ((and (integerp (cdr (func-arity fun))) (< (cdr (func-arity fun)) 1))
        (setq items (funcall fun)))
       (t (setq items (funcall fun input args)))))
    (when (and items transform)
      (setq items (funcall transform items input)))
    (funcall async (and items (consult-omni--multi-propertize items cat idx face)))
    (funcall async 'refresh)))

#+end_src

***** update candidates for dynamic sources (async elisp)
#+begin_src emacs-lisp
(defun consult-omni--multi-update-dynamic-candidates (async source idx input &rest args)
  "Asynchronously collect candidates for INPUT from a “dynamic” SOURCE.

This returns a list of candidates with properties suitable
for use in a dynamically updated multi-source command

Description of Arguments:
  ASYNC  a funciton; the sink function that updates the minibuffer
         candidates list
  SOURCE a plist with properties that define the source to search.
         for example see `consult-omni-sources-alist'.
  INPUT  a string; the user's input to pass to the collecting function
         \(e.g. the value of :items field in the SOURCE plist\)
  ARGS   list of ARGS to pass to the collecting function
         \(e.g. the value of :items field in the SOURCE plist\)
  IDX    is passed to `consult-omni--multi-propertize'."
  (let* ((name (plist-get source :name))
         (face (and (plist-member source :face) `(face ,(plist-get source :face))))
         (cat (plist-get source :category))
         (transform (consult-omni--get-source-prop name :transform)))
    (funcall (plist-get source :items) input
             :callback (lambda (response-items)
                         (when response-items
                           (when transform (setq response-items (funcall transform response-items input)))
                           (funcall async (consult-omni--multi-propertize response-items cat idx face))
                           (funcall async 'refresh))) args)))

#+end_src


***** update candidates for async sources (async process)
#+begin_src emacs-lisp
(defun consult-omni--multi-update-async-candidates (async source idx input &rest args)
  "Asynchronously collect candidates for INPUT from a “async” SOURCE.

This returns a list of candidates with properties suitable
for use in a dynamically updated multi-source command

Description of Arguments:
  ASYNC  a funciton; the sink function that updates the minibuffer
         candidates list
  SOURCE a plist with properties that define the source to search.
         for example see `consult-omni-sources-alist'
  INPUT  a string; the user's input to pass to the collecting function
         \(e.g. the value of :items field in the SOURCE plist\)
  ARGS   list of ARGS to pass to the collecting function
         \(e.g. the value of :items field in the SOURCE plist\)
  IDX    is passed to `consult-omni--multi-propertize'

This is adopted from `consult--async-process'"
  (let* ((name (plist-get source :name))
         (builder (plist-get source :items))
         (transform (consult-omni--get-source-prop name :transform))
         (filter (consult-omni--get-source-prop name :filter))
         (props (seq-drop-while (lambda (x) (not (keywordp x))) args))
         (proc)
         (proc-buf)
         (count)
         (face (and (plist-member source :face) `(face ,(plist-get source :face))))
         (consult-omni--async-log-buffer (concat " *consult-omni-async-log--" name "*"))
         (cat (plist-get source :category))
         (query (car (consult-omni--split-command input)))
         (args (funcall builder input)))
    (unless (stringp (car args))
      (setq args (car args)))
    (when proc
      (delete-process proc)
      (kill-buffer proc-buf)
      (setq proc nil proc-buf nil))
    (when args
      (let* ((rest "")
             (proc-filter
              (lambda (_ out)
                (let* ((lines (split-string out "[\r\n]+")))
                  (if (not (cdr lines))
                      (setq rest (concat rest (car lines)))
                    (setcar lines (concat rest (car lines)))
                    (let* ((len (length lines))
                           (last (nthcdr (- len 2) lines)))
                      (setq rest (cadr last)
                            count (+ count len -1))
                      (setcdr last nil)
                      (when lines
                        (when (and filter (functionp filter)) (setq lines (funcall filter lines query)))
                        (when (and transform (functionp transform))
                          (setq lines (funcall transform lines query)))
                        (setq lines (mapcar (lambda (line) (propertize line :source name :title line :query query)) lines))
                        (funcall async (consult-omni--multi-propertize lines cat idx face))
                        (funcall async 'refresh)))))))
             (proc-sentinel
              (lambda (_ event)
                (funcall async 'indicator
                         (cond
                          ((string-prefix-p "killed" event)   'killed)
                          ((string-prefix-p "finished" event) 'finished)
                          (t 'failed)))
                (when (and (string-prefix-p "finished" event) (not (equal rest "")))
                  (cl-incf count)
                  (funcall async (list rest)))
                (consult-omni--async-log
                 "consult--async-process sentinel: event=%s lines=%d\n"
                 (string-trim event) count)
                (when (> (buffer-size proc-buf) 0)
                  (with-current-buffer (get-buffer-create consult-omni--async-log-buffer)
                    (goto-char (point-max))
                    (insert ">>>>> stderr >>>>>\n")
                    (let ((beg (point)))
                      (insert-buffer-substring proc-buf)
                      (save-excursion
                        (goto-char beg)
                        (message #("%s" 0 2 (face error))
                                 (buffer-substring-no-properties (pos-bol) (pos-eol)))))
                    (insert "<<<<< stderr <<<<<\n")))))
             (process-adaptive-read-buffering nil))
        (funcall async 'indicator 'running)
        (consult-omni--async-log "consult--async-process started %S\n" args)
        (setq count 0
              proc-buf (generate-new-buffer (concat " *consult-omni-async-stderr-" name "*"))
              proc (apply #'make-process
                          `(,@props
                            :connection-type pipe
                            :name ,(car args)
                            :process-buffer ,proc-buf
                            :noquery t
                            :command ,args
                            :filter ,proc-filter
                            :sentinel ,proc-sentinel)))))
    (when proc (add-to-list 'consult-omni--async-processes `(,proc . ,proc-buf)))))

#+end_src

***** consult-omni--multi-cancel
#+begin_src emacs-lisp
(defun consult-omni--multi-cancel ()
  "Kill asynchronous subprocesses created for async multi-source commands."
  (mapc (lambda (proc) (when proc (delete-process (car proc))
                               (kill-buffer (cdr proc))))
          consult-omni--async-processes)
  (setq consult-omni--async-processes nil)
  (mapc (lambda (timer) (when timer (cancel-timer timer))) consult-omni--dynamic-timers)
  (setq consult-omni--dynamic-timers nil))

#+end_src


***** consult-omni--multi-update-candidates
#+begin_src emacs-lisp
(defun consult-omni--multi-update-candidates (async sources action &rest args)
  "Dynamically update CANDIDATES for multiple SOURCES.

Description of Arguments:
  ASYNC   a function; the sink function
  SOURCES a list; sources to use
  ACTION  a string or symbol; the action argument passed to ASYNC.
          See `consult--async-sink' for more info"
  (let ((idx 0))
    (seq-doseq (src sources)
      (let* ((name (plist-get src :name))
             (items (plist-get src :items))
             (narrow (plist-get src :narrow))
             (async-type (consult-omni--get-source-prop name :type))
             (narrow-type (or (car-safe narrow) narrow -1))
             (err (if consult-omni-log-level 'err nil)))
        (when (or (eq consult--narrow narrow-type)
                  (not (or consult--narrow (plist-get src :hidden))))
          (condition-case err
              (progn
                (when (functionp items)
                  (cond
                   (; sync source, append candidates right away
                    (equal async-type 'sync)
                    (consult-omni--multi-update-sync-candidates async src idx action args))
                   (; async source, append candidatesin process
                    (equal async-type 'async)
                    (consult-omni--multi-update-async-candidates async src idx action args))
                   (; dynamic source, append candidates in a callback function
                    (equal async-type 'dynamic)
                    (consult-omni--multi-update-dynamic-candidates async src idx action args))
                   (t
                    (message "source %s needs a :type keyword. See the documentation for `consult-omni-define-source'." name)))))
            (error ;; message other erros
             (funcall async 'indicator 'killed)
             (message (if consult-omni-log-level
                          (format "error in calling :items of %s source - %s" name (error-message-string err))
                        (format "error in calling :items of %s source" name)))
             nil))))
      (cl-incf idx))))

#+end_src

***** collect candidates form multiple sources
#+begin_src emacs-lisp
(defun consult-omni--multi-dynamic-collection (async sources &rest args)
  "Dynamically compute candidates from SOURCES.

This is a generalized replacement for `consult--async-process', and
`consult--dynamic-collection' that allows collecting candidates from
synchronous (e.g. elisp funciton with no input args), dynamic (e.g. elip
function with input args), or asynchronous (e.g. shell process) SOURCES.

Description of Arguments:
  ASYNC   a funciton; the sink function
  SOURCES a list; sources to use
  ARGS    a list of args; extra arguments passed to each source
          ARGS is passed to `consult-omni--multi-update-candidates'"
  (setq async (consult--async-indicator async))
  (let ((consult-omni--async-processes (list))
        (consult-omni--dynamic-timers (list))
        (current))
    (lambda (action)
      (pcase action
        ('nil
         (funcall async nil))
        (""
         (setq current nil)
         (consult-omni--multi-cancel)
         (funcall async 'flush)
         (funcall async 'indicator 'finished))
        ((pred stringp)
         (if (equal action current)
             (funcall async 'indicator 'finished)
           (progn
             (setq current action)
             (consult-omni--multi-update-candidates async sources action args)
             (funcall async 'refresh))))
        ((or 'destroy 'cancel)
         (consult-omni--multi-cancel)
         (funcall async action))
        (_ (funcall async action))))))

#+end_src



***** dynamic command
#+begin_src emacs-lisp
(defun consult-omni--multi-dynamic-command (sources &rest args)
  "Dynamically collect with input splitting on multiple SOURCES.

ARGS is passed to each source \(by passing it along with SOURCES to
`consult-omni--multi-dynamic-collection'\).

This is a generalized form of `consult--async-command'
and `consult--dynamic-compute' that allows synchronous, dynamic,
and asynchronous sources."
  (declare (indent 1))
  (thread-first
    (consult--async-sink)
    (consult--async-refresh-timer)
    (consult-omni--multi-dynamic-collection sources args)
    (consult--async-throttle)
    (consult--async-split)))

#+end_src

***** consult-omni--multi-dynamic
#+begin_src emacs-lisp
(cl-defun consult-omni--multi-dynamic (sources args &rest options)
  "Select candidates with dynamic input from a list of SOURCES.

This is similar to `consult--multi' but with dynamic update of candidates
and accepts async (shell commands simlar to `consult--grep'),
or dynamic sources (elisp functions like `consult-line-multi') as well.

Description of Arguments:
  SOURCES a list; sources to use
  ARGS    list of args; additional arguments sent to each SOURCE's
          collection function.
  OPTIONS are similar to options in `consult--multi'."
  (let* ((sources (consult-omni--multi-enabled-sources sources))
         (selected
          (apply #'consult--read
                 (consult-omni--multi-dynamic-command sources args)
                 (append
                  options
                  (list
                   :sort        nil
                   :history     '(:input consult-omni--search-history)
                   :initial     (consult--async-split-initial nil)
                   :category    'multi-category
                   :predicate   (apply-partially #'consult-omni--multi-predicate sources)
                   :annotate    (apply-partially #'consult-omni--multi-annotate sources)
                   :group       (apply-partially #'consult-omni--multi-group sources)
                   :lookup      (apply-partially #'consult-omni--multi-lookup sources)
                   :preview-key (consult--multi-preview-key sources)
                   :narrow      (consult--multi-narrow sources)
                   :state       (consult--multi-state sources))))))
    (if (plist-member (cdr selected) :match)
        (when-let (fun (plist-get (cdr selected) :new))
          (funcall fun (car selected))
          (plist-put (cdr selected) :match 'new))
      (when-let (fun (plist-get (cdr selected) :action))
        (funcall fun (car selected)))
      (setq selected `(,(car selected) :match t ,@(cdr selected))))
    selected))

#+end_src


** Macro
*** make a variable for source
**** make symbol for source name
#+begin_src emacs-lisp
(defun consult-omni--source-name (source-name &optional suffix)
  "Return a symbol for SOURCE-NAME variable with optional SUFFIX.

The variable is consult-omni--source-%s (%s=source-name).
Adds SUFFIX to the name if provided."
  (intern (format "consult-omni--source-%s" (concat (replace-regexp-in-string " " "-" (downcase source-name)) (if suffix (downcase suffix) nil)))))

#+end_src
**** make generic docstring for varibale of source
#+begin_src emacs-lisp
(defun consult-omni--source-generate-docstring (source-name)
  "Make a generic documentation string for SOURCE-NAME.

This is used in `consult-omni-define-source' macro to make generic
docstrings for variables."
  (format "consult-omni source for %s.\n \nThis variable was created by the macro `consult-omni-define-source'."
          (capitalize source-name)))

#+end_src
*** make a function for source
**** make a function symbol for source
#+begin_src emacs-lisp
(defun consult-omni--func-name (source-name &optional prefix suffix)
  "Make a function symbol for SOURCE-NAME with optional PREFIX and SUFFIX.

This is used to make interactive command symbols.

Adds PREFIX and SUFFIX to the name if non-nil."
  (intern (concat "consult-omni-" (if prefix prefix)
                  (replace-regexp-in-string " " "-" (downcase source-name))
                  (if suffix suffix))))
#+end_src
**** make generic doctring for function of source
#+begin_src emacs-lisp
(defun consult-omni--func-generate-docstring (source-name &optional dynamic)
  "Make a generic documentaion string for an interactive command.

DEscription of Arguments:

  SOURCE-NAME a string; name of the source \(e.g. “Google”\)
  DYNAMIC     a boolean; whether the funciton is dynamic or not.
              dynamic here means dynamic completion in minibuffer like
              consult-grep behavior.

This is used to make docstring for function made by
`consult-omni-define-source'."
  (concat (if dynamic "Dynamic interactive" "Interactive ")
          (format "command to search %s."
                  (capitalize source-name))
          "\n\n This function was created by the macro `consult-omni-define-source'."))

#+end_src
*** make a consult--read source list
#+begin_src emacs-lisp
(defun consult-omni--make-source-list (source-name request annotate face narrow-char state preview-key category lookup group require-match sort enabled predicate select-hist add-hist)
  "Internal function to make a source for `consult-omni--multi'.

Do not use this function directly, use `consult-omni-define-source' macro
instead.  Refer to `consult-omni-define-source' for details on
SOURCE-NAME, REQUEST, ANNOTATE, FACE, NARROW-CHAR, STATE, PREVIEW-KEY,
CATEGORY, LOOKUP, GROUP, REQUIRE-MATCH, SORT, ENABLED, PREDICATE,
SELECT-HIST, and ADD-HIST."
  `(:name ,source-name
          ,(when (and annotate face) :face)
          ,(when (and annotate face)
             (cond
              ((eq face t)
               'consult-omni-default-face)
              (t face)))
          :narrow ,narrow-char
          :state ,(or state #'consult-omni--dynamic-state-function)
          :category ,(or category 'consult-omni)
          :history ,select-hist
          :add-history ,(or add-hist #'consult-omni--add-history)
          :items  ,request
          :annotate ,(cond
                      ((and annotate (functionp annotate))
                       annotate)
                      ((eq annotate t)
                       #'consult-omni--annotate-function)
                      (t nil))
          :lookup ,(if (and lookup (functionp lookup))
                       lookup
                     #'consult-omni--lookup-function)
          :group ,(or group #'consult-omni--group-function)
          :preview-key ,(and consult-omni-show-preview (or preview-key consult-omni-preview-key))
          ,(when enabled ':enabled)
          ,(when enabled enabled)
          :sort ,sort
          ,(when predicate ':predicate)
          ,(when predicate predicate)
          :require-match ,require-match))

#+end_src

*** make a static interactive command
#+begin_src emacs-lisp

(defun consult-omni--call-static-command (input prompt no-callback args request face state source-name category lookup require-match select-hist-var annotate preview-key sort)
  "Internal function to make static `consult--read' command.

Do not use this function directly, use `consult-omni-define-source' macro
instead.  Refer to `consult-omni-define-source' for details on INPUT,
PROMPT, NO-CALLBACK, ARGS, REQUEST, FACE, STATE, SOURCE-NAME, CATEGORY,
LOOKUP, REQUIRE-MATCH, SELECT-HIST-VAR, ANNOTATE, PREVIEW-KEY, and SORT."
  (let* ((input (or input
                    (and consult-omni-default-autosuggest-command (funcall-interactively consult-omni-default-autosuggest-command))
                    (consult-omni--read-search-string)))
         (setup (consult-omni--get-source-prop source-name :on-setup))
         (exit (consult-omni--get-source-prop source-name :on-exit))
         (prompt (or prompt (concat "[" (propertize (format "%s" (consult-omni--func-name source-name)) 'face 'consult-omni-prompt-face) "]" " Search: ")))
         (_ (if (functionp setup) (funcall setup)))
         (selected (consult-omni--multi-static (list (consult-omni--source-name source-name))
                                               input
                                               args
                                               :prompt prompt
                                               :sort sort
                                               :history select-hist-var
                                               :require-match require-match))
         (_ (if (functionp exit) (funcall exit)))
         (match (plist-get (cdr selected) :match))
         (source  (plist-get (cdr selected) :name))
         (selected (cond
                    ((consp selected) (car-safe selected))
                    (t selected)))
         (selected (if match selected (string-trim selected (consult--async-split-initial nil))))
         (callback-func (and (not no-callback)
                             (or (and match source (consult-omni--get-source-prop source :on-callback))
                                 (and source (consult-omni--get-source-prop source :on-new))))))
    (unless consult-omni-log-level
      (consult-omni--kill-hidden-buffers)
      (consult-omni--kill-url-dead-buffers))
    (cond
     ((and match (functionp callback-func))
      (funcall callback-func selected))
     ((functionp callback-func)
      (setq selected (funcall callback-func selected))))
    selected))

#+end_src
*** make a dynamic interactive command
#+begin_src emacs-lisp
(defun consult-omni--call-dynamic-command (initial prompt no-callback args source-name request category face lookup require-match search-hist-var select-hist-var add-hist preview-key sort)
  "Internal function to make dynamic `consult--read' command.

Do not use this function directly, use `consult-omni-define-source' macro
instead.  Refer to `consult-omni-define-source' for details on INITIAL,
PROMPT, NO-CALLBACK, ARGS, SOURCE-NAME, REQUEST, CATEGORY, FACE, LOOKUP,
REQUIRE-MATCH, SEARCH-HIST-VAR, SELECT-HIST-VAR, ADD-HIST, PREVIEW-KEY,
and SORT."

  (let* ((consult-async-refresh-delay consult-omni-dynamic-refresh-delay)
         (consult-async-input-throttle consult-omni-dynamic-input-throttle)
         (consult-async-input-debounce consult-omni-dynamic-input-debounce)
         (setup (consult-omni--get-source-prop source-name :on-setup))
         (exit (consult-omni--get-source-prop source-name :on-exit))
         (prompt (or prompt (concat "[" (propertize (format "%s" (consult-omni--func-name source-name)) 'face 'consult-omni-prompt-face) "]" " Search: ")))
         (_ (if (functionp setup) (funcall setup)))
         (selected (consult-omni--multi-dynamic (list (consult-omni--source-name source-name))
                                                args
                                                :prompt prompt
                                                :history '(:input search-hist-var)
                                                :add-history (or add-hist (consult-omni--add-history))
                                                :initial (consult--async-split-initial initial)
                                                :sort sort
                                                :require-match require-match))
         (_ (if (functionp exit) (funcall exit)))
         (match (plist-get (cdr selected) :match))
         (source  (plist-get (cdr selected) :name))
         (selected (cond
                    ((consp selected) (car selected))
                    (t selected)))
         (selected (if match selected (string-trim selected (consult--async-split-initial nil))))
         (title (get-text-property 0 :title selected))
         (callback-func (and (not no-callback)
                             (or (and match source (consult-omni--get-source-prop source :on-callback))
                                 (and source (consult-omni--get-source-prop source :on-new))))))
    (add-to-history select-hist-var title)
    (unless consult-omni-log-level
      (consult-omni--kill-hidden-buffers)
      (consult-omni--kill-url-dead-buffers))
    (cond
     ((and match (functionp callback-func))
      (funcall callback-func selected))
     ((functionp callback-func)
      (setq selected (funcall callback-func selected))))
    selected))

#+end_src
*** macro to add a new source

#+begin_src emacs-lisp
;;; Macros

;;;###autoload
(cl-defmacro consult-omni-define-source (source-name &rest args &key type request transform filter on-setup on-preview on-return on-exit state on-callback on-new require-match interactive lookup group narrow-char category search-hist select-hist add-hist face annotate enabled sort predicate preview-key docstring  &allow-other-keys)
  "Macro to make a consult-omni-source for SOURCE-NAME with ARGS.

Generates the following:
  - a source plist
  - interactive commands \(static or dynamic\) for single source
  - adds a new row to to `consult-omni--sources-alist' with all the
    metadata as a property list.

Description of Arguments:

  Brief Description:

  ==========   ========  ==============================================
  Keyword      Type      Explanation
  ==========   ========  ==============================================
  TYPE         symbol    How to collect items for source?
                         \(one of \='sync, \='dynamic, or \='async\)
  REQUEST      function  Fetch results from source
  TRANSFORM    funciton  Function to transform/format candidates
  FILTER       funciton  Function to filter candidates
  ON-SETUP     function  Setup action in `consult--read'
  ON-PREVIEW   function  Preview action in `consult--read'
  ON-RETURN    function  Return action in `consult--read'
  ON-EXIT      function  Exit action in `consult--read'
  STATE        function  STATE passed to `consult--read'
                         (bypasses ON-PREVIEW and ON-RETURN)
  ON-CALLBACK  function  Function called on selected candidate
  ON-NEW       function  Function called on non-existing candidate
  REUIRE-MATCH function  Can non-matching candidates be selected
  INTERACTIVE  symbol    make \='dynamic, \='static or \='both commands
  LOOKUP       function  Lookup function for `consult--read'
  GROUP        function  Passed as GROUP to `consult--read'
  NARROW-CHAR  char      Passed as NARROW to `consult-read'
  CATEGORY     symbol    Passed as CATEGORY to `consult--read'
  SEARCH-HIST  symbol    Passed as HISTORY to `consult--read'
  SELECT-HIST  symbol    Collects list of selected items
  ADD-HIST     list      List of items to add to the history.
  FACE         face      Passed as FACE to `consult--read-multi'
  ANNOTATE     function  Passed as ANNOTATE to `consult--read'
  ENABLED      function  Passed as ENABLED to `consult--read'
  SORT         boolean   Passed as SORT to `consult--read'
  PREDICATE    function  Passed as PREDICATE to `consult--read'
  PREVIEW-KEY  key       Passed as PREVIEW-KEY to `consult--read'
  DOCSTRING    string    DOCSTRING for the SOURCE-NAME variable
  =====================================================================

  Detailed Decription:

  TYPE can be \='sync, \='dynamic or \='async, depending on how the items
       for the source should be collected.
       - \='sync    sources get their candidates from a synchronous elisp
                    function \(i.e. a function that returns a list\).
       - \='dynamic sources use an elisp function that runs asynchronously
                    to produce list of candidates \(e.g. a web request that
                    runs in the background\)
       - \='async   sources run a shell process \(e.g. a command line\)
                    asynchronously and return the results \(lines from
                    stdout\) as list of candidates.
       Note that all three types can have dynamic completion
       \(meaning that the funciton takes an input argument and returns
       the result based on the input\), but the difference is whether the
       function uses synchronous or asynchronous collection and whether it
       is an elsip function or a shell subprocess.

  REQUEST is a function that returns the list of candidates.
          - In synchronous sources, REQEUEST can take 0 or 1 input
            argument, and returns a list of candidates.
          - In asynchronous sources, REQUEST takes at least 1 input
            argument, and returns a list of strings that are command line
            process arguments.
          - In dynamic sources, REQUEST takes at least 1 input argument and
            a keyword argument called CALLBACK.  The CALLBACK should be
            called with candidates as input in the body.
            Here is the recommended format:
            (cl-defun REQUEST (input
                               &rest args
                               &key callback
                               &allow-other-keys)
              BODY
              (when callback (funcall callback candidates))
              candidates)
           See `consult-omni--brave-fetch-results' and
           `consult-omni--grep-builder' for examples.  More examples
           can be found in the wiki pages of the repo or in
           Lisp files under “sources” directory.

  TRANSFORM is a function that takes a list of candidates (e.g. strings)
            and optionally the query string and returns a list of
            transformed/formatted strings.  It's called with
            (funcall tranform candidates query).
            This is especially useful for async sources
            where the process returns a list of candiate strings,
            in which case TRANSFORM is applied to all candiates using `mapcar'.
            See `consult-omni--grep-transform' for an example.

  FILTER is a function that takes a list of candidates (e.g. strings)
         and optionally the query string and returns a list of filtered
         strings.  It's called with `(funcall filter candidates query)`.
         This is especially useful for async sources
         where the process returns a list of candiate strings,
         in which case FILTER is applied to all candidates using `seq-filter'.
         See `consult-omni--locate-filter' for an example.

  ON-SETUP is a function called when setting up the minibuffer.
           This is used inside an state funciton by `consult--read.
           See and its `consult--read' and state functions for more info.

  ON-PREVIEW is used as a function to call on the candidate, when a
             preview is requested.  It takes one required argument, the
             candidate.  For an example, see
             `consult-omni-default-preview-function'.

  ON-RETURN is used as a function to call on the candidate, when the
            candidate is selected.  This is passed to consult built-in
            state function machinery.  Note that in consult-omni's commands
            the output of this function will be returned, and ON-CALLBACK
            is used to do further actions on this returned value.  This
            allows to separate the returned value from the commands and
            actions that run on the selected candidates.  Therefore, for
            most use cases, ON-RETURN can just be `#'identity' to get the
            candidate back as it is.  But, if some transformation is
            needed, ON-RETURN can be used to transform the selected
            candidate.

  ON-EXIT is a function called when exiting the minibuffer.
          This is used inside an state funciton by `consult--read.
          See `consult--read' and its state functions for more info.

  STATE is a function that takes no argument and returns a function for
        consult--read STATE argument.  For an example see
        `consult-omni--dynamic-state-function' that builds state function
        based on ON-PREVIEW and ON-RETURN.  If STATE is non-nil, instead of
        using ON-PREVIEW and ON-RETURN to make a state function, STATE will
        be directly used in consult--read.

  ON-CALLBACK is a function that is called with one required input
              argument, the selected candidate.
              For example, see `consult-omni--default-callback'
              that opens the url of the candidate in the default browser.
              Other examples can be found in the wiki pages of the repo or
              in Lisp files under “source” directory.

  ON-NEW is similiar to ON-CALLBACK but for new non-pre-existing
         candidates, in other words the minibuffer content itself.  This is
         useful for example in autosuggestion commands, to get the query
         itself rather than a suggestion.

  REQUIRE-MATCH is a boolean.  When non-nil non-matching candidates \(e.g.
                the minibuffer content itself\) can be selected as a
                candidate.

  INTERACTIVE can be a symbol of the list:
         - If \='dynamic, only \*dynamic\* interactive commands are created
           in this macro.
         - If \='static, only \*static\* interactive commands are created
           in this macro.
         - Otherwise, \*Both\* dynamic and static
           commands are created.

  LOOKUP is passed to `consult--read'.
  GROUP is passed to `consult--read'.
  ANNOTATE is passed to `consult--read'.
  NARROW-CHAR is passed to `consult--read'.
  CATEGORY is passed to `consult--read'.
  ENABLED is passed to `consult--read'.
  SORT is passed to `consult--read'.
  PREVIEW-KEY is passed to `consult--read'.
    See consult's Documentaion for more details.

  SEARCH-HIST is a history list varibale to keep records of search terms.
  SELECT-HIST is a history list varibale to keep records of selected
              candidates.
  ADD-HIST is a list of items to add to the history list.

  FACE is used to format the candidate.  This is useful for simple
       formating without making use of TRANSFORM or formating candidates
       inside the REQUEST function.

  DOCSTRING is used as docstring for the variable consult-omni--source-%s
            variable that this macro creates for SOURCE-NAME."
  (if (symbolp source-name) (setq source-name (eval source-name)))
  `(progn
     ;; make a variable called consult-omni--source-%s (%s=source-name)
     (defvar ,(consult-omni--source-name source-name) nil)
     (setq ,(consult-omni--source-name source-name) (consult-omni--make-source-list ,source-name ,request ,annotate ,face ,narrow-char ,state ,preview-key ,category ,lookup ,group ,require-match ,sort ,enabled ,predicate ,select-hist ,add-hist))
     ;; make a dynamic interactive command called consult-omni-%s (%s=source-name)
     (unless (eq ,interactive 'dynamic)
       (defun ,(consult-omni--func-name source-name) (&optional initial prompt no-callback &rest args)
         ,(or docstring (consult-omni--func-generate-docstring source-name t))
         (interactive "P")
         (consult-omni--call-dynamic-command initial prompt no-callback args ,source-name ,request ,category ,face ,lookup ,require-match ,search-hist ,select-hist ,add-hist ,preview-key ,sort)))
     ;; make a static interactive command called consult-omni-%s-static (%s=source-name)
     (unless (eq ,interactive 'static)
       (defun ,(consult-omni--func-name source-name nil "-static") (&optional input prompt no-callback &rest args)
         ,(or docstring (consult-omni--func-generate-docstring source-name))
         (interactive "P")
         (consult-omni--call-static-command input prompt no-callback args ,request ,face ,state ,source-name ,category ,lookup ,require-match ,select-hist ,annotate ,preview-key ,sort)))
     ;; add source to consult-omni--sources-alist
     (add-to-list 'consult-omni--sources-alist (cons ,source-name
                                                     (list :name ,source-name
                                                           :type ,type
                                                           :require-match ,require-match
                                                           :source (consult-omni--source-name ,source-name)
                                                           :face ,face
                                                           :request-func ,request
                                                           :transform ,transform
                                                           :filter ,filter
                                                           :on-setup ,on-setup
                                                           :on-preview (or ,on-preview #'consult-omni--default-url-preview)
                                                           :on-return (or ,on-return #'identity)
                                                           :on-exit ,on-exit
                                                           :on-callback (or ,on-callback #'consult-omni--default-callback)
                                                           :on-new (or ,on-new #'consult-omni--default-new)
                                                           :state ,state
                                                           :group ,group
                                                           :annotate ,annotate
                                                           :narrow-char ,narrow-char
                                                           :preview-key ,preview-key
                                                           :category (or ',category 'consult-omni)
                                                           :search-hist ,search-hist
                                                           :select-hist ,select-hist
                                                           :add-hist ,add-hist
                                                           :intactive ,interactive
                                                           :static-command (and (functionp (consult-omni--func-name ,source-name nil "-static")) (consult-omni--func-name ,source-name nil "-static"))
                                                           :dynamic-command (and (functionp (consult-omni--func-name ,source-name)) (consult-omni--func-name ,source-name))
                                                           :enabled ,enabled
                                                           :sort ,sort
                                                           :predicate ,predicate)))
     ,source-name))

#+end_src
*** make source for consult-omni from consult source
**** make fetch function
#+begin_src emacs-lisp
;;;###autoload
(cl-defmacro consult-omni--make-fetch-function (source &rest args &key source-name docstring &allow-other-keys)
  "Make a function for fetching result based on SOURCE with ARGS.

Description of Arguments:
SOURCE       a source for consult \(e.g. a plist that is passed
             to consult--multi\).  See `consult-buffer-sources' for
             examples.
SOURCE-NAME  a string name for SOURCE
DOCSTRING    the docstring for the function that is returned."
  (let* ((source (if (plistp source) source (eval source)))
         (source-name (substring-no-properties (plist-get source :name))))
    `(progn
       ;; make a function that creates a consult--read source for consult-omni-multi
       (cl-defun ,(consult-omni--source-name source-name "-fetch-results") (input &rest args &key callback &allow-other-keys)
         ,(or docstring (format "Fetch results from %s for consult-omni.\n\n This funciton was created by `consult-omni--make-fetch-function'." source-name))
         (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input args))
                      (opts (car-safe opts))
                      (fun  (plist-get ',source :items))
                      (results (cond
                                ((functionp fun) (funcall fun))
                                ((listp fun) fun)
                                ))
                      (source (substring-no-properties (plist-get ',source :name))))
           (delq nil (mapcar (lambda (item)
                               (if (consp item) (setq item (or (car-safe item) item)))
                               (when (string-match (concat ".*" query ".*") item)
                                 (propertize item
                                             :source source
                                             :title item
                                             :url nil
                                             :query query
                                             :search-url nil)))
                             results)))))))

#+end_src
**** define source from consult source
#+begin_src emacs-lisp
(cl-defun consult-omni--make-source-from-consult-source (consult-source &rest args &key type request transform on-setup on-preview on-return on-exit state on-callback on-new group narrow-char category interactive search-hist select-hist face annotate enabled sort predicate preview-key require-match docstring &allow-other-keys)
  "Make a consult-omni source from a consult source plist, CONSULT-SOURCE.

all ARGS are passed to `consult-omni-define-source' macro.

See `consult-omni-define-source' for more details on TYPE, REQUEST,
TRANSFORM, ON-SETUP, ON-PREVIEW, ON-RETURN, ON-EXIT, STATE, ON-CALLBACK,
ON-NEW, GROUP, NARROW-CHAR, CATEGORY, INTERACTIVE, SEARCH-HIST,
SELECT-HIST, FACE, ANNOTATE, ENABLED, SORT, PREDICATE, PREVIEW-KEY,
REQUIRE-MATCH, DOCSTRING."
  (let* ((source (if (plistp consult-source) consult-source (and (boundp consult-source) (eval consult-source))))
         (source (if (plistp source) source (eval source)))
         (name (and (plistp source) (substring-no-properties (plist-get source :name))))
         (narrow-char (or narrow-char (and (plistp source) (plist-get source :narrow))))
         (narrow-char (if (listp narrow-char) (car narrow-char)))
         (face (or face (and (plistp source) (plist-get source :face))))
         (state (or state (and (plistp source) (plist-get source :state))))
         (annotate (cond
                    ((eq annotate 'nil) nil)
                    ((eq annotate 't) (and (plistp source) (plist-get source :annotate)))
                    (t annotate)))
         (preview-key (or preview-key (and (plistp source) (plist-get source :preview-key)) consult-omni-preview-key))
         (predicate (or predicate (and (plistp source) (plist-get source :predicate))))
         (require-match (if (plist-member args :require-match)
                            (plist-get args :require-match)
                          (and (plistp source) (plist-get source :require-match))))
         (group (or group (and (plistp source) (plist-get source :group))))
         (sort (or sort (and (plistp source) (plist-get source :sort))))
         (enabled (or enabled (and (plistp source) (plist-get source :enabled))))
         (category (or category (and (plistp source) (plist-get source :category)) 'consult-omni)))
    (eval (macroexpand
           `(consult-omni-define-source ,name
                                        :docstring ,docstring
                                        :narrow-char ,narrow-char
                                        :face ',face
                                        :category ',category
                                        :type ',type
                                        :request (or ,request (consult-omni--make-fetch-function ,source))
                                        :transform ,transform
                                        :on-setup ',on-setup
                                        :on-preview ',on-preview
                                        :on-return ',on-return
                                        :on-exit ',on-exit
                                        :on-callback ',on-callback
                                        :on-new ',on-new
                                        :preview-key ,preview-key
                                        :search-hist ',search-hist
                                        :select-hist ',select-hist
                                        :enabled ',enabled
                                        :predicate ',predicate
                                        :group ',group
                                        :sort ',sort
                                        :interactive ',interactive
                                        :annotate ',annotate
                                        :require-match ',require-match)))))

#+end_src

** Frontend Interactive commands
*** consult-omni-multi
#+begin_src emacs-lisp
;;; Interactive Commands

;;;###autoload
(defun consult-omni-multi (&optional initial prompt sources no-callback &rest args)
  "Interactive “multi-source dynamic search”.

This is an interactive command that fetches results form all the sources
in either SOURCES or in `consult-omni-multi-sources' with dynamic
completion meaning that the search term can be dynamically updated by the
user and the results are fetched as the user types in the miinibuffer.

Description of Arguments:

  INITIAL     a string; the initial search prompt in the minibuffer.
  PROMPT      a string; an optional minibuffer prompt
  SOURCES     a list of strings or symbols;
              - strings can be the name of a source, a key from
                `consult-omni--sources-alist', which can be made with
                the convinient macro `consult-omni-define-source' or by
                using `consult-omni--make-source-from-consult-source'.
              - symbols can be other consult sources
                (see `consult-buffer-sources' for example.)
              If SOURCES is nil, `consult-omni-multi-sources' is used
              instead.
  NO-CALLBACK a boolean; If t, only the selected candidate is returned
              without any callback action.

Other Features:

Additional commandline arguments can be passed in the minibuffer
entry similar to `consult-grep' by typing `--` followed by arguments.
These additional arguments are passed to async sources similar to
`consult-grep' syntax.  In addition, other arguments can be passed
to all sources by using key, val pairs \(e.g. “:group domain”\)

For example the user can enter:
  “#consult-omni -- :g domain”
This will run a search on all the sources for
the term “consult-omni” and then groups the results by the “domain
of the URL” of the results.

Built-in arguments include:
  - :g, or :group for grouping (see `consult-omni-group-by' and
    `consult-omni--override-group-by' for more info.)
  - :n, or :count is passed as the value for COUNT to any source in
    `consult-omni-multi-sources'.
  - :p, or :page is passed as the value for PAGE to any source in
    `consult-omni-multi-sources'.

Custom arguments can be passed by using “:ARG value”.
For example, if the user types the following in the minibuffer:
  “#how to do web search in emacs? -- :model gpt-4”
The term “how to do web search in emacs?” is passed as the search
term and the “gpt-4” as a keyword argument for :model to every
source in `consult-omni-multi-sources'.  If any request function of
the sources takes a keyword argument for :model, “gpt-4” is
used then.

Once the results are fetched, narrowing down can be done by
using `consult-async-split-style' syntax \(e.g. “#” for “perl” style\)
after the serach term, similar to `consult-grep'.
For example:
  “#consult-omni#github.com”
uses “consult-omni” as the search term, and then narrows the choices to
results that have “github.com” in them.

For more examples, refer to the official documentation of the repo here:
URL `https://github.com/armindarvish/consult-omni'.

For more details on consult--async functionalities, you can also
see `consult-grep' and the official manual of consult, here:
URL `https://github.com/minad/consult'."
  (interactive "P")
  (let* ((consult-async-refresh-delay consult-omni-dynamic-refresh-delay)
         (consult-async-input-throttle consult-omni-dynamic-input-throttle)
         (consult-async-input-debounce consult-omni-dynamic-input-debounce)
         (sources (or sources consult-omni-multi-sources))
         (sources (remove nil (mapcar (lambda (source)
                                        (cond
                                         ((stringp source)
                                          (consult-omni--get-source-prop source :source))
                                         ((symbolp source)
                                          source)))
                                      sources)))
         (prompt (or prompt (concat "[" (propertize "consult-omni-multi" 'face 'consult-omni-prompt-face) "]" " Search:  ")))
         (selected
          (consult-omni--multi-dynamic
           sources
           args
           :prompt prompt
           :sort t
           :require-match nil
           :history '(:input consult-omni--search-history)
           :add-history (consult-omni--add-history '(symbol))
           :initial (consult--async-split-initial initial)))
         (match (plist-get (cdr selected) :match))
         (source  (plist-get (cdr selected) :name))
         (selected (cond
                    ((consp selected) (car-safe selected))
                    (t selected)))
         (selected (if match selected (string-trim selected (consult--async-split-initial nil))))
         (callback-func (and (not no-callback)
                             (or (and match source (consult-omni--get-source-prop source :on-callback))
                                 #'consult-omni--default-new))))
    (unless consult-omni-log-level
      (consult-omni--kill-hidden-buffers)
      (consult-omni--kill-url-dead-buffers))
    (cond
     ((and match (functionp callback-func))
      (funcall callback-func selected))
     ((functionp callback-func)
      (setq selected (funcall callback-func selected))))
    selected))
#+end_src
*** consult-omni-multi-static
#+begin_src emacs-lisp
;;;###autoload
(defun consult-omni-multi-static (&optional input prompt sources no-callback &rest args)
  "Interactive “static” multi-source search.

This commands asks user for an input \(a.k.a. a search term\) and fetches
results from all the sources in either SOURCES or in
`consult-omni-multi-sources' and present the result candidates in
minibuffer completion for user to select.

Description of Arguments:

  INPUT       a string; the initial search term.  If non-nil the user
              is queried for one with either
              `consult-omni-default-autosuggest-command' or
              `consult-omni--read-search-string'
  PROMPT      a string; an optional minibuffer prompt
  SOURCES     a list of strings or symbols:
                - strings can be name of a source, a key from
                  `consult-omni--sources-alist', which can be made with the
                  convinient macro `consult-omni-define-source' or by using
                  `consult-omni--make-source-from-consult-source'.
                - symbols can be other consult sources
                  (see `consult-buffer-sources' for example.)
              If SOURCES is nil, `consult-omni-multi-sources' is used
              instead.
  NO-CALLBACK a boolean; If t, only the selected candidate is returned
              without any callback action."
  (interactive "P")
  (let* ((input (or input
                    (and consult-omni-default-autosuggest-command  (funcall consult-omni-default-autosuggest-command))
                    (consult-omni--read-search-string)))
         (input (if (stringp input) (substring-no-properties input)))
         (sources (or sources consult-omni-multi-sources))
         (sources (remove nil (mapcar (lambda (source)
                                        (cond
                                         ((stringp source)
                                          (consult-omni--get-source-prop source :source))
                                         ((symbolp source)
                                          source)))
                                      sources)))
         (prompt (or prompt (concat "[" (propertize "consult-omni-multi-static" 'face 'consult-omni-prompt-face) "]" " Search:  ")))
         (selected (consult-omni--multi-static sources
                                               input
                                               args
                                               :prompt prompt
                                               :require-match nil
                                               :history 'consult-omni--selection-history
                                               :sort t))
         (match (plist-get (cdr selected) :match))
         (source  (plist-get (cdr selected) :name))
         (selected (cond
                    ((consp selected) (car-safe selected))
                    (t selected)))
         (selected (if match selected (string-trim selected (consult--async-split-initial nil))))
         (callback-func (and (not no-callback)
                             (or (and match source (consult-omni--get-source-prop source :on-callback))
                                 #'consult-omni--default-new))))
    (unless consult-omni-log-level
      (consult-omni--kill-hidden-buffers)
      (consult-omni--kill-url-dead-buffers))
    (cond
     ((and selected match (functionp callback-func))
      (funcall callback-func selected))
     ((and selected (functionp callback-func))
      (setq selected (funcall callback-func selected))))
    selected))

#+end_src
*** consult-omni
#+begin_src emacs-lisp
;;;###autoload
(defun consult-omni (&rest args)
  "Convinient wrapper function for favorite interactive command.

Calls the function in `consult-omni-default-interactive-command' with
ARGS."
  (interactive)
  (apply consult-omni-default-interactive-command args))

#+end_src
** Provide and Footer
#+begin_src emacs-lisp
;;; provide `consult-omni' module

(provide 'consult-omni)

;;; consult-omni.el ends here
#+end_src

* embark
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./consult-omni-embark.el
:END:
** Header
#+begin_src emacs-lisp
;;; consult-omni-embark.el --- Embark Actions for `consult-omni' -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish


;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; provides Embark actions for consult-omni
;;; Code:
#+end_src
** Requirements
#+begin_src emacs-lisp
;;; Requirements

(require 'consult-omni)
(require 'embark-consult)

#+end_src
** Define Group, Customs, Vars, Etc.
*** customization variables
#+begin_src emacs-lisp
;;; User Options (a.k.a. Custom Variables)
;;  The following user options modify the behavior of consult-omni-embark.

(defcustom consult-omni-embark-default-term  #'eshell
  "Consult-omni default terminal to use in embark actions."
  :group 'consult-omni
  :type '(choice (function :tag "(Default) eshell" #'eshell)
                 (function :tag "shell" #'shell)
                 (function :tag "term" #'term)
                 (function :tag "ansi-term" #'ansi-term)
                 (function :tag "vterm" #'vterm)
                 (function :tag "vterm" #'eat)
                 (function :tag "Custom Function" function)))
#+end_src

*** other variables
*** define faces

** General
*** actions
#+begin_src emacs-lisp
;;; Define Embark Action Functions
;; Embark actions for general sources (e.g. search engines)

(defun consult-omni-embark-default-action (cand)
  "Call the default action on CAND.

Gets the default callback function from `consult-omni--sources-alist'."
  (let* ((source (and (stringp cand) (get-text-property 0 :source cand))))
    (funcall (consult-omni--get-source-prop source :on-callback) cand)))

(add-to-list 'embark-default-action-overrides '(consult-omni . consult-omni-embark-default-action))

(defun consult-omni-embark-insert-title (cand)
  "Insert the title of CAND at point."
  (if-let ((title (and (stringp cand) (get-text-property 0 :title cand))))
      (insert (format " %s " title))))

(defun consult-omni-embark-copy-title-as-kill (cand)
  "Copy the title of CAND to `kill-ring'."
  (if-let ((title (and (stringp cand) (get-text-property 0 :title cand))))
      (kill-new (string-trim title))))

(defun consult-omni-embark-insert-url-link (cand)
  "Insert the url link of CAND at point."
  (let* ((url (and (stringp cand) (get-text-property 0 :url cand)))
         (url (and (stringp url) (string-trim url)))
         (title (and (stringp cand) (get-text-property 0 :title cand))))
    (when url
      (cond
       ((derived-mode-p 'org-mode)
        (insert (cond
                 ((and url title) (format " [[%s][%s]] " url title))
                 (url (format " [[%s]] " url))
                 (t ""))))
       ((derived-mode-p 'markdown-mode)
        (insert (cond
                 ((and url title) (format " [%s](%s) " url title))
                 (url (format " <%s> " url))
                 (t ""))))
       (t
        (insert (cond
                 ((and url title) (format " %s (%s) " title  url))
                 (url (format " %s " url))
                 (t ""))))))))

(defun consult-omni-embark-copy-url-as-kill (cand)
  "Copy the url of CAND to `kill-ring'."
  (if-let ((url (and (stringp cand) (get-text-property 0 :url cand))))
      (kill-new (format " %s " (string-trim url)))))

(defun consult-omni-embark-external-browse-link (cand)
  "Open the url of CAND with `consult-omni-default-browse-function'."
  (if-let* ((url (and (stringp cand) (get-text-property 0 :url cand))))
      (funcall consult-omni-default-browse-function url)))

(defun consult-omni-embark-alternate-browse-link (cand)
  "Open the url of CAND with `consult-omni-alternate-browse-function'."
  (if-let* ((url (and (stringp cand) (get-text-property 0 :url cand))))
      (funcall consult-omni-alternate-browse-function url)))

(defun consult-omni-embark-external-browse-search-link (cand)
  "Open the “search url” of CAND in the external browser.

The “search url” is the source search page withthe search term from CAND."
  (if-let* ((search-url (and (stringp cand) (get-text-property 0 :search-url cand))))
      (funcall #'browse-url search-url)))

(defun consult-omni-embark-show-preview (cand)
  "Open a preview of CAND.

Gets the preview function from `consult-omni--sources-alist'."
  (let* ((source (and (stringp cand) (get-text-property 0 :source cand))))
    (funcall (consult-omni--get-source-prop source :on-preview) cand)))

#+end_src
*** keymap
#+begin_src emacs-lisp
;;; Define Embark Keymaps

(defvar-keymap consult-omni-embark-general-actions-map
  :doc "Keymap for consult-omni-embark"
  :parent embark-general-map
  "i t"  #'consult-omni-embark-insert-title
  "i u" #'consult-omni-embark-insert-url-link
  "w t" #'consult-omni-embark-copy-title-as-kill
  "w u" #'consult-omni-embark-copy-url-as-kill
  "o o" #'consult-omni-embark-external-browse-link
  "o O" #'consult-omni-embark-alternate-browse-link
  "o s" #'consult-omni-embark-external-browse-search-link
  "o p" #'consult-omni-embark-show-preview)

(add-to-list 'embark-keymap-alist '(consult-omni . consult-omni-embark-general-actions-map))

#+end_src
** Scholar
*** variables
#+begin_src emacs-lisp
;;; Scholar
;; Embark actions for sources searching academic article

(defcustom consult-omni-embark-scholar-make-note-func  #'consult-omni-embark-scholar-default-note
  "Function for making note template for scholar articles."
  :group 'consult-omni
  :type '(choice (function :tag "(Default) Make Note with Title, Link, Journal, Authors... " consult-omni-embark-scholar-default-note)
                 (function :tag "Custom Function")))

#+end_src
*** actions
#+begin_src emacs-lisp
(defun consult-omni-embark-scholar-external-browse-doi (cand)
  "Open the DOI url of CAND in external browser."
  (if-let* ((doi (and (stringp cand) (get-text-property 0 :doi cand))))
      (funcall #'browse-url (concat "https://doi.org/" doi))))

(defun consult-omni-embark-scholar-copy-authors-as-kill (cand)
  "Copy the authors of CAND to `kill-ring'."
  (if-let ((authors (and (stringp cand) (get-text-property 0 :authors cand))))
      (kill-new (string-trim (format " %s " authors)))))

(defun consult-omni-embark-scholar-insert-authors (cand)
  "Insert the authors of CAND at point."
  (if-let ((authors (and (stringp cand) (get-text-property 0 :authors cand))))
      (insert (string-trim (mapconcat #'identity authors ", ")))))

(defun consult-omni-embark-scholar-default-note (cand)
  "Make note on CAND article.

This can be used for making notes for scholar articles."
  (let* ((url (and (stringp cand) (get-text-property 0 :url cand)))
         (url (and (stringp url) (string-trim url)))
         (doi (and (stringp cand) (get-text-property 0 :doi cand)))
         (doi (if (and doi (stringp doi)) (concat "https://doi.org/" doi)))
         (source (and (stringp cand) (get-text-property 0 :source cand)))
         (url (if (and (equal source "Scopus") doi)
                  doi
                url))
         (title (and (stringp cand) (get-text-property 0 :title cand)))
         (authors (and (stringp cand) (get-text-property 0 :authors cand)))
         (authors (cond
                   ((and (listp authors) (= (length authors) 1))
                    (car authors))
                   ((listp authors)
                    (mapconcat #'identity authors ", "))
                   (t authors)))
         (journal  (and (stringp cand) (get-text-property 0 :journal cand)))
         (date (and (stringp cand) (get-text-property 0 :date cand))))
    (cond
     ((derived-mode-p 'org-mode)
      (concat
       "\n"
       (cond
        ((and url title) (format "** [[%s][%s]]\n" url title))
        (url (format "** [[%s]]\n" url))
        (title (format "** %s\n" title)))
       (if authors (format "\n%s" authors))
       (if journal (format "\nin =%s= " journal))
       (if date (format "published on [%s]\n" date) "\n")
       "\n*** Notes\n"))
     ((derived-mode-p 'markdown-mode)
      (concat
       "\n"
       (cond
        ((and url title) (format "## [%s](%s)\n" url title))
        (url (format "## <%s>\n" url))
        (title (format "## %s\n" title)))
       (if authors (format "\n%s" authors))
       (if journal (format "\nin **%s** " journal))
       (if date (format "published on %s\n" date) "\n")
       "\n### Notes\n"))
     (t
      (concat
       "\n"
       (cond
        ((and url title) (format "** %s (%s)\n" title  url))
        (url (format "** %s\n" url))
        (title (format "** %s\n" title)))
       (if authors (format "\n%s" authors))
       (if journal (format "\nin %s " journal))
       (if date (format "published on %s\n" date) "\n")
       "\n*** Notes\n")))))

(defun consult-omni-embark-scholar-insert-note (cand)
  "Insert note snippet for CAND article.

Uses `consult-omni-embark-scholar-make-note-func' to make template."
  (insert (funcall consult-omni-embark-scholar-make-note-func cand)))

#+end_src
*** keymap
#+begin_src emacs-lisp
(defvar-keymap consult-omni-embark-scholar-actions-map
  :doc "Keymap for consult-omni-embark-scholar"
  :parent consult-omni-embark-general-actions-map
  "o d" #'consult-omni-embark-scholar-external-browse-doi
  "w a" #'consult-omni-embark-scholar-copy-authors-as-kill
  "i a" #'consult-omni-embark-scholar-insert-authors
  "i n" #'consult-omni-embark-scholar-insert-note)

(add-to-list 'embark-keymap-alist '(consult-omni-scholar . consult-omni-embark-scholar-actions-map))

(add-to-list 'embark-default-action-overrides '(consult-omni-scholar . consult-omni-embark-default-action))

#+end_src

** Apps
*** actions
#+begin_src emacs-lisp
;;; Apps
;; Embark actions for sources searching applications

(defun consult-omni-embark-apps-open-filemanager (cand)
  "Open CAND's filepath with system's file manager."
  (if-let* ((path (and (stringp cand) (get-text-property 0 :path cand))))
      (pcase system-type
        ('darwin (call-process "open" nil 0 nil path "-R"))
        ('cygwin (call-process "cygstart" nil 0 nil path))
        ('windows-nt (and (fboundp 'w32-shell-execute) (w32-shell-execute "open" path)))
        (_ (call-process "xdg-open" nil 0 nil path)))))

(defun consult-omni-embark-apps-find-file (cand)
  "Open CAND's filepath with `find-file'."
  (if-let* ((path (and (stringp cand) (get-text-property 0 :path cand)))
            (directory (and (file-exists-p (file-truename path)) (file-truename path)))
            (default-directory directory))
      (call-interactively #'find-file)))

(defun consult-omni-embark-apps-open-externally (cand)
  "Open CAND's filepath using system's default application."
  (if-let ((path (and (stringp cand) (get-text-property 0 :path cand))))
      (pcase system-type
        ('darwin (call-process "open" nil 0 nil path))
        ('cygwin (call-process "cygstart" nil 0 nil path))
        ('windows-nt (and (fboundp 'w32-shell-execute) (w32-shell-execute "open" path)))
        (_ (call-process "xdg-open" nil 0 nil path)))
    nil))

(defun consult-omni-embark-apps-open-term (cand)
  "Open CAND's filepath in `consult-omni-embark-default-term'."
  (if-let* ((path (and (stringp cand) (get-text-property 0 :path cand)))
            (directory (and (file-exists-p (file-truename path)) (file-truename path)))
            (default-directory directory))
      (funcall consult-omni-embark-default-term)))

(defun consult-omni-embark-apps-insert-path (cand)
  "Insert the title of CAND at point."
  (if-let ((path (and (stringp cand) (get-text-property 0 :path cand))))
      (insert (format " %s " path))))

(defun consult-omni-embark-apps-copy-path-as-kill (cand)
  "Copy the title of CAND to `kill-ring'."
  (if-let ((path (and (stringp cand) (get-text-property 0 :path cand))))
      (kill-new (format " %s " path))))

#+end_src
*** keymap
#+begin_src emacs-lisp

;;; Define Embark Keymaps

(defvar-keymap consult-omni-embark-apps-actions-map
  :doc "Keymap for consult-omni-embark"
  :parent consult-omni-embark-general-actions-map
  "x"  #'consult-omni-embark-apps-open-externally
  "f"  #'consult-omni-embark-apps-find-file
  "o f"  #'consult-omni-embark-apps-find-file
  "o o" #'consult-omni-embark-apps-open-filemanager
  "o t" #'consult-omni-embark-apps-open-term
  "w p" #'consult-omni-embark-apps-copy-path-as-kil)

(add-to-list 'embark-keymap-alist '(consult-omni-apps . consult-omni-embark-apps-actions-map))
(add-to-list 'embark-default-action-overrides '(consult-omni-apps . consult-omni-embark-default-action))

#+end_src
** Calc
*** actions
#+begin_src emacs-lisp
;;; Calc
;; Embark actions for calc source

(defun consult-omni-embark-calc-copy-results-as-kill (cand)
  "Copy the results of the calculator, CAND, to `kill-ring'."
  (if-let ((results (and (stringp cand) (get-text-property 0 :title cand))))
      (kill-new (format " %s " results))))

(defun consult-omni-embark-calc-insert-results (cand)
  "Insert the results of the calculator, CAND, at point."
  (if-let (results (and (stringp cand) (get-text-property 0 :title cand)))
      (insert (format " %s " results))))

(defun consult-omni-embark-calc-copy-formula-as-kill (cand)
  "Copy the results of the calculator, CAND, to `kill-ring'."
  (if-let ((formula (and (stringp cand) (get-text-property 0 :query cand))))
      (kill-new (format " %s " formula))))

(defun consult-omni-embark-calc-insert-formula (cand)
  "Insert the results of the calculator, CAND, at point."
  (if-let (formula (and (stringp cand) (get-text-property 0 :query cand)))
      (insert (format " %s " formula))))

#+end_src
*** keymap
#+begin_src emacs-lisp

;;; Define Embark Keymaps

(defvar-keymap consult-omni-embark-calc-actions-map
  :doc "Keymap for consult-omni-embark"
  :parent embark-general-map
  "w r"  #'consult-omni-embark-calc-copy-results-as-kill
  "w f"  #'consult-omni-embark-calc-copy-formula-as-kill
  "i r"  #'consult-omni-embark-calc-insert-results
  "i f"  #'consult-omni-embark-calc-insert-formula)

(add-to-list 'embark-keymap-alist '(consult-omni-calc . consult-omni-embark-calc-actions-map))
(add-to-list 'embark-default-action-overrides '(consult-omni-calc . consult-omni-embark-default-action))

#+end_src
** Video
*** variables
#+begin_src emacs-lisp
;;; Video
;; Embark actions for sources searching videos (e.g. Youtube)

(defcustom consult-omni-embark-video-default-player  (executable-find "mpv")
  "External video player for consult-omni.

Can be:
  - an elisp function that takes a URL argument \(e.g. mpv-pay-url\)
  - a string for external command line program"
  :type '(choice (string :tag "(Default) mpv executable command" (executable-find "mpv"))
                 (function :tag "play with mpv package" mpv-play-url)
                 (function :tag "Custom Function")
                 (string :tag "Custom Executable Command")))

#+end_src

*** actions
#+begin_src emacs-lisp
(defun consult-omni-play-url-with-app (url)
  "Play video at URL with `consult-omni-embark-video-default-player'."
  (interactive (let* ((cand (consult-omni-youtube nil "Search Youtube:  " t))
                      (link (get-text-property 0 :url cand)))
                 (list link)))
  (cond
   ((stringp consult-omni-embark-video-default-player)
    (if-let ((cmd (executable-find consult-omni-embark-video-default-player)))
        (progn
          (start-process "consult-omni-mpv" nil cmd url)
          (message "Opening with %s ..." consult-omni-embark-video-default-player))
      (message "executable %s not found" consult-omni-embark-video-default-player)))
   ((symbolp consult-omni-embark-video-default-player)
    (if (functionp consult-omni-embark-video-default-player)
        (progn (funcall consult-omni-embark-video-default-player url)
               (message "Opening with %s ..." consult-omni-embark-video-default-player))
      (message "Symbol function definition is void: %s"  consult-omni-embark-video-default-player)))))

(defun consult-omni-embark-video-play-with-app (cand)
  "Open CAND's video URL with `consult-omni-play-url-with-app'."
  (if-let* ((url (and (stringp cand) (get-text-property 0 :url cand))))
      (consult-omni-play-url-with-app url)))

#+end_src


*** keymap
#+begin_src emacs-lisp
(defvar-keymap consult-omni-embark-video-actions-map
  :doc "Keymap for consult-omni-embark-video"
  :parent consult-omni-embark-general-actions-map
  "o x" #'consult-omni-embark-video-play-with-app)

(add-to-list 'embark-keymap-alist '(consult-omni-video . consult-omni-embark-video-actions-map))

(add-to-list 'embark-default-action-overrides '(consult-omni-video . consult-omni-embark-default-action))

#+end_src


** Provide and Footer
#+begin_src emacs-lisp
;;; Provide `consul-web-embark' module

(provide 'consult-omni-embark)

;;; consult-omni-embark.el ends here
#+end_src
* sources
** Module
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-sources.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-sources.el --- Sources for consult-omni -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; This file provides the default sources for consult-omni.

;;; Code:


(require 'consult-omni)

#+end_src
**** define all source modules
#+begin_src emacs-lisp

(defvar consult-omni-sources--all-modules-list (list)
  "List of all sources in consult-omni.")

(setq consult-omni-sources--all-modules-list
  (list 'consult-omni-apps
        'consult-omni-bing
        'consult-omni-brave-autosuggest
        'consult-omni-brave
        'consult-omni-browser-history
        'consult-omni-buffer
        'consult-omni-calc
        'consult-omni-chatgpt
        'consult-omni-consult-notes
        'consult-omni-dict
        'consult-omni-doi
        'consult-omni-duckduckgo
        'consult-omni-elfeed
        'consult-omni-fd
        'consult-omni-find
        'consult-omni-gh
        'consult-omni-git-grep
        'consult-omni-google
        'consult-omni-google-autosuggest
        'consult-omni-gptel
        'consult-omni-grep
        'consult-omni-invidious
        'consult-omni-line-multi
        'consult-omni-locate
        'consult-omni-man
        'consult-omni-mdfind
        'consult-omni-mu4e
        'consult-omni-notes
        'consult-omni-notmuch
        'consult-omni-numi
        'consult-omni-org-agenda
        'consult-omni-pubmed
        'consult-omni-projects
        'consult-omni-ripgrep
        'consult-omni-ripgrep-all
        'consult-omni-scopus
        'consult-omni-stackoverflow
        'consult-omni-wikipedia
        'consult-omni-youtube))
#+end_src
**** add individual or list of sources
#+begin_src emacs-lisp
(defun consult-omni-sources--load-module (symbol)
  "Load feature SYMBOL."
  (require symbol nil t))

(defun consult-omni-sources-load-modules (&optional list)
  "Load the LIST of symbols.

If LIST is nil, loads `consult-omni-sources-modules-to-load', and if that
is nil as well, loads `consult-omni-sources--all-modules-list'."
  (mapc #'consult-omni-sources--load-module (or list consult-omni-sources-modules-to-load consult-omni-sources--all-modules-list)))

#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-sources' module

(provide 'consult-omni-sources)

;;; consult-omni-sources.el ends here
#+end_src
** Single Source Definition
*** Desktop Apps
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-apps.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-apps.el --- Consulting OS applications -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-apps provides commands for searching desktop applications using consult-omni.

;;; Code:

(require 'consult-omni)
(require 'xdg)

#+end_src
**** variables
***** custom
#+begin_src emacs-lisp
;;; User Options (a.k.a. Custom Variables)

(defcustom consult-omni-apps-paths (list)
  "List of directories that contain applications."
  :group 'consult-omni
  :type '(repeat :tag "List of paths" directory))

(defcustom consult-omni-apps-use-cache nil
  "Whether to use cache for getting list of apps?"
  :group 'consult-omni
  :type 'boolean)

(defcustom consult-omni-apps-open-command-args nil
  "Command line args to open an application."
  :group 'consult-omni
  :type 'string)

(defcustom consult-omni-apps-regexp-pattern ""
  "Regexp pattern to find system applications."
  :group 'consult-omni
  :type 'regexp)

(defcustom consult-omni-apps-default-launch-function #'consult-omni--apps-launch-app
  "Default function to launch an app."
  :group 'consult-omni
  :type '(choice (function :tag "(Default) Use System Shell" consult-omni--apps-launch-app)
                 (function :tag "Custom Function")))

(defcustom consult-omni-open-with-prompt ">|  "
  "String for prompt in `consult-omni-open-with-app'."
  :group 'consult-omni
  :type 'string)

;; Set the variables per system type (Linux and MacOS only)
(pcase system-type
  ('darwin
   (setq consult-omni-apps-paths (append (file-expand-wildcards "/Applications/Adobe*") (list "/Applications" "/Applications/Utilities/" "/System/Applications/" "/System/Applications/Utilities/" "~/Applications/")))
   (setq consult-omni-apps-regexp-pattern ".*\\.app$")
   (setq consult-omni-apps-open-command-args "open -a"))
  ('gnu/linux
   (setq consult-omni-apps-xdg-data-home (if (fboundp 'xdg-data-home) (xdg-data-home)
                                           (let ((path (getenv "XDG_DATA_HOME")))
                                             (if (or (null path) (string= path ""))
                                                 nil
                                               (parse-colon-path path)))))
   (setq consult-omni-apps-xdg-data-dirs (if (fboundp 'xdg-data-dirs) (xdg-data-dirs)
                                           (let ((path (getenv "XDG_DATA_DIRS")))
                                             (if (or (null path) (string= path ""))
                                                 nil
                                               (parse-colon-path path)))))
   (setq consult-omni-apps-paths (remove nil (mapcar (lambda (dir)
                                                       (let ((path (and (stringp dir) (file-exists-p dir) (file-truename (expand-file-name "applications" dir)))))
                                                         (and (stringp path) path)))
                                                     (append consult-omni-apps-xdg-data-dirs
                                                             (list consult-omni-apps-xdg-data-home
                                                                   "/usr/share"
                                                                   "/usr/local/share")))))
   (setq consult-omni-apps-regexp-pattern ".*\\.desktop$")
   (setq consult-omni-apps-open-command-args "gtk-launch")))

#+end_src
(
***** other
#+begin_src emacs-lisp
(defvar consult-omni-apps-cached-apps nil
  "Cached list of Paths to desktop entry files.")

(defvar consult-omni-apps-cached-items nil
  "Cached list of desktop apps for `consult-omni-apps'.")

#+end_src
**** helper functions
***** cmd args
#+begin_src emacs-lisp
(defun consult-omni--apps-cmd-args (app &optional file)
  "Return a command line string for opening the APP.

Uses `consult-omni-apps-open-command-args' as the main command line program
If FILE is non-nil, returns a command line for opeing the FILE with APP."
  (append (consult--build-args consult-omni-apps-open-command-args)
          (list (format "%s" app))
          (if (and file (file-exists-p (file-truename file))) (list (format "%s" file)))
          (list "&")))

#+end_src

***** make process
#+begin_src emacs-lisp
(defun consult-omni--apps-launch-app (app &optional file)
  "Make an async process for opening APP.

Uses `consult-omni--apps-cmd-args' to get the command line args string.
If FILE is non-nil, the process will open the FILE in APP."
  (let* ((name (concat "consult-omni-" (file-name-base app)))
         (cmds (consult-omni--apps-cmd-args app file)))
    (call-process-shell-command (string-join cmds " "))
    nil))

#+end_src
***** open with
#+begin_src emacs-lisp
(defun consult-omni-open-with-app (&optional file app)
  "Open FILE in “external” APP interactively.

If FILE is nil, user is queried to select a file.
If APP is nil, `consult-omni-apps-static' is called to select one."
  (interactive)
  (if-let* ((file (or file (read-file-name "select file:")))
            (file (file-truename file))
            (app (or app (get-text-property 0 :app (consult-omni-apps-static ".*" consult-omni-open-with-prompt t)))))
      (funcall consult-omni-apps-default-launch-function
               (format "%s" app)
               (format "%s" (and (file-exists-p file) file)))))

#+end_src
***** preview
#+begin_src emacs-lisp
(defun consult-omni--apps-preview (cand)
  "Ignore preview if called on CAND in `consult-omni-apps'."
  (ignore))

#+end_src

***** callback
#+begin_src emacs-lisp
(defun consult-omni--apps-callback (cand)
  "Callback function to call on CAND for `consult-omni-apps'."
  (let ((app (get-text-property 0 :app cand)))
    (funcall consult-omni-apps-default-launch-function app)))

#+end_src

***** format
#+begin_src emacs-lisp
(cl-defun consult-omni--apps-format-candidates (&rest args &key source query title path snippet visible face &allow-other-keys)
  "Formats the candidates of `consult-omni-apps' withn ARGS.

Description of Arguments:

  SOURCE  a string; the name to use (e.g. “Apps”)
  QUERY   a string; the query input from the user
  TITLE   a string; the title of the App (name of an application)
  PATH    a string; the filepath to the application
  SNIPPET a string; the description of the app (from Desktop Entry)
  VISIBLE a boolean; whether the applicaiton is visible
          (this can be derived from DesktopEntry)
  FACE    a symbol; the face to use for TITLE"
  (let* ((frame-width-percent (max 10 (floor (* (frame-width) 0.1))))
         (source (and (stringp source) (propertize source 'face 'consult-omni-source-type-face)))
         (directory (and path (file-name-directory path)))
         (directory (and (stringp directory) (propertize directory 'face 'consult-omni-path-face)))
         (snippet (and (stringp snippet) (consult-omni--set-string-width snippet (* 3 frame-width-percent))))
         (snippet (and (stringp snippet) (propertize snippet 'face 'consult-omni-snippet-face)))
         (match-str (and (stringp query) (not (equal query ".*")) (consult--split-escaped query)))
         (face (or (consult-omni--get-source-prop source :face) face 'consult-omni-files-title-face))
         (title-str (propertize title 'face face))
         (title-str (consult-omni--set-string-width title-str (* 4 frame-width-percent)))
         (str (concat title-str
                      (unless visible "\s[Hidden App]")
                      (when snippet (concat "\t" snippet))
                      (when directory (concat "\t" directory))
                      (when source (concat "\t" source)))))
    (if consult-omni-highlight-matches-in-minibuffer
        (cond
         ((listp match-str)
          (mapc (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-omni--highlight-match match-str str t)))))
    str))

#+end_src

**** fetching items/results
***** get list of system apps
#+begin_src emacs-lisp
(defun consult-omni--apps-get-desktop-apps ()
  "Return a list of system applications.

Finds all the desktop applications by finding files that
match `consult-omni-apps-regexp-pattern' in `consult-omni-apps-paths'."
  (save-match-data
    (if (and consult-omni-apps-use-cache consult-omni-apps-cached-apps)
        consult-omni-apps-cached-apps
      (let ((paths (if (stringp consult-omni-apps-paths)
                       (list consult-omni-apps-paths)
                     consult-omni-apps-paths)))
        (when (listp paths)
          (setq consult-omni-apps-cached-apps
                (cl-remove-duplicates
                 (apply #'append (mapcar
                                  (lambda (path)
                                    (when (file-exists-p path)
                                      (directory-files path t consult-omni-apps-regexp-pattern t)))
                                  paths)))))))))

;; set the `consult-omni-apps-cached-apps'
(setq consult-omni-apps-cached-apps (consult-omni--apps-get-desktop-apps))

#+end_src
***** update list of system apps
#+begin_src emacs-lisp
(defun consult-omni--apps-update-cached-apps ()
  "Updated cached list of desktop applications."
  (let ((consult-omni-apps-use-cache nil))
    (consult-omni--apps-get-desktop-apps)))

#+end_src
***** parse app for name, comment and exec
#+begin_src emacs-lisp
(defun consult-omni--apps-parse-app-file (file)
  "Parse a desktop entry FILE.

Returns
 - name: the name of the application
 - comment: description of the application
 - exec: the executable for application

Adopted from `counsel-linux-app--parse-file' in counsel:
URL https://github.com/abo-abo/swiper/blob/master/counsel.el"
  (save-match-data
    (pcase system-type
      ('darwin
       (let ((name (file-name-base file))
             (comment nil)
             (exec (consult-omni--apps-cmd-args (file-name-nondirectory file))))
         (list name comment exec t)))
      ('gnu/linux
       (with-temp-buffer
         (insert-file-contents file)
         (goto-char (point-min))
         (let ((start (re-search-forward "^\\[Desktop Entry\\] *$" nil t))
               (end (re-search-forward "^\\[" nil t))
               (visible t)
               name comment exec)
           (catch 'break
             (unless start
               (throw 'break nil))
             (goto-char start)
             (when (re-search-forward "^\\(Hidden\\|NoDisplay\\) *= *\\(1\\|true\\) *$" end t)
               (setq visible nil))
             (setq name (match-string 1))
             (goto-char start)
             (unless (re-search-forward "^Type *= *Application *$" end t)
               (throw 'break nil))
             (setq name (match-string 1))
             (goto-char start)
             (unless (re-search-forward "^Name *= *\\(.+\\)$" end t)
               (throw 'break nil))
             (setq name (match-string 1))
             (goto-char start)
             (when (re-search-forward "^Comment *= *\\(.+\\)$" end t)
               (setq comment (match-string 1)))
             (goto-char start)
             (unless (re-search-forward "^Exec *= *\\(.+\\)$" end t)
               ;; Don't warn because this can technically be a valid desktop file.
               (throw 'break nil))
             (setq exec (match-string 1))
             (goto-char start)
             (when (re-search-forward "^TryExec *= *\\(.+\\)$" end t)
               (let ((try-exec (match-string 1)))
                 (unless (locate-file try-exec exec-path nil #'file-executable-p)
                   (throw 'break nil))))
             (list name comment exec visible))))))))
#+end_src

***** cached items
#+begin_src emacs-lisp
(defun consult-omni-apps--cached-items (files query)
  "Make a cahced list of Desktop Applications from FILES.

If `consult-omni-apps-cached-items' already exists, returns it otherwise
makes a new one.

FILES is a list of file paths to parse.
For each file in files, if it contains the QUERY (a.k.a. matches the
regexp pattern “.*QUERY.*”), it is parsed by
`consult-omni--apps-parse-app-file' and added to the
`consult-omni-apps-cached-items'"
  (save-match-data
    (if (and consult-omni-apps-use-cache consult-omni-apps--cached-items)
        consult-omni-apps-cached-items
      (setq consult-omni-apps-cached-items
            (mapcar (lambda (file)
                      (pcase-let* ((source "Apps")
                                   (`(,name ,comment ,exec ,visible) (consult-omni--apps-parse-app-file file))
                                   (title (or name (file-name-base file) ""))
                                   (app (and (stringp file) (file-exists-p file) (file-name-nondirectory file)))
                                   (search-url nil)
                                   (consult-omni-highlight-matches-in-minibuffer nil)
                                   (decorated (funcall #'consult-omni--apps-format-candidates :source source :query query :title title :path file :snippet comment :visible visible)))
                        (propertize decorated
                                    :source source
                                    :title title
                                    :url nil
                                    :search-url nil
                                    :query query
                                    :snippet comment
                                    :path file
                                    :exec exec
                                    :app app)))
                    (if query
                        (cl-remove-if-not (lambda (file) (string-match (concat ".*" query ".*") file nil t)) files)
                      files))))))

(setq consult-omni-apps--cached-items  (consult-omni-apps--cached-items consult-omni-apps-cached-apps ".*"))

#+end_src

****** update cahced items
#+begin_src emacs-lisp
(defun consult-omni--apps-update-cached-items ()
"Update list of cached app names."
(let ((consult-omni-apps-use-cache nil))
  (consult-omni-apps--cached-items consult-omni-apps-cached-apps ".*")))
#+end_src

***** items
#+begin_src emacs-lisp
(cl-defun consult-omni--apps-list-apps (input &rest args &key callback &allow-other-keys)
  "Get a list of applications from the operating system with ARGS.

Finds apps in `consult-omni--apps-get-desktop-apps' that contain
the query in INPUT string \(i.e. matches regexp pattern “.*INPUT.*”\).
If `consult-omni-apps-use-cache' is non-nil,
then `consult-omni-apps-cached-items' is used, otherwise
a new list is generated.

CALLBACK is an internal function used by consult-omni collection mechanism
to update list of candidates in the minibuffer."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (files (consult-omni--apps-get-desktop-apps)))
    (if (and consult-omni-apps-use-cache query)
        (seq-filter (lambda (file) (string-match (concat ".*" query ".*") file nil t)) consult-omni-apps-cached-items)
      (mapcar (lambda (file)
                (pcase-let* ((source "Apps")
                             (`(,name ,comment ,exec ,visible) (consult-omni--apps-parse-app-file file))
                             (title (or name (file-name-base file) ""))
                             (app (and (stringp file) (file-exists-p file) (file-name-nondirectory file)))
                             (search-url nil)
                             (consult-omni-highlight-matches-in-minibuffer nil)
                             (decorated (funcall #'consult-omni--apps-format-candidates :source source :query query :title title :path file :snippet comment :visible visible)))
                  (propertize decorated
                              :source source
                              :title title
                              :url nil
                              :search-url nil
                              :query query
                              :snippet comment
                              :path file
                              :exec exec
                              :app app)))
              (if query
                  (cl-remove-if-not (lambda (file) (string-match (concat ".*" query ".*") file nil t)) files)
                files)))))

#+end_src

**** define source
#+begin_src emacs-lisp
(consult-omni-define-source "Apps"
                            :narrow-char ?A
                            :category 'consult-omni-apps
                            :type 'sync
                            :require-match t
                            :request #'consult-omni--apps-list-apps
                            :on-preview #'ignore
                            :on-return #'identity
                            :on-callback #'consult-omni--apps-callback
                            :preview-key nil
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--apps-select-history
                            :enabled (lambda () (boundp 'consult-omni-apps-paths))
                            :group #'consult-omni--group-function
                            :sort t
                            :interactive consult-omni-intereactive-commands-type
                            :annotate nil
                            :category 'file)
#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-apps module

(provide 'consult-omni-apps)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-apps)
;;; consult-omni-apps.el ends here
#+end_src

*** Bing
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-bing.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-bing.el --- Consulting Bing -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-bing provides commands for searching bing in Emacs using ;; consult-omni.


;;; Code:
(require 'consult-omni)

#+end_src
**** variables
***** custom
#+begin_src emacs-lisp
;;; User Options (a.k.a. Custom Variables)

(defcustom consult-omni-bing-search-api-key nil
  "Key for Bing (Microsoft Azure) search API.

Can be a key string or a function that returns a key string.

Refer to URL `https://www.microsoft.com/en-us/bing/apis/bing-web-search-api'
and URL
`https://learn.microsoft.com/en-us/bing/search-apis/bing-web-search/search-the-web' for details on getting an API key."
  :group 'consult-omni
  :type '(choice (string :tag "API Key")
                 (function :tag "Custom Function")))

#+end_src
***** other
#+begin_src emacs-lisp
(defvar consult-omni-bing-search-api-url "https://api.bing.microsoft.com/v7.0/search"
  "API URL for Bing.")

#+end_src
**** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--bing-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch search results for INPUT from Bing web search api with ARGS.

Refer to URL `https://programmablesearchengine.google.com/about/' and
`https://developers.google.com/custom-search/' for more info.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (page (or (and page (integerp (read page)) (string-to-number page))
                         consult-omni-default-page))
               (count (max count 1))
               (page (* page count))
               (params `(("q" . ,(replace-regexp-in-string " " "+" query))
                         ("count" . ,(format "%s" count))
                         ("offset" . ,(format "%s" page))))
               (headers `(("Ocp-Apim-Subscription-Key" . ,(consult-omni-expand-variable-function consult-omni-bing-search-api-key)))))
    (consult-omni--fetch-url consult-omni-bing-search-api-url consult-omni-http-retrieve-backend
                             :encoding 'utf-8
                             :params params
                             :headers headers
                             :parser #'consult-omni--json-parse-buffer
                             :callback
                             (lambda (attrs)
                               (let* ((raw-results (map-nested-elt attrs '("webPages" "value")))
                                      (search-url (gethash "webSearchUrl" attrs))
                                      (annotated-results
                                       (mapcar (lambda (item)
                                                 (let*
                                                     ((source "Bing")
                                                      (url (format "%s" (gethash "url" item)))
                                                      (title (gethash "name" item))
                                                      (snippet (gethash "snippet" item))
                                                      (decorated (funcall consult-omni-default-format-candidate :source source :query query :url url :search-url search-url :title title :snippet snippet)))
                                                   (propertize decorated
                                                               :source source
                                                               :title title
                                                               :url url
                                                               :search-url search-url
                                                               :query query
                                                               :snippet snippet)))
                                               raw-results)))
                                 (when (and annotated-results (functionp callback))
                                   (funcall callback annotated-results))
                                 annotated-results)))))

#+end_src
**** define source
#+begin_src emacs-lisp
;; Define the Bing Source
(consult-omni-define-source "Bing"
                            :narrow-char ?i
                            :type 'dynamic
                            :require-match nil
                            :face 'consult-omni-engine-title-face
                            :request #'consult-omni--bing-fetch-results
                            :on-new (apply-partially #'consult-omni-external-search-with-engine "Bing")
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :enabled (lambda () (bound-and-true-p consult-omni-bing-search-api-key))
                            :group #'consult-omni--group-function
                            :sort t
                            :interactive consult-omni-intereactive-commands-type
                            :annotate nil)

#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-bing' module

(provide 'consult-omni-bing)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-bing)
;;; consult-omni-bing.el ends here
#+end_src


*** Brave
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-brave.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-brave.el --- Consulting Brave -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-brave provides commands for searching Brave in Emacs using
;; consult-omni.

;;; Code:

(require 'consult-omni)

#+end_src
**** variables
***** custom
#+begin_src emacs-lisp
;;; User Options (a.k.a. Custom Variables)
(defcustom consult-omni-brave-api-key nil
  "Key for Brave API.

Can be a key string or a function that returns a key string.

Refer to URL `https://brave.com/search/api/' for more info on getting an
API key."
  :group 'consult-omni
  :type '(choice (string :tag "Brave API Key")
                 (function :tag "Custom Function")))

#+end_src
***** other
#+begin_src emacs-lisp
(defvar consult-omni-brave-search-url "https://search.brave.com/search"
"Web search URL for Brave.")

(defvar consult-omni-brave-url "https://api.search.brave.com/res/v1/web/search"
"API URL for Brave.")

#+end_src

**** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--brave-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch search results from Brave for INPUT with ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (page (or (and page (integerp (read page)) (string-to-number page))
                         consult-omni-default-page))
               (count (min (max count 1) 20))
               (params `(("q" . ,(replace-regexp-in-string " " "+" query))
                         ("count" . ,(format "%s" count))
                         ("page" . ,(format "%s" page))))
               (headers `(("User-Agent" . "Emacs:consult-omni/0.1 (Emacs consult-omni package; https://github.com/armindarvish/consult-omni)")
                          ("Accept" . "application/json")
                          ("Accept-Encoding" . "gzip")
                          ("X-Subscription-Token" . ,(consult-omni-expand-variable-function consult-omni-brave-api-key)))))
    (consult-omni--fetch-url consult-omni-brave-url consult-omni-http-retrieve-backend
                             :encoding 'utf-8
                             :params params
                             :headers headers
                             :parser #'consult-omni--json-parse-buffer
                             :callback
                             (lambda (attrs)
                               (when-let* ((raw-results (map-nested-elt attrs '("web" "results")))
                                           (annotated-results
                                            (mapcar (lambda (item)
                                                      (let*
                                                          ((source "Brave")
                                                           (url (gethash "url" item))
                                                           (title (gethash "title" item))
                                                           (snippet (gethash "description" item))
                                                           (search-url (consult-omni--make-url-string consult-omni-brave-search-url params))
                                                           (decorated (funcall consult-omni-default-format-candidate :source source :query query :url url :search-url search-url :title title :snippet snippet)))
                                                        (propertize decorated
                                                                    :source source
                                                                    :title title
                                                                    :url url
                                                                    :search-url search-url
                                                                    :query query
                                                                    :snippet snippet)))
                                                    raw-results)))
                                 (funcall callback annotated-results)
                                 annotated-results)))))

#+end_src
**** define source
#+begin_src emacs-lisp
;; Define the Brave Source
(consult-omni-define-source "Brave"
                            :narrow-char ?b
                            :type 'dynamic
                            :require-match nil
                            :face 'consult-omni-engine-title-face
                            :request #'consult-omni--brave-fetch-results
                            :on-new (apply-partially #'consult-omni-external-search-with-engine "Brave")
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :enabled (lambda () (bound-and-true-p consult-omni-brave-api-key))
                            :group #'consult-omni--group-function
                            :sort t
                            :interactive consult-omni-intereactive-commands-type)

#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-brave' module

(provide 'consult-omni-brave)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-brave)
;;; consult-omni-brave.el ends here
#+end_src
*** Brave AutoSuggest
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-brave-autosuggest.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-brave-autosuggest.el --- Consulting Brave Autosuggest -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-brave-autosuggest provides commands for getting
;; autosuggestion from Brave in Emacs using consult-omni.

;;; Code:

(require 'consult-omni)

#+end_src
**** variables
***** custom
#+begin_src emacs-lisp
;;; User Options (a.k.a. Custom Variables)
(defcustom consult-omni-brave-autosuggest-api-key nil
  "Key for Brave Autosuggest API.

Can be a key string or a function that returns a key string.

Refer to URL `https://brave.com/search/api/' for more info on getting an API key."
  :group 'consult-omni
  :type '(choice (string :tag "Brave Autosuggest API Key")
                 (function :tag "Custom Function")))

#+end_src
***** other
#+begin_src emacs-lisp
(defvar consult-omni-brave-autosuggest-api-url "https://api.search.brave.com/res/v1/suggest/search"
  "API URL for Brave AutoSuggest.")

#+end_src
**** helper functions
***** return
#+begin_src emacs-lisp
(defun consult-omni--brave-autosuggest-return (cand)
  "Return the string of CAND with no properties."
  (when (stringp cand)
    (substring-no-properties (string-trim cand))))

#+end_src
***** new
#+begin_src emacs-lisp
(defun consult-omni--brave-autosuggest-new (cand)
  "Return CAND for NEW non-existing candidates."
  (when (listp cand) (setq cand (car-safe cand)))
  (or (and (stringp cand) (string-trim cand (consult--async-split-initial nil)))
      cand))

#+end_src
**** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--brave-autosuggest-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch search results for INPUT from Brave Autosuggest API with ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (page (or (and page (integerp (read page)) (string-to-number page))
                         consult-omni-default-page))
               (count (min (max count 1) 20))
               (params  `(("q" . ,(replace-regexp-in-string " " "+" query))
                          ("count" . ,(format "%s" count))
                          ("page" . ,(format "%s" page))
                          ("country" . "US")))
               (headers `(("User-Agent" . "Emacs:consult-omni/0.1 (Emacs consult-omni package; https://github.com/armindarvish/consult-omni)")
                          ("Accept" . "application/json")
                          ("Accept-Encoding" . "gzip")
                          ("X-Subscription-Token" . ,(consult-omni-expand-variable-function consult-omni-brave-autosuggest-api-key)))))
    (consult-omni--fetch-url consult-omni-brave-autosuggest-api-url consult-omni-http-retrieve-backend
                             :encoding 'utf-8
                             :params params
                             :headers headers
                             :parser #'consult-omni--json-parse-buffer
                             :callback
                             (lambda (attrs)
                               (when-let* ((original (make-hash-table :test 'equal))
                                           (_ (puthash "query" (gethash "original" (gethash "query" attrs)) original))
                                           (raw-results  (append (map-nested-elt attrs '("results")) (list original)))
                                           (annotated-results
                                            (mapcar (lambda (item)
                                                      (let* ((source "Brave AutoSuggest")
                                                             (word (gethash "query" item))
                                                             (url (concat "https://search.brave.com/search?q="  (replace-regexp-in-string " " "+" word)))
                                                             (urlobj (and url (url-generic-parse-url url)))
                                                             (domain (and (url-p urlobj) (url-domain urlobj)))
                                                             (domain (and (stringp domain)
                                                                          (propertize domain 'face 'font-lock-variable-name-face)))
                                                             (path (and (url-p urlobj) (url-filename urlobj)))
                                                             (path (and (stringp path)
                                                                        (propertize path 'face 'font-lock-warning-face)))
                                                             (search-url nil)
                                                             (decorated (propertize word 'face 'consult-omni-default-face)))
                                                        (propertize decorated
                                                                    :source source
                                                                    :title word
                                                                    :url url
                                                                    :search-url search-url
                                                                    :query query)))
                                                    raw-results)))
                                 (funcall callback annotated-results)
                                 annotated-results)))))

#+end_src
**** define source
#+begin_src emacs-lisp
;; Define the Brave AutoSuggest Source
(consult-omni-define-source "Brave AutoSuggest"
                            :narrow-char ?B
                            :type 'dynamic
                            :require-match nil
                            :face 'consult-omni-engine-title-face
                            :request #'consult-omni--brave-autosuggest-fetch-results
                            :group #'consult-omni--group-function
                            :on-preview #'ignore
                            :on-return #'consult-omni--brave-autosuggest-return
                            :on-callback #'string-trim
                            :on-new #'consult-omni--brave-autosuggest-new
                            :search-hist 'consult-omni--search-history
                            :select-hist t
                            :enabled (lambda () (bound-and-true-p consult-omni-brave-autosuggest-api-key))
                            :sort t
                            :interactive consult-omni-intereactive-commands-type)

#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-brave-autosuggest' module

(provide 'consult-omni-brave-autosuggest)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-brave-autosuggest)
;;; consult-omni-brave-autosuggest.el ends here
#+end_src
*** browser historiy
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-browser-history.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-browser-history.el --- Consulting Browser History -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (browser-hist "0.0.1")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-browser-history provides commands for searching browser
;; history in Emacs using consult-omni.  It uses the browser-hist.el
;; package as the backend.
;; See URL https://github.com/agzam/browser-hist.el


;;; Code:

(require 'consult-omni)
(require 'browser-hist)

#+end_src
**** helper functions
***** format
#+begin_src emacs-lisp
(cl-defun consult-omni--browser-history-format-candidate (&rest args &key source query url title face &allow-other-keys)
  "Format candidates of `consult-omni-browser-history' with ARGS.

Description of Arguments:

  SOURCE     a string; the name string of the source for candidate
  QUERY      a string; the query string used for searching
  URL        a string; the URL of the candidate
  TITLE      a string; the title of the candidate
  FACE       a symbol; the face to use for title"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (and (stringp source) (propertize source 'face 'consult-omni-source-type-face)))
         (match-str (and (stringp query) (not (equal query ".*")) (consult--split-escaped query)))
         (face (or (consult-omni--get-source-prop source :face) face 'consult-omni-default-face))
         (title-str (propertize title 'face face))
         (title-str (consult-omni--set-string-width title-str (* 4 frame-width-percent)))
         (urlobj (and url (url-generic-parse-url url)))
         (domain (and (url-p urlobj) (url-domain urlobj)))
         (domain (and (url-p urlobj) (or (url-domain urlobj) (url-host urlobj))))
         (port (and (url-p urlobj) (url-port urlobj)))
         (domain (if port (format "%s:%s" domain port) (format "%s" domain)))
         (domain (and (stringp domain) (propertize domain 'face 'consult-omni-domain-face)))
         (path (and (url-p urlobj) (url-filename urlobj)))
         (path (and (stringp path) (propertize path 'face 'consult-omni-path-face)))
         (url-str (consult-omni--set-url-width domain path (* frame-width-percent 5)))
         (str (concat title-str
                      (when url-str (concat "\s" url-str))
                      (when source (concat "\t" source)))))
    (if consult-omni-highlight-matches-in-minibuffer
        (cond
         ((listp match-str)
          (mapc (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-omni--highlight-match match-str str t)))))
    str))

#+end_src
**** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--browser-history-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch search results for INPUT from browser history with ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (browser (or (plist-get opts :browser) browser-hist-default-browser))
               (browser-hist-default-browser browser)
               (results (browser-hist--send-query query))
               (source "Browser History"))
    (mapcar (lambda (item)
              (let* ((url (car-safe item))
                     (title (cdr-safe item))
                     (decorated (consult-omni--browser-history-format-candidate :source source :query query :url url :title title)))
                (propertize decorated
                            :source source
                            :title title
                            :url url
                            :query query)))
            results)))

#+end_src
**** define source
#+begin_src emacs-lisp
;; Define the Browse History Source
(consult-omni-define-source "Browser History"
                            :narrow-char ?H
                            :type 'sync
                            :require-match nil
                            :face 'consult-omni-engine-title-face
                            :request #'consult-omni--browser-history-fetch-results
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :enabled (lambda () (fboundp 'browser-hist-search))
                            :group #'consult-omni--group-function
                            :sort t
                            :interactive consult-omni-intereactive-commands-type
                            :annotate nil)

#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-browser-history' module

(provide 'consult-omni-browser-history)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-browser-history)
;;; consult-omni-browser-history.el ends here
#+end_src
*** calc
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-calc.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-calc.el --- Consulting Emacs Calculator -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-calc provides commands for getting calc results directly
;; in the minibuffer using consult-omni.

;;; Code:

(require 'consult-omni)
(require 'calc)
(require 'calc-aent nil t)

#+end_src
**** variables
***** custom
#+begin_src emacs-lisp
;;; User Options (a.k.a. Custom Variables)

(defcustom consult-omni-calc-number-only nil
  "Only show calculator results when the query result is a number?"
  :group 'consult-omni
  :type 'boolean)

(defcustom consult-omni-calc-regexp-pattern "^=\\(.*\\)?"
  "Regexp to detect calculator formula?

The first capturing group will be used as input for `calc-eval'.
If there is no capture group, the whole input query is used.

Note that the default setting is simply any string with a leading “=”.
This allows the user to see the results from calculator \(i.e.
`consult-omni--calc-fetch-results')\ from any string without consult-omni
detecting (i.e. trying to guess) what is a mathematical equation.  This
can specially be useful in multi-source searches, if the user does not
want to see random results from the calculator on every search string.
The downside of this approach is that the user has to type “=” every time
before seeing results form the calculator.  For example to see the result
of the equation 2+3, the user has to type:
  “#=2+3”
\(Note that the leading “#” above is from the default perl style of
`consult-async-split-style' and otherwise not neccessary\).

Alternatively, one can change this cariable to regexp pattern that
detects/guesses a mathematical equation \(for example by looking for
strings that contain digits and/or mathematical operators\).  For an
example, see the default choices for this custom variable.  This would
remove the need to type a leading character evertytime but at the same
time may miss some edge cases if the user's query/equation does not match
this regexp.

To be safe the default setting of this variable uses the former approach
with a leading “=” character."

  :group 'consult-omni
  :type '(choice (regexp :tag "(Default) formula after =" "^=\\(.*\\)?")
                 (regexp :tag "Any string with digits, operators or brackets" "\\(.*[[:digit:]\/\*\+-=%^&$\(\{\[].*\\)")))

(defcustom consult-omni-calc-message-errors nil
  "Whether to message errors for calc?

Setting this to non-nil will show messages when the calcultor cannot find
results, which may not be desirable in multi-source omni searches."
  :group 'consult-omni
  :type 'boolean)

#+end_src
**** helper functions
***** callback
#+begin_src emacs-lisp
(defun consult-omni--calc-callback (cand)
  "Copy the result, CAND, as well as the equation to the `kill-ring'."
  (let ((equ (get-text-property 0 :query cand))
        (result  (get-text-property 0 :title cand)))
    (kill-new (concat equ " => " result))
    (kill-new result)))

#+end_src

**** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--calc-fetch-results (input &rest args &key callback &allow-other-keys)
  "Calculate the result of possible math equations in INPUT with ARGS.

This uses `calc-eval' to return the result of the INPUT string.  The INPUT
should match `consult-omni-calc-regexp-pattern', which by default has a
leading “=”.  For example to see the result of the equation 2+3, the user
should type:
  “#=2+3”
\(Note that the leading “#” above is from the default perl style of
`consult-async-split-style' and otherwise not neccessary\).

For more details on how to type equations refer to `calc-eval'
documentation on input strings and Emacs manual for calc in general as
well as this package's repo:
URL `https://github.com/armindarvish/consult-omni'

To change this behavior, `consult-omni-calc-regexp-pattern' can be edited.
For example, to remove the leading “=”, in which case the user can simply
enter “2+3” to see the results.  Keep in mind that the densures that
consult-omni-calc returns results only when the user intends the query as
a calc equation.  Removing “=”, may sometimes lead to confusing answers
from the calculator in multi-source searches, because it passes the INPUT
query to `calc-eval', which in turn tries its best to interpret the INPUT
as a mathematical equation.

For unit conversion, the INPUT should contain “:convert” keyword with unit
value as an optional argument using consult's syntax.  See the documention
of `consult-omni-multi' for how to pass extra arguments using
`consult-async-split-style' syntax.
For example:
 “#=100degF -- :convert degC”
converts 100 Farenheit to Celsius.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (source "calc")
               (opts (car-safe opts))
               (opts (cl-substitute :convert :c opts :test 'equal))
               (convert (plist-get opts :convert))
               (extra-args (plist-get opts :$))
               (extra-args (and extra-args (car (read-from-string extra-args))))
               (extra-args (if (listp extra-args) extra-args (list extra-args)))
               (extra-args (mapcar (lambda (item) (cond
                                                   ((numberp item) (format "%s" item))
                                                   ((and (symbolp item) (numberp (symbol-value item))) (format "%s" (symbol-value item)))
                                                   ((and (functionp item) (numberp (funcall item))) (format "%s" (funcall item)))
                                                   ((and (numberp (eval item))) (format "%s" (eval item)))
                                                   (t item)))
                                   extra-args))
               (calc-eval-error t)
               (result)
               (annotated-result))
    (when consult-omni-calc-regexp-pattern
      (if (string-match consult-omni-calc-regexp-pattern query nil)
          (setq query (or (match-string 1 query) query))
        (setq query nil)))
    (when query
      (condition-case err
          (if convert
              (cl-letf* (((symbol-function 'calc-convert-units)
                          (symbol-function 'calc-convert-exact-units)))
                (setq result (cond
                              ((string-match-p ".*deg.*" convert)
                               (setq result (calc-eval (math-convert-temperature (apply #'calc-eval (list query) 'raw extra-args) (apply #'calc-eval (list (replace-regexp-in-string "[[:digit:]\s$]+" "" query extra-args)) 'raw extra-args) (calc-eval (list convert) 'raw)))))
                              (t (calc-eval (math-convert-units (apply #'calc-eval (list query) 'raw extra-args) (calc-eval (list convert) 'raw)))))))
            (if consult-omni-calc-number-only
                (setq result (apply #'calc-eval (list query) 'num extra-args))
              (setq result (apply #'calc-eval (list query) nil extra-args))))
        (error (and consult-omni-calc-message-errors (message (error-message-string err)))))
      (when result (setq annotated-result (propertize result
                                                      :source source
                                                      :title result
                                                      :url nil
                                                      :query query)))
      (if annotated-result
          (list annotated-result)
        nil))))

#+end_src
**** define source
#+begin_src emacs-lisp
;; Define the Calc Source
(consult-omni-define-source "calc"
                            :narrow-char ?c
                            :category 'consult-omni-calc
                            :type 'sync
                            :require-match t
                            :face 'consult-omni-date-face
                            :request #'consult-omni--calc-fetch-results
                            :on-preview #'ignore
                            :on-return #'identity
                            :on-callback #'consult-omni--calc-callback
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :enabled (lambda () (fboundp 'calc-eval))
                            :group #'consult-omni--group-function
                            :sort t
                            :interactive consult-omni-intereactive-commands-type
                            :annotate nil)

#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-calc' module

(provide 'consult-omni-calc)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-calc)
;;; consult-omni-calc.el ends here
#+end_src


*** ChatGPT
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-chatgpt.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-chatgpt.el --- Consulting ChatGPT -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-chatgpt provides commands for getting ChatGPT results
;; directly in the minibuffer using consult-omni.

;;; Code:

(require 'consult-omni)

#+end_src
**** variables
***** custom
#+begin_src emacs-lisp
;;; User Options (a.k.a. Custom Variables)

(defcustom consult-omni-openai-api-key nil
  "Key for OpeAI API.

Can be a key string or a function that returns a key string.

Refer to URL `https://openai.com/product' and
URL `https://platform.openai.com/docs/introduction' for details on getting
an API key."
  :group 'consult-omni
  :type '(choice (string :tag "API Key")
                 (function :tag "Custom Function")))

#+end_src
***** other
#+begin_src emacs-lisp
(defvar consult-omni-chatgpt-api-url "https://api.openai.com/v1/chat/completions"
"API URL for OpenAI chatgpt service.")

#+end_src
**** helper functions
***** format
#+begin_src emacs-lisp
(defun consult-omni-dynamic--chatgpt-format-candidate (source query title &optional model face)
  "Format candidates of `consult-omni-chatgpt'.

Description of Arguments:

  SOURCE     a string; the source name to use \(e.g. “ChatGPT”\)
  QUERY      a string; query input from the user
  TITLE      a string; the title of the candidate
             \(e.g. response from ChatGPT\)
  MODEL      a string; the OpenAI model used
  FACE       a string; the face to apply to TITLE"
  (let* ((source (if (stringp source) (propertize source 'face 'consult-omni-source-type-face)))
         (title-str (consult-omni--set-string-width title (floor (* (frame-width) 0.4))))
         (title-str (propertize title-str 'face (or face 'consult-omni-ai-title-face)))
         (str (concat title-str "\t"
                      (propertize " " 'display '(space :align-to center))
                      (if model (propertize (format "model: %s" model) 'face 'consult-omni-path-face))
                      (if source (concat "\t" source))))
         (match-str (if (and (stringp query) (not (equal query ".*"))) (consult--split-escaped query) nil)))
    (if consult-omni-highlight-matches-in-minibuffer
        (cond
         ((listp match-str)
          (mapc (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-omni--highlight-match match-str str t)))))
    str))

#+end_src

***** preview
#+begin_src emacs-lisp
(defun consult-omni--chatgpt-response-preview (response &optional query)
  "Return a buffer with formatted RESPONSE to QUERY from ChatGPT."
  (save-excursion
    (let ((buff (get-buffer-create "*consult-omni-chatgpt-response*")))
      (with-current-buffer buff
        (erase-buffer)
        (if query (insert (format "# User:\n\n %s\n\n" query)))
        (if response (insert (format "# ChatGPT:\n\n %s\n\n" response)))
        (if (featurep 'mardown-mode)
            (require 'markdown-mode)
          (markdown-mode))
        (point-marker)))))

(defun consult-omni--chatgpt-preview (cand)
  "Show a preview buffer with ChatGPT response in CAND."
  (when-let ((buff (get-buffer "*consult-omni-chatgpt-response*")))
    (kill-buffer buff))
  (if (listp cand) (setq cand (or (car-safe cand) cand)))
  (when-let*  ((query  (get-text-property 0 :query cand))
               (response (or (get-text-property 0 :title cand) cand))
               (marker (consult-omni--chatgpt-response-preview response query)))
    (consult--jump marker)))

#+end_src

**** fetchng items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--chatgpt-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch chat response for INPUT from ChatGPT with ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (model (or (plist-get opts :model) "gpt-3.5-turbo"))
               (headers `(("Content-Type" . "application/json")
                          ("Authorization" . ,(concat "Bearer " (consult-omni-expand-variable-function consult-omni-openai-api-key))))))
    (consult-omni--fetch-url consult-omni-chatgpt-api-url
                             consult-omni-http-retrieve-backend
                             :type "POST"
                             :encoding 'utf-8
                             :headers headers
                             :data  (json-encode `((model . ,model)
                                                   (messages . [((role . "user")
                                                                 (content . ,query))])))
                             :parser #'consult-omni--json-parse-buffer
                             :callback
                             (lambda (attrs)
                               (let* ((source "ChatGPT")
                                      (url nil)
                                      (search-url nil)
                                      (choices (car-safe (gethash "choices" attrs)))
                                      (title (and choices (map-nested-elt choices '("message" "content"))))
                                      (model model)
                                      (decorated (consult-omni-dynamic--chatgpt-format-candidate source query title model))
                                      (annotated-results (and decorated
                                                              (propertize decorated
                                                                          :source source
                                                                          :title title
                                                                          :url url
                                                                          :model model
                                                                          :search-url search-url
                                                                          :query query))))
                                 (when (and annotated-results (functionp callback))
                                   (funcall callback (list annotated-results)))
                                 (list annotated-results))))))

#+end_src
**** define sources
#+begin_src emacs-lisp
;; Define the ChatGPT Source
(consult-omni-define-source "ChatGPT"
                            :narrow-char ?a
                            :type 'dynamic
                            :require-match t
                            :face 'consult-omni-ai-title-face
                            :request #'consult-omni--chatgpt-fetch-results
                            :preview-key consult-omni-preview-key
                            :on-preview #'consult-omni--chatgpt-preview
                            :on-return #'identity
                            :on-callback #'consult-omni--chatgpt-preview
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :enabled (lambda () (bound-and-true-p consult-omni-openai-api-key))
                            :group #'consult-omni--group-function
                            :sort t
                            :interactive consult-omni-intereactive-commands-type
                            :annotate nil)

#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-chatgpt' module

(provide 'consult-omni-chatgpt)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-chatgpt)
;;; consult-omni-chatgpt.el ends here
#+end_src


*** consult-line-multi
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-line-multi.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-line-multi.el --- Search Lines in All Buffers  -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-line-multi provides commands for searching lines in
;; multiple buffers similar to consult-line-multi but using consult-omni.

;;; Code:

(require 'consult)
(require 'consult-omni)

#+end_src
**** helper functions
***** get candidates
#+begin_src emacs-lisp
(defun consult-omni--line-multi-candidates (input &optional buffers)
  "Search for lines containing INPUT in multiple BUFFERS.

This is a wrapper around `consult--line-multi-candidates' for
consult-omni."
  (let  ((buffers (or buffers (consult--buffer-query :directory (consult--normalize-directory default-directory) :sort 'alpha-current))))
    (consult--line-multi-candidates buffers input)))

#+end_src
***** preview
#+begin_src emacs-lisp
(defun consult-omni--line-multi-preview (cand)
  "Preview function for CAND from `consult-omni-line-multi'."
  (let* ((marker (car (get-text-property 0 :marker cand)))
         (query (get-text-property 0 :query cand)))
    (consult--jump marker)))

#+end_src
***** format
#+begin_src emacs-lisp
(cl-defun consult-omni--line-multi-format-candidate (&rest args &key source query marker title face &allow-other-keys)
  "Format the candidates of `consult-omni-line-multi' with ARGS.

Description of Arguments:

  SOURCE     the source name to use (e.g. “buffers text search”)
  QUERY      query input from the user
  MARKER     the marker pointing to results of line multi search
  TITLE      the title of the candidate (e.g. response from chatgpt)
  FACE       the face to apply to TITLE"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (if (stringp source) (propertize source 'face 'consult-omni-source-type-face)))
         (marker (car marker))
         (buff (marker-buffer marker))
         (pos (marker-position marker))
         (buff (and buff (propertize (format "%s" buff) 'face 'consult-omni-domain-face)))
         (pos (and pos (propertize (format "%s" pos) 'face 'consult-omni-path-face)))
         (match-str (if (and (stringp query) (not (equal query ".*")))
                        (consult--split-escaped (car (consult--command-split query)))
                      nil))
         (face (or (consult-omni--get-source-prop source :face) face 'consult-omni-default-face))
         (title-str (propertize title 'face face))
         (title-str (consult-omni--set-string-width title-str (* 6 frame-width-percent)))
         (str (concat title-str
                      (when buff (concat "\t" buff))
                      (when pos (concat "\s\s" pos ))
                      (when source (concat "\t" source)))))
    (if consult-omni-highlight-matches-in-minibuffer
        (cond
         ((listp match-str)
          (mapc (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-omni--highlight-match match-str str t)))))
    str))

#+end_src

**** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--line-multi-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch search results for INPUT from `consult-line-multi' with ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (unless (functionp 'consult-omni--line-multi-candidates)
    (error "Consult-omni: consult-omni-line-multi not available.  Make sure `consult' is loaded properly"))
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (items (consult-omni--line-multi-candidates query))
               (annotated-results (mapcar (lambda (item)
                                            (let* ((source "buffers text search")
                                                   (marker  (consult--get-location item))
                                                   (title (substring-no-properties item 0 -1))
                                                   (decorated (consult-omni--line-multi-format-candidate :source source :query query :marker marker :title title)))
                                              (propertize decorated
                                                          :source source
                                                          :title title
                                                          :url nil
                                                          :marker marker
                                                          :query query
                                                          )))
                                          items)))
    annotated-results))

#+end_src


**** define source
#+begin_src emacs-lisp
;; Define the Buffers Text Search Source
(consult-omni-define-source "buffers text search"
                            :narrow-char ?s
                            :type 'sync
                            :require-match t
                            :category 'consult-location
                            :face 'default
                            :request #'consult-omni--line-multi-fetch-results
                            :preview-key consult-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :on-preview #'consult-omni--line-multi-preview
                            :on-return #'identity
                            :on-callback #'consult-omni--line-multi-preview
                            :enabled (lambda () (fboundp 'consult-omni--line-multi-candidates))
                            :group #'consult-omni--group-function
                            :sort t
                            :interactive consult-omni-intereactive-commands-type
                            :annotate nil)

#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-line-multi' module

(provide 'consult-omni-line-multi)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-line-multi)
;;; consult-omni-line-multi.el ends here
#+end_src
*** consult sources
**** consult-buffer
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-buffer.el
:END:
***** header

#+begin_src emacs-lisp
;;; consult-omni-buffer.el --- Consulting Buffers -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-buffer provides commands for searching buffer names
;; similar to consult-buffer but using consult-omni.

;;; Code:

(require 'consult-omni)

#+end_src
***** helper functions
****** preview
#+begin_src emacs-lisp
(defun consult-omni--consult-buffer-preview (cand)
  "Preview function for CAND from `consult-omni--buffer'."
  (if cand
      (let* ((title (get-text-property 0 :title cand)))
        (when-let ((buff (get-buffer title)))
          (consult--buffer-action buff)))))

#+end_src
***** define source
****** buffer
#+begin_src emacs-lisp
;; make a consult-omni source from `consult--source-buffer'
(consult-omni--make-source-from-consult-source 'consult--source-buffer
                                               :type 'sync
                                               :on-preview #'consult-omni--consult-buffer-preview
                                               :on-return #'identity
                                               :on-callback #'consult--buffer-action
                                               :search-hist 'consult-omni--search-history
                                               :select-hist 'consult-omni--selection-history
                                               :interactive consult-omni-intereactive-commands-type
                                               :preview-key 'consult-omni-preview-key
                                               :on-new #'consult--buffer-action
                                               :group #'consult-omni--group-function
                                               :enabled (lambda () (bound-and-true-p consult--source-buffer)))

#+end_src
****** modified buffer
#+begin_src emacs-lisp
;; make a consult-omni source from `consult--source-modified-buffer'
(consult-omni--make-source-from-consult-source 'consult--source-modified-buffer
                                               :type 'sync
                                               :on-preview #'consult-omni--consult-buffer-preview
                                               :on-return #'identity
                                               :on-callback #'consult--buffer-action
                                               :search-hist 'consult-omni--search-history
                                               :select-hist 'consult-omni--selection-history
                                               :interactive consult-omni-intereactive-commands-type
                                               :preview-key 'consult-omni-preview-key
                                               :on-new #'consult--buffer-action
                                               :group #'consult-omni--group-function
                                               :enabled (lambda () (bound-and-true-p consult--source-modified-buffer)))

#+end_src
****** hidden buffer
#+begin_src emacs-lisp
;; make a consult-omni source from `consult--source-hidden-buffer'
(consult-omni--make-source-from-consult-source 'consult--source-hidden-buffer
                                               :type 'sync
                                               :on-preview #'consult-omni--consult-buffer-preview
                                               :on-return #'identity
                                               :on-callback #'consult--buffer-action
                                               :search-hist 'consult-omni--search-history
                                               :select-hist 'consult-omni--selection-history
                                               :interactive consult-omni-intereactive-commands-type
                                               :preview-key 'consult-omni-preview-key
                                               :on-new #'consult--buffer-action
                                               :group #'consult-omni--group-function
                                               :enabled (lambda () (bound-and-true-p consult--source-hidden-buffer)))

#+end_src
****** project buffer
#+begin_src emacs-lisp
;; make a consult-omni source from `consult--source-project-buffer'
(consult-omni--make-source-from-consult-source 'consult--source-project-buffer
                                               :type 'sync
                                               :on-preview #'consult-omni--consult-buffer-preview
                                               :on-return #'identity
                                               :on-callback #'consult--buffer-action
                                               :search-hist 'consult-omni--search-history
                                               :select-hist 'consult-omni--selection-history
                                               :interactive consult-omni-intereactive-commands-type
                                               :preview-key 'consult-omni-preview-key
                                               :on-new #'consult--buffer-action
                                               :group #'consult-omni--group-function
                                               :enabled :enabled (lambda () (bound-and-true-p consult--source-project-buffer)))

#+end_src
****** recent file
#+begin_src emacs-lisp
;; make a consult-omni source from `consult--source-recent-file'
(consult-omni--make-source-from-consult-source 'consult--source-recent-file
                                               :type 'sync
                                               :on-preview #'consult-omni--consult-buffer-preview
                                               :on-return #'identity
                                               :on-callback #'consult--file-action
                                               :search-hist 'consult-omni--search-history
                                               :select-hist 'consult-omni--selection-history
                                               :interactive consult-omni-intereactive-commands-type
                                               :preview-key 'consult-omni-preview-key
                                               :on-new #'consult--file-action
                                               :group #'consult-omni--group-function
                                               :enabled (lambda () (bound-and-true-p consult--source-recent-file)))

#+end_src
****** project recent file
#+begin_src emacs-lisp
;; make a consult-omni source from `consult--source-project-recent-file'
(consult-omni--make-source-from-consult-source 'consult--source-project-recent-file
                                               :type 'sync
                                               :on-preview #'consult-omni--consult-buffer-preview
                                               :on-return #'identity
                                               :on-callback #'consult--file-action
                                               :search-hist 'consult-omni--search-history
                                               :select-hist 'consult-omni--selection-history
                                               :interactive consult-omni-intereactive-commands-type
                                               :preview-key 'consult-omni-preview-key
                                               :on-new #'consult--file-action
                                               :group #'consult-omni--group-function
                                               :enabled (lambda () (bound-and-true-p consult--source-project-recent-file)))

#+end_src
****** bookmark
#+begin_src emacs-lisp
;; make a consult-omni source from `consult--source-bookmark'
(consult-omni--make-source-from-consult-source 'consult--source-bookmark
                                               :type 'sync
                                               :on-preview #'consult-omni--consult-buffer-preview
                                               :on-return #'identity
                                               :on-callback #'consult--bookmark-action
                                               :search-hist 'consult-omni--search-history
                                               :select-hist 'consult-omni--selection-history
                                               :interactive consult-omni-intereactive-commands-type
                                               :preview-key 'consult-omni-preview-key
                                               :on-new #'bookmark-set
                                               :group #'consult-omni--group-function
                                               :enabled (lambda () (bound-and-true-p consult--source-bookmark)))

#+end_src

***** provide and footer

#+begin_src emacs-lisp
;;; provide `consult-omni-buffer' module

(provide 'consult-omni-buffer)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-buffer)
;;; consult-omni-buffer.el ends here
#+end_src


**** consult-fd
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-fd.el
:END:
***** header
#+begin_src emacs-lisp
;;; consult-omni-fd.el --- Consulting Fd Command -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-fd provides commands for running “fd” shell commands
;; similar to consult-fd but using consult-omni.

;;; Code:

(require 'consult-omni)

#+end_src
***** variables
****** custom
#+begin_src emacs-lisp
;;; User Options (a.k.a. Custom Variables)

(defcustom consult-omni-fd-show-hidden-files t
  "Whether to show hidden files in `consult-omni-fd'."
  :group 'consult-omni
  :type 'boolean)

(defcustom consult-omni-fd-args (list (if (executable-find "fdfind" 'remote) "fdfind" "fd")
                                      "--full-path --color=never")
  "Command line arguments for fd.

Similar to `consult-fd-args' bur for consult-omni."
  :group 'consult-omni
  :type '(choice string (repeat (choice string sexp))))

#+end_src
***** helper functions
****** transform
#+begin_src emacs-lisp
(defun consult-omni--fd-transform (candidates &optional _query)
  "Format CANDIDATES of `consult-omni-fd' with ARGS."
  (mapcar (lambda (candidate)
            (string-trim (string-remove-prefix (file-truename default-directory) candidate)))
          candidates))

#+end_src
****** preview
#+begin_src emacs-lisp
(defun consult-omni--fd-preview (cand)
  "Preview function for CAND from `consult-omni-find'."
  (funcall (consult--file-preview) 'preview cand))

#+end_src

****** callback
#+begin_src emacs-lisp
(defun consult-omni--fd-callback (cand)
  "Callback for CAND from `consult-omni-find'."
  (consult--file-action cand))

#+end_src

***** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--fd-builder (input &rest args &key callback &allow-other-keys)
  "Make builder command line args for “fd” from INPUT with ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (hidden (if (plist-member opts :hidden) (plist-get opts :hidden) consult-omni-fd-show-hidden-files))
               (case-sensitive (if (plist-member opts :case) (plist-get opts :case) nil))
               (exclude (or (plist-get opts :ignore) (plist-get opts :exclude)))
               (exclude (if exclude (format "%s" exclude)))
               (dir (plist-get opts :dir))
               (dir (if dir (file-truename (format "%s" dir))))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (default-directory (or dir default-directory))
               (`(_ ,paths _) (consult--directory-prompt "" dir))
               (paths (if dir
                          (mapcar (lambda (path) (file-truename (concat dir path))) paths)
                        paths))
               (consult-fd-args (append consult-omni-fd-args
                                        (and hidden (list "--hidden"))
                                        (and case-sensitive (list "--case-sensitive"))
                                        (and exclude (list (concat "--exclude " exclude))))))
    (funcall (consult--fd-make-builder paths) query)))

#+end_src

***** define source
#+begin_src emacs-lisp
;; Define the fd Source
(consult-omni-define-source "fd"
                            :narrow-char ?f
                            :category 'file
                            :type 'async
                            :require-match t
                            :face 'consult-omni-engine-title-face
                            :request #'consult-omni--fd-builder
                            :transform #'consult-omni--fd-transform
                            :on-preview #'consult-omni--fd-preview
                            :on-return #'identity
                            :on-callback #'consult-omni--fd-callback
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :group #'consult-omni--group-function
                            :sort t
                            :interactive consult-omni-intereactive-commands-type
                            :enabled (lambda () (or (executable-find "fdfind")
                                               (executable-find "fd")))
                            :annotate nil)

#+end_src

***** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-fd' module

(provide 'consult-omni-fd)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-fd)
;;; consult-omni-fd.el ends here
#+end_src


**** consult-find
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-find.el
:END:
***** header
#+begin_src emacs-lisp
;;; consult-omni-find.el --- Consulting Find Command -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-find provides commands for running “find” shell commands
;; similar to consult-find but using consult-omni.

;;; Code:

(require 'consult-omni)

#+end_src
***** variables
****** custom
#+begin_src emacs-lisp
;;; User Options (a.k.a. Custom Variables)

(defcustom consult-omni-find-show-hidden-files t
  "Whether to show hidden files in `consult-omni-find'."
  :group 'consult-omni
  :type 'boolean)

(defcustom consult-omni-find-args  "find ."
  "Command line arguments for find.

Similar to `consult-find-args' bur for consult-omni."
  :group 'consult-omni
  :type '(choice string (repeat (choice string sexp))))

#+end_src
***** helper functions
****** transform
#+begin_src emacs-lisp
(defun consult-omni--find-transform (candidates &optional _query)
  "Format CANDIDATES of `consult-omni-find'."
  (mapcar (lambda (candidate)
            (string-trim (string-remove-prefix (file-truename default-directory) candidate)))
          candidates))

#+end_src
****** filter
#+begin_src emacs-lisp
(defun consult-omni--find-filter (candidates &optional _query)
  "Filters for CANDIDATES of `consult-omni-find'."
  (seq-filter (lambda (candidate) (not (string-match "^find:.*$" candidate nil nil))) candidates))

#+end_src
****** preview
#+begin_src emacs-lisp
(defun consult-omni--find-preview (cand)
  "Preview function for CAND from `consult-omni-find'."
  (funcall (consult--file-preview) 'preview cand))

#+end_src

****** callback
#+begin_src emacs-lisp
(defun consult-omni--find-callback (cand)
  "Callback for CAND from `consult-omni-find'."
  (consult--file-action cand))

#+end_src

***** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--find-builder (input &rest args &key callback &allow-other-keys)
  "Make builder command line args for “find” from INPUT from ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (hidden (if (plist-member opts :hidden) (plist-get opts :hidden) consult-omni-find-show-hidden-files))
               (ignore (plist-get opts :ignore))
               (ignore (if ignore (format "%s" ignore)))
               (dir (plist-get opts :dir))
               (dir (if dir (file-truename (format "%s" dir))))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (default-directory (or dir default-directory))
               (`(_ ,paths _) (consult--directory-prompt "" dir))
               (paths (if dir
                          (mapcar (lambda (path) (file-truename (concat dir path))) paths)
                        paths))
               (consult-find-args (concat consult-omni-find-args
                                          (if (not hidden) " -not -iwholename *./[a-z]*")
                                          (if ignore (concat " -not -iwholename *" ignore "*")))))
    (funcall (consult--find-make-builder paths) query)))

#+end_src

***** define source
#+begin_src emacs-lisp
;; Define the find Source
(consult-omni-define-source "find"
                            :narrow-char ?f
                            :category 'file
                            :type 'async
                            :require-match t
                            :face 'consult-omni-engine-title-face
                            :request #'consult-omni--find-builder
                            :transform #'consult-omni--find-transform
                            :filter #'consult-omni--find-filter
                            :on-preview #'consult-omni--find-preview
                            :on-return #'identity
                            :on-callback #'consult-omni--find-callback
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :group #'consult-omni--group-function
                            :sort t
                            :interactive consult-omni-intereactive-commands-type
                            :enabled (lambda () (executable-find "find"))
                            :annotate nil)

#+end_src

***** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-find' module

(provide 'consult-omni-find)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-find)
;;; consult-omni-find.el ends here
#+end_src


**** consult-git-grep
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-git-grep.el
:END:
***** header
#+begin_src emacs-lisp
;;; consult-omni-git-grep.el --- Consulting Git Grep Command -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-git-grep provides commands for running “git grep” shell
;; commands similar to consult-git-grep but using consult-omni.


;;; Code:

(require 'consult-omni)
(require 'consult-omni-grep)
#+end_src
***** helper functions
****** transform
#+begin_src emacs-lisp
(defun consult-omni--git-grep-transform (candidates &optional query)
  "Format CANDIDATES of `consult-omni-git-grep' from QUERY."
  (consult-omni--grep-format candidates :source "git-grep" :query query :regexp-pattern consult--grep-match-regexp))

#+end_src

***** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--git-grep-builder (input &rest args &key callback &allow-other-keys)
  "Make builder command line args for “git-grep” from INPUT with ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (dir (plist-get opts :dir))
               (dir (if dir (file-truename (format "%s" dir))))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (default-directory (or dir default-directory)))
    (funcall (consult-omni--grep-make-builder #'consult--git-grep-make-builder dir) query)))

#+end_src


***** define source
#+begin_src emacs-lisp
;; Define the git-grep Source
(consult-omni-define-source "git-grep"
                            :narrow-char ?r
                            :type 'async
                            :require-match t
                            :face 'consult-omni-engine-title-face
                            :request #'consult-omni--git-grep-builder
                            :transform #'consult-omni--git-grep-transform
                            :on-preview #'consult-omni--grep-preview
                            :on-return #'identity
                            :on-callback #'consult-omni--grep-preview
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :group #'consult-omni--group-function
                            :enabled (lambda () (and (executable-find "git")
                                                    (fboundp 'consult-git-grep)))
                            :sort nil
                            :interactive consult-omni-intereactive-commands-type
                            :annotate nil)

#+end_src

***** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-git-grep' module

(provide 'consult-omni-git-grep)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-git-grep)
;;; consult-omni-git-grep.el ends here
#+end_src


**** consult-grep
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-grep.el
:END:
***** header
#+begin_src emacs-lisp
;;; consult-omni-grep.el --- Consulting Grep Command -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-grep provides commands for running “grep” shell commands
;; similar to consult-grep but using consult-omni.

;;; Code:

(require 'consult-omni)

#+end_src
***** helper functions
****** format
#+begin_src emacs-lisp
(cl-defun consult-omni--grep-format (candidates &rest args &key source query regexp-pattern)
  "Format CANDIDATES for grep based commands with ARGS.

Description of Arguments:
  SOURCE         a string; the source name \(e.g. “grep”\)
  QUERY          a string; query input from the user
  REGEXP-PATTERN a string; regexp to match file and line of grep output
                 \(for an example, see `consult--grep-match-regexp'\)

Adopted from `consult--grep-format'."
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (file "")
         (filename "")
         (file-len 0)
         (file-str "")
         (file-str-len 0)
         result)
    (dolist (str candidates)
      (when (and (string-match regexp-pattern str)
                 ;; Filter out empty context lines
                 (or (/= (aref str (match-beginning 3)) ?-)
                     (/= (match-end 0) (length str))))
        ;; We share the file name across candidates to reduce
        ;; the amount of allocated memory.
        (unless (and (= file-len (- (match-end 1) (match-beginning 1)))
                     (eq t (compare-strings
                            file 0 file-len
                            str (match-beginning 1) (match-end 1) nil)))
          (setq file (match-string 1 str)
                file-len (length file)))
        (let* ((line (match-string 2 str))
               (ctx (= (aref str (match-beginning 3)) ?-))
               (sep (if ctx "-" ":"))
               (content (substring str (match-end 0)))
               (line-len (length line))
               (cand)
               (file-str (string-remove-prefix (file-truename default-directory) (file-truename file)))
               (file-str (if (> (length file-str) (* frame-width-percent 5))
                             (consult-omni--set-string-width file-str (* frame-width-percent 5) (* frame-width-percent 1))
                           file-str))
               (file-str-len (length file-str)))
          (when (length> content consult-grep-max-columns)
            (setq content  (consult-omni--set-string-width content consult-grep-max-columns)))
          (setq cand (concat file-str sep line sep content))
          ;; Store file name in order to avoid allocations in `consult--prefix-group'
          (add-text-properties 0 1 `(:source ,source :title ,cand :query ,query :file ,file :pos ,line :content ,content) cand)
          (add-text-properties 0 file-str-len `(face consult-file consult--prefix-group ,file) cand)
          (put-text-property (1+ file-str-len) (+ 1 file-str-len line-len) 'face 'consult-line-number cand)
          (when ctx
            (add-face-text-property (+ 2 file-str-len line-len) (length cand) 'consult-grep-context 'append cand))
          (push cand result)
          )))
    result))

#+end_src
****** transform
#+begin_src emacs-lisp
(defun consult-omni--grep-transform (candidates &optional query)
  "Format CANDIDATES for `consult-omni-grep' from QUERY."
  (consult-omni--grep-format candidates :source "grep" :query query :regexp-pattern consult--grep-match-regexp))

#+end_src
****** grep-builder
#+begin_src emacs-lisp
(defun consult-omni--grep-make-builder (make-builder &optional dir)
  "Build command line for grep and similar processes.

Description of Arguments:
  MAKE-BUILDER a function; takes one argument, PATHS, and builds grep
               command line across PATHS.
  DIR          a string; parent directory to use for getting PATHS"
  (pcase-let* ((`(_ ,paths ,dir) (consult--directory-prompt "" dir))
               (paths (if dir
                          (mapcar (lambda (path) (file-truename (concat dir path))) paths)
                        paths)))
    (funcall make-builder paths)))

#+end_src



****** preview
#+begin_src emacs-lisp
(defun consult-omni--grep-preview (cand)
  "Preview function for CAND from `consult-omni-grep'."
  (let ((file (get-text-property 0 :file cand))
        (pos (get-text-property 0 :pos cand))
        (content (get-text-property 0 :content cand))
        (query (get-text-property 0 :query cand)))
    (when file
      (with-current-buffer (funcall #'consult--file-action file)
        (when (stringp pos) (forward-line (- (string-to-number pos) (line-number-at-pos))))
        (consult--invisible-open-permanently)
        (recenter nil t)
        (when consult-omni-highlight-matches-in-file
          (consult-omni--overlay-match query nil consult-omni-highlight-match-ignore-case)
          (add-to-history 'search-ring (isearch-string-propertize query)))
        (consult-omni--pulse-line))
      nil)))

#+end_src

***** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--grep-builder (input &rest args &key callback &allow-other-keys)
  "Make builder command line args for “grep” with INPUT and ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (dir (plist-get opts :dir))
               (dir (if dir (file-truename (format "%s" dir))))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (default-directory (or dir default-directory)))
    (funcall (consult-omni--grep-make-builder #'consult--grep-make-builder dir) query)))

#+end_src


***** define source
#+begin_src emacs-lisp
;; Define the grep Source
(consult-omni-define-source "grep"
                            :narrow-char ?r
                            :type 'async
                            :require-match t
                            :face 'consult-omni-engine-title-face
                            :request #'consult-omni--grep-builder
                            :transform #'consult-omni--grep-transform
                            :on-preview #'consult-omni--grep-preview
                            :on-return #'identity
                            :on-callback #'consult-omni--grep-preview
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :group #'consult-omni--group-function
                            :sort nil
                            :interactive consult-omni-intereactive-commands-type
                            :transform #'consult-omni--ripgrep-transform
                            :enabled (lambda () (and (executable-find "grep")
                                                (fboundp 'consult-grep)
                                                t))
                            :annotate nil)

#+end_src

***** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-grep' module

(provide 'consult-omni-grep)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-grep)
;;; consult-omni-grep.el ends here
#+end_src


**** consult-locate
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-locate.el
:END:
***** header
#+begin_src emacs-lisp
;;; consult-omni-locate.el --- Consulting Locate Command -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-locate provides commands for running “locate” shell
;; commands similar to consult-locate but using consult-omni.


;;; Code:

(require 'consult-omni)

#+end_src

***** variables
****** custom
#+begin_src emacs-lisp
;;; User Options (a.k.a. Custom Variables)

(defcustom consult-omni-locate-limit consult-omni-default-count
  "Max number results for `consult-omni-locate'.

This is passed to “-l” command line argument."
  :group 'consult-omni
  :type 'integer)

(defcustom consult-omni-locate-args "locate -i"
  "Command line arguments for locate.

Similar to `consult-locate-args' bur for consult-omni."
  :group 'consult-omni
  :type '(choice string (repeat (choice string sexp))))

#+end_src
***** helper functions
****** preview
#+begin_src emacs-lisp
(defun consult-omni--locate-preview (cand)
  "Preview function for CAND from `consult-omni-locate'."
  (funcall (consult--file-preview) 'preview cand))

#+end_src

****** callback
#+begin_src emacs-lisp
(defun consult-omni--locate-callback (cand)
  "Callback for CAND from `consult-omni-locate'."
  (consult--file-action cand))

#+end_src

****** transform
#+begin_src emacs-lisp
(defun consult-omni--locate-transform (candidates &optional _query)
  "Format CANDIDATES of `consult-omni-locate'."
  (mapcar (lambda (candidate)
            (string-remove-prefix (file-truename default-directory)
                                  candidate))
          candidates))

#+end_src



****** filter
#+begin_src emacs-lisp
(defun consult-omni--locate-filter (candidates &optional _query)
  "Filter CANDIDATES for `consult-omni-locate'."
  (seq-filter (lambda (candidate)
                (not (string-match "^locate:.*$" candidate nil nil)))
              candidates))

#+end_src
***** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--locate-builder (input &rest args &key callback &allow-other-keys)
  "Make builder command line args for “locate” with INPUT and ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (dir (plist-get opts :dir))
               (dir (if dir (file-truename (format "%s" dir))))
               (count (or (and (integerp count) count)
                          (and count (string-to-number (format "%s" count)))
                          consult-omni-locate-limit))
               (default-directory (or dir default-directory))
               (consult-locate-args (concat consult-omni-locate-args
                                            (if count (format " -l %s" count)))))
    (funcall #'consult--locate-builder query)))

#+end_src

***** define source
#+begin_src emacs-lisp
;; Define the locate source
(consult-omni-define-source "locate"
                            :narrow-char ?f
                            :category 'file
                            :type 'async
                            :require-match t
                            :face 'consult-omni-engine-title-face
                            :request #'consult-omni--locate-builder
                            :filter #'consult-omni--locate-filter
                            :on-preview #'consult-omni--locate-preview
                            :on-return #'identity
                            :on-callback #'consult-omni--locate-callback
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :group #'consult-omni--group-function
                            :enabled (lambda () (executable-find "locate"))
                            :sort t
                            :interactive consult-omni-intereactive-commands-type
                            :annotate nil)

#+end_src

***** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-locate' module

(provide 'consult-omni-locate)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-locate)
;;; consult-omni-locate.el ends here
#+end_src



**** consult-man
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-man.el
:END:
***** header
#+begin_src emacs-lisp
;;; consult-omni-man.el --- Consulting Man Command -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-man provides commands for running “man” shell commands
;; similar to consult-man but using consult-omni.


;;; Code:

(require 'consult-omni)

#+end_src
***** variables
****** custom
#+begin_src emacs-lisp
;;; User Options (a.k.a. Custom Variables)

(defcustom consult-omni-man-args "man -k"
  "Command line arguments for man.

Similar to `consult-man-args' bur for consult-omni."
  :group 'consult-omni
  :type '(choice string (repeat (choice string sexp))))

#+end_src
***** helper functions
****** preview
#+begin_src emacs-lisp
(defun consult-omni--man-preview (cand)
  "Preview function for CAND from `consult-omni-man'."
  (when-let* ((Man-notify-method 'quiet)
              (path (get-text-property 0 :path cand)))
    (funcall (consult--buffer-preview) 'preview (man path))))

#+end_src

****** callback
#+begin_src emacs-lisp
(defun consult-omni--man-callback (cand)
  "Callback for CAND from `consult-omni-man'."
  (when-let ((path (get-text-property 0 :path cand)))
    (man path)))

#+end_src

****** transform
#+begin_src emacs-lisp
(defun consult-omni--man-transform (candidates &optional query)
  "Format CANDIDATES for QUERY from `consult-omni-man'."
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (match-str (if (and (stringp query) (not (equal query ".*"))) (consult--split-escaped query) nil))
         (source (propertize "man" 'face 'consult-omni-source-type-face))
         (results))
    (save-match-data
      (dolist (cand candidates)
        (when (string-match "\\`\\(.*?\\([^ ]+\\) *(\\([^,)]+\\)[^)]*).*?\\) +- +\\(.*\\)\\'" cand)
          (let* ((names (match-string 1 cand))
                 (name (match-string 2 cand))
                 (section (match-string 3 cand))
                 (desc (match-string 4 cand))
                 (path (concat section " " name))
                 (snippet (and (stringp desc) (propertize desc 'face 'consult-omni-snippet-face)))
                 (face (or (consult-omni--get-source-prop source :face) 'consult-omni-default-face))
                 (title (propertize names 'face face))
                 (title-str (and (stringp title) (consult-omni--set-string-width title (* 6 frame-width-percent))))
                 (str (concat title-str
                              (and desc "\t") desc
                              (and source "\t") source)))
            (if consult-omni-highlight-matches-in-minibuffer
                (cond
                 ((listp match-str)
                  (mapc (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
                 ((stringp match-str)
                  (setq str (consult-omni--highlight-match match-str str t)))))
            (push (propertize str :source "man" :query query :title title :path path :url nil :search-url nil :snippet desc) results)))))
    (nreverse results)))

#+end_src




***** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--man-builder (input &rest args &key callback &allow-other-keys)
  "Make builder command line args for “man” with INPUT and ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (consult-man-args consult-omni-man-args))
    (funcall #'consult--man-builder query)))
#+end_src

***** define source
#+begin_src emacs-lisp
;; Define the man source
(consult-omni-define-source "man"
                            :narrow-char ?m
                            :category 'consult-man
                            :type 'async
                            :require-match t
                            :face 'consult-omni-engine-title-face
                            :request #'consult-omni--man-builder
                            :transform #'consult-omni--man-transform
                            :on-preview #'consult-omni--man-preview
                            :on-return #'identity
                            :on-callback #'consult-omni--man-callback
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :group #'consult-omni--group-function
                            :enabled (lambda () (executable-find "man"))
                            :sort t
                            :interactive consult-omni-intereactive-commands-type
                            :annotate nil)

#+end_src

***** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-man' module

(provide 'consult-omni-man)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-man)
;;; consult-omni-man.el ends here
#+end_src



**** consult-mdfind
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-locate.el
:END:
***** header
#+begin_src emacs-lisp
;;; consult-omni-mdfind.el --- Consulting mdfind Command -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-mdfind provides commands for running “mdfind” shell
;; commands

;;; Code:

(require 'consult-omni)

#+end_src

***** variables
****** custom
#+begin_src emacs-lisp
;;; User Options (a.k.a. Custom Variables)

(defcustom consult-omni-mdfind-interpret t
  "Whether to toggle “-interpret” arg in mdfind.
See mdfind documents (e.g. “man mdfind”) for more details."
  :group 'consult-omni
  :type 'boolean)

(defcustom consult-omni-mdfind-args "mdfind"
  "Command line arguments for mdfind.

Similar to other command line args for consult but for mdfind.
See `consult-locate-args' for an example."
  :group 'consult-omni
  :type '(choice string (repeat (choice string sexp))))

#+end_src

***** helper functions
****** preview
#+begin_src emacs-lisp
(defun consult-omni--mdfind-preview (cand)
  "Preview function for CAND from `consult-omni-mdfind'."
  (funcall (consult--file-preview) 'preview cand))

#+end_src

****** callback
#+begin_src emacs-lisp
(defun consult-omni--mdfind-callback (cand)
  "Callback for CAND from `consult-omni-locate'."
  (consult--file-action cand))

#+end_src

***** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--mdfind-builder (input &rest args &key callback &allow-other-keys)
  "Make builder command line args for “mdfind” with INPUT and ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (dir (plist-get opts :dir))
               (dir (if dir (file-truename (format "%s" dir))))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (default-directory (or dir default-directory))
               (consult-locate-args (concat consult-omni-mdfind-args
                                            (if consult-omni-mdfind-interpret " -interpret")
                                            (if dir (format " -onlyin %s" dir)))))
    (funcall #'consult--locate-builder query)))

#+end_src

***** define source
#+begin_src emacs-lisp
;; Define the mdfind source
(consult-omni-define-source "mdfind"
                            :narrow-char ?f
                            :category 'file
                            :type 'async
                            :require-match t
                            :face 'consult-omni-engine-title-face
                            :request #'consult-omni--mdfind-builder
                            :on-preview #'consult-omni--mdfind-preview
                            :on-return #'identity
                            :on-callback #'consult-omni--mdfind-callback
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :group #'consult-omni--group-function
                            :enabled (lambda () (executable-find "mdfind"))
                            :sort nil
                            :interactive consult-omni-intereactive-commands-type
                            :annotate nil)

#+end_src

***** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-mdfind' module

(provide 'consult-omni-mdfind)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-mdfind)
;;; consult-omni-mdfind.el ends here
#+end_src



**** consult-ripgrep
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-ripgrep.el
:END:
***** header
#+begin_src emacs-lisp
;;; consult-omni-ripgrep.el --- Consulting Ripgrep Command -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-ripgrep provides commands for running “rg” shell commands
;; similar to consult-ripgrep but using consult-omni.

;;; Code:

(require 'consult-omni)
(require 'consult-omni-grep)

#+end_src
***** helper functions
****** transform
#+begin_src emacs-lisp
(defun consult-omni--ripgrep-transform (candidates &optional query)
  "Format CANDIDATES for QUERY from `consult-omni-ripgrep'."
  (consult-omni--grep-format candidates :source "ripgrep" :query query :regexp-pattern consult--grep-match-regexp))

#+end_src

***** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--ripgrep-builder (input &rest args &key callback &allow-other-keys)
  "Make builder command line args for “ripgrep” with INPUT and ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (dir (plist-get opts :dir))
               (dir (if dir (file-truename (format "%s" dir))))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (default-directory (or dir default-directory)))
    (funcall (consult-omni--grep-make-builder #'consult--ripgrep-make-builder dir) query)))

#+end_src


***** define source
#+begin_src emacs-lisp
;; Define the ripgrep source
(consult-omni-define-source "ripgrep"
                            :narrow-char ?r
                            :type 'async
                            :require-match t
                            :face 'consult-omni-engine-title-face
                            :request #'consult-omni--ripgrep-builder
                            :transform #'consult-omni--ripgrep-transform
                            :on-preview #'consult-omni--grep-preview
                            :on-return #'identity
                            :on-callback #'consult-omni--grep-preview
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :group #'consult-omni--group-function
                            :enabled (lambda () (and (executable-find "rg")
                                                     (fboundp 'consult-ripgrep)))
                            :sort nil
                            :interactive consult-omni-intereactive-commands-type
                            :annotate nil)

#+end_src

***** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-ripgrep' module

(provide 'consult-omni-ripgrep)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-ripgrep)
;;; consult-omni-ripgrep.el ends here
#+end_src


**** consult-ripgrep-all
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-ripgrep-all.el
:END:
***** header
#+begin_src emacs-lisp
;;; consult-omni-ripgrep-all.el --- Consulting Ripgrep-all Command -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-ripgrep-all provides commands for running “rga” shell
;; commands.
;;
;; For info on ripgrep-all, see:
;; URL `https://github.com/phiresky/ripgrep-all'

;;; Code:

(require 'consult-omni)
(require 'consult-omni-grep)

#+end_src
***** variables
****** custom
#+begin_src emacs-lisp
;;; User Options (a.k.a. Custom Variables)

(defcustom consult-omni-ripgrep-all-args
  '("rga" "--null" "--line-buffered" "--color=never" "--max-columns=1000" "--path-separator" "/" "--smart-case" "--no-heading" "--with-filename" "--line-number")
  "Command line arguments for rga (ripgrep-all), see `consult-omni-ripgrep-all'.
The dynamically computed arguments are appended.
Can be either a string, or a list of strings or expressions."
  :group 'consult-omni
  :type '(choice string (repeat (choice string sexp))))

#+end_src
****** other
#+begin_src emacs-lisp
(defconst consult-omni-ripgrep-all-match-regexp "\\`\\(?:\\./\\)?\\([^\n\0]+\\)\0\\([0-9]+\\)\\([-:]\\)\\([pP]age\s\\)?\\([0-9]+\\)?\\(.*\\)[-:\0]"
  "Regexp used to match file and line of grep output.")

#+end_src
***** helper functions
****** format
#+begin_src emacs-lisp
(cl-defun consult-omni--ripgrep-all-format (candidates &rest args &key source query regexp-pattern)
  "Format CANDIDATES for ripgrep-all commands with ARGS.

Description of Arguments:
  SOURCE         a string; the source name \(e.g. “ripgrep-all”\)
  QUERY          a string; query input from the user
  REGEXP-PATTERN a string; regexp to match file and line of ripgrep-all output
                 \(for an example, see `consult-omni-ripgrep-all-match-regexp'\)

Adopted from `consult--grep-format'."
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (file "")
         (file-len 0)
         (file-str)
         (cand)
         result)
    (save-match-data
      (dolist (str candidates)
        (when (and (not (string-prefix-p "Error" str))
                   (not (string-prefix-p "Syntax Error" str))
                   (string-match regexp-pattern str)
                   ;; Filter out empty context lines
                   (or (/= (aref str (match-beginning 3)) ?-)
                       (/= (match-end 0) (length str))))
          ;; We share the file name across candidates to reduce
          ;; the amount of allocated memory.
          (unless (and (= file-len (- (match-end 1) (match-beginning 1)))
                       (eq t (compare-strings
                              file 0 file-len
                              str (match-beginning 1) (match-end 1) nil)))
            (setq file (match-string 1 str)
                  file-len (length file)))

          (let* ((line (match-string 2 str))
                 (ctx (and (numberp (match-beginning 3)) (= (aref str (match-beginning 3)) ?-)))
                 (sep (if ctx "-" ":"))
                 (content (substring str (or (match-end 5) (match-end 4) (match-end 3) (match-end 2) (match-end 1) (match-end 0))))
                 (page (match-string 5 str))
                 (page-str (and page (concat "Page " page)))
                 (line-len (length line))
                 (file-str (string-remove-prefix (file-truename default-directory) (file-truename file)))
                 (file-str (if (and (stringp file-str) (> (length file-str) (* frame-width-percent 2)))
                               (consult-omni--set-string-width file-str (* frame-width-percent 2) (* frame-width-percent 1))
                             file-str))
                 (file-str-len (length file-str))
                 (cand (concat file-str sep line sep page-str sep content)))

            (when (length> content (* frame-width-percent 6)) (setq content (consult-omni--set-string-width content (* frame-width-percent 6))))

            ;; Store file name in order to avoid allocations in `consult--prefix-group'
            (add-text-properties 0 1 `(:source ,source :title ,cand :query ,query :file ,file :pos ,line :page ,page :content ,content) cand)
            (add-text-properties 0 file-str-len `(face consult-file consult--prefix-group ,file) cand)
            (put-text-property (1+ file-str-len) (+ 1 file-str-len line-len) 'face 'consult-line-number cand)
            (when ctx
              (add-face-text-property (+ 2 file-str-len line-len) (length cand) 'consult-grep-context 'append cand))
            (push cand result)))))
    result))

#+end_src
****** transform
#+begin_src emacs-lisp
(defun consult-omni--ripgrep-all-transform (candidates &optional query)
  "Format CANDIDATES for QUERY from `consult-omni-ripgrep-all'."
  (consult-omni--ripgrep-all-format candidates :source "ripgrep-all" :query query :regexp-pattern consult-omni-ripgrep-all-match-regexp))

#+end_src

****** preview
#+begin_src emacs-lisp
(defun consult-omni--ripgrep-all-preview (cand)
  "Preview function for CAND from `consult-omni-ripgrep-all'."
  (let ((file (get-text-property 0 :file cand))
        (pos (get-text-property 0 :pos cand))
        (page (get-text-property 0 :page cand))
        (content (get-text-property 0 :content cand))
        (query (get-text-property 0 :query cand)))
    (with-current-buffer (funcall #'consult--file-action file)
      (cond
       ((string-suffix-p ".pdf" file)
        (pcase major-mode
          ('doc-view-mode
           (and (stringp page) (doc-view-goto-page (string-to-number page))))
          ('pdf-view-mode
           (and (stringp page) (pdf-view-goto-page (string-to-number page)))
           (when consult-omni-highlight-matches-in-file
             (add-to-history 'search-ring (isearch-string-propertize query))
             (when-let ((matches (pdf-isearch-search-page query)))
               (setq pdf-isearch-current-matches matches)
               (setq pdf-isearch-current-match (car-safe matches))
               (pdf-isearch-hl-matches pdf-isearch-current-match pdf-isearch-current-matches t)
               (pdf-isearch-focus-match pdf-isearch-current-match))))
          (_ nil)))
       (t
        (if (buffer-narrowed-p) (widen))
        (and (stringp pos) (forward-line (- (string-to-number pos) (line-number-at-pos))))
        (when (derived-mode-p 'org-mode)
          (org-fold-show-entry))
        (recenter nil t)
        (when consult-omni-highlight-matches-in-file
          (add-to-history 'search-ring (isearch-string-propertize query))
          (consult-omni--overlay-match query nil consult-omni-highlight-match-ignore-case))
        (consult-omni--pulse-line))))
    nil))

#+end_src


***** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--ripgrep-all-builder (input &rest args &key callback &allow-other-keys)
  "Make builder command line args for “ripgrep-all” with INPUT and ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (dir (plist-get opts :dir))
               (dir (if dir (file-truename (format "%s" dir))))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (default-directory (or dir default-directory))
               (consult-ripgrep-args consult-omni-ripgrep-all-args))
    (funcall (consult-omni--grep-make-builder #'consult--ripgrep-make-builder default-directory) query)))

#+end_src

***** define source
#+begin_src emacs-lisp
;; Define the ripgrep-all source
(consult-omni-define-source "ripgrep-all"
                            :narrow-char ?r
                            :type 'async
                            :require-match t
                            :face 'consult-omni-engine-title-face
                            :request #'consult-omni--ripgrep-all-builder
                            :transform #'consult-omni--ripgrep-all-transform
                            :on-preview #'consult-omni--ripgrep-all-preview
                            :on-return #'identity
                            :on-callback #'consult-omni--ripgrep-all-preview
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :group #'consult-omni--group-function
                            :enabled (lambda () (and (executable-find "rga")
                                                     (fboundp 'consult--ripgrep-make-builder)))
                            :sort nil
                            :interactive consult-omni-intereactive-commands-type
                            :annotate nil)

#+end_src

***** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-ripgrep-all' module

(provide 'consult-omni-ripgrep-all)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-ripgrep-all)
;;; consult-omni-ripgrep-all.el ends here
#+end_src



*** consult-notes
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-consult-notes.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-consult-notes.el --- Consulting Consult Notes -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-notes "0.7")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-consult-notes enables using consult-notes in consult-omni.
;; It provides commands to search note files using consult-notes the
;; backend.
;;
;; For more info on consult-notes see:
;; URL `https://github.com/mclear-tools/consult-notes'

;;; Code:

(require 'consult-omni)
(require 'consult-notes nil t)

#+end_src
**** helper functions
***** preview
#+begin_src emacs-lisp
(defun consult-omni--consult-notes-org-roam-note-preview (cand)
  "Preview function for CAND from org-roam files."
  (if cand
      (let* ((title (get-text-property 0 :title cand))
             (node (org-roam-node-from-title-or-alias title)))
        (if (org-roam-node-p node)
            (consult--file-action (org-roam-node-file node))))))

(defun consult-omni--consult-notes-org-headings-preview (cand)
  "Preview function for CAND from org headings."
  (if cand
      (let* ((title (get-text-property 0 :title cand))
             (marker (get-text-property 0 'consult--candidate title)))
        (if marker
            (consult--jump marker)))))

(defun consult-omni--consult-notes-denote-preview (cand)
  "Preview function for CAND from denote file."
  (if (and cand
           (not (consult-notes-denote--excluded-p cand)))
      (let* ((title (get-text-property 0 :title cand))
             (file (format "%s" (get-text-property 0 'denote-path title))))
        (if file
            (consult--file-action file)))))

#+end_src

***** callback
#+begin_src emacs-lisp
(defun consult-omni--consult-notes-org-roam-note-callback (cand &rest _args)
  "Callback function for CAND from org-roam files."
  (let* ((title (get-text-property 0 :title cand))
         (node (org-roam-node-from-title-or-alias title)))
    (org-roam-node-open node)))

(defun consult-omni--consult-notes-org-headings-callback (cand &rest _args)
  "Callback function for CAND from org headings."
  (if cand
      (let* ((title (get-text-property 0 :title cand))
             (marker (get-text-property 0 'consult--candidate title)))
        (if marker
            (let* ((buff (marker-buffer marker))
                   (pos (marker-position marker)))
              (if buff (with-current-buffer buff
                         (if pos (goto-char pos))
                         (funcall consult--buffer-display buff)
                         (recenter nil t))))))))

(defun consult-omni--consult-notes-denote-callback (cand &rest _args)
  "Callback function for CAND from denote files."
  (if (and cand
           (not (consult-notes-denote--excluded-p cand)))
      (let* ((title (get-text-property 0 :title cand))
             (file (format "%s" (get-text-property 0 'denote-path title))))
        (if file
            (consult--file-action file)))))

#+end_src

***** new
#+begin_src emacs-lisp
(defun consult-omni--consult-notes-org-headings-new (cand)
  "Callback function for making “new” org headings from CAND."
  (org-capture-string cand))

(defun consult-omni--consult-notes-org-roam-note-new (cand)
  "Callback function for making “new” org-roam files from CAND."
  (org-roam-node-find nil cand))

(defun consult-omni--consult-notes-denote-new (cand)
  "Callback function for making “new” denote files from CAND."
  (consult-notes-denote--new-note cand))

#+end_src
**** define source
***** consult-notes-org-headings
#+begin_src emacs-lisp
;; make consult-omni sources from consult-notes `consult-notes-org-headings--source'.
(when consult-notes-org-headings-mode
  (consult-omni--make-source-from-consult-source (plist-put consult-notes-org-headings--source :name "Consult Notes Org")
                                                 :category 'file
                                                 :type 'sync
                                                 :require-match nil
                                                 :face 'consult-omni-notes-title-face
                                                 :search-hist 'consult-omni--search-history
                                                 :select-hist 'consult-omni--selection-history
                                                 :on-preview #'consult-omni--consult-notes-org-headings-preview
                                                 :on-return #'identity
                                                 :on-callback #'consult-omni--consult-notes-org-headings-callback
                                                 :on-new #'consult-omni--consult-notes-org-headings-new
                                                 :search-hist 'consult-omni--search-history
                                                 :select-hist 'consult-omni--selection-history
                                                 :preview-key 'consult-omni-preview-key
                                                 :group #'consult-omni--group-function
                                                 :enabled (lambda () (bound-and-true-p consult-notes-org-headings-mode))
                                                 :interactive consult-omni-intereactive-commands-type))

#+end_src

***** consult-notes-org-roam
#+begin_src emacs-lisp
;; make consult-omni sources from consult-notes `consult-notes-org-headings--source'.
(when consult-notes-org-roam-mode
  (cl-loop for source in '(consult-notes-org-roam--refs consult-notes-org-roam--nodes)
           do (let ((name (plist-get (eval source) :name)))
                (plist-put (eval source) :name (concat "Consult Notes " name))
                (consult-omni--make-source-from-consult-source source
                                                               :category 'file
                                                               :type 'sync
                                                               :require-match nil
                                                               :face 'consult-omni-notes-title-face
                                                               :search-hist 'consult-omni--search-history
                                                               :select-hist 'consult-omni--selection-history
                                                               :on-preview #'consult-omni--consult-notes-org-roam-note-preview
                                                               :on-return #'identity
                                                               :on-callback #'consult-omni--consult-notes-org-roam-note-callback
                                                               :on-new #'consult-omni--consult-notes-org-roam-note-new
                                                               :preview-key 'consult-omni-preview-key
                                                               :interactive consult-omni-intereactive-commands-type
                                                               :group #'consult-omni--group-function
                                                               :enabled (lambda () consult-notes-org-roam-mode)
                                                               :annotate nil))))

#+end_src

***** consult-notes-denote
#+begin_src emacs-lisp
;; make consult-omni sources from consult-notes `consult-notes-org-headings--source'.
(when consult-notes-denote-mode
  (consult-omni--make-source-from-consult-source (plist-put consult-notes-denote--source :name "Consult Notes Denote")
                                                 :category 'file
                                                 :type 'sync
                                                 :require-match nil
                                                 :face 'consult-omni-notes-title-face
                                                 :search-hist 'consult-omni--search-history
                                                 :select-hist 'consult-omni--selection-history
                                                 :on-preview #'consult-omni--consult-notes-denote-preview
                                                 :on-return #'identity
                                                 :on-callback #'consult-omni--consult-notes-denote-callback
                                                 :on-new #'consult-omni--consult-notes-denote-new
                                                 :preview-key 'consult-omni-preview-key
                                                 :interactive consult-omni-intereactive-commands-type
                                                 :group #'consult-omni--group-function
                                                 :enabled (lambda () consult-notes-denote-mode)
                                                 :annotate nil))

#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-consult-notes' module

(provide 'consult-omni-consult-notes)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-consult-notes)
;;; consult-omni-consult-notes.el ends here
#+end_src



*** consult-gh
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-gh.el
:END:
**** header

#+begin_src emacs-lisp
;;; consult-omni-gh.el --- Consulting Github Client -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-gh "2.0")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-gh enables using consult-gh in consult-omni.
;; It provides commands to search GitHub repositories using consult-gh as ;; the backend.
;;
;; For more info on consult-gh see:
;; URL `https://github.com/armindarvish/consult-gh'

;;; Code:

(require 'consult-omni)
(require 'consult-gh)

#+end_src
**** helper functions
***** transform/format
#+begin_src emacs-lisp
(defun consult-omni--gh-transform (items &optional query)
  "Transform consult-gh ITEMS for QUERY to consult-omni style."
  (remove nil (mapcar (lambda (string)
                        (consult-gh--repo-format string (or query "") t))
                      items)))

#+end_src
***** preview
#+begin_src emacs-lisp
(defun consult-omni--gh-preview (cand)
  "Preview function for CAND from `consult-omni-github'."
  (when-let ((info (text-properties-at 0 (cdr (get-text-property 0 'multi-category cand))))
             (repo (plist-get info :repo))
             (query (plist-get info :query))
             (match-str (consult--build-args query))
             (buffer (get-buffer-create consult-gh-preview-buffer-name)))
    (add-to-list 'consult-gh--preview-buffers-list buffer)
    (consult-gh--repo-view (format "%s" repo) buffer)
    (with-current-buffer buffer
      (if consult-gh-highlight-matches
          (cond
           ((listp match-str)
            (mapc (lambda (item)
                    (highlight-regexp item 'consult-gh-preview-match-face))
                  match-str))
           ((stringp match-str)
            (highlight-regexp match-str 'consult-gh-preview-match-face)))))
    (funcall (consult--buffer-preview) 'preview
             buffer)))

#+end_src
***** callback
#+begin_src emacs-lisp
(defun consult-omni--gh-callback (cand)
  "Callback function for CAND from `consult-omni-github'."
  (funcall consult-gh-repo-action (cdr (get-text-property 0 'multi-category cand))))

#+end_src
**** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--gh-search-repos-builder (input &rest args &key callback &allow-other-keys)
  "Make builder command line args for “GitHub CLI” with INPUT and ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (if callback (seq-difference args (list :callback callback)) args)))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (cmd (consult--build-args '("gh" "search" "repos")))
               (cmd-opts (list "--limit" (format "%s" count)))
               (`(,re . ,hl) (funcall consult--regexp-compiler query 'basic t)))
    (when re
      (cons (append cmd
                    (list (string-join re " "))
                    cmd-opts)
            hl))))

#+end_src
**** define source
#+begin_src emacs-lisp
;; Define the GitHub source
(consult-omni-define-source "GitHub"
                            :narrow-char ?h
                            :type 'async
                            :require-match nil
                            :category 'consult-gh-repos
                            :face 'consult-omni-engine-title-face
                            :request #'consult-omni--gh-search-repos-builder
                            :on-preview #'consult-omni--gh-preview
                            :on-return #'identity
                            :on-callback #'consult-omni--gh-callback
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :group #'consult-omni--group-function
                            :sort t
                            :interactive consult-omni-intereactive-commands-type
                            :transform #'consult-omni--gh-transform
                            :enabled (lambda () (and (executable-find "gh")
                                                     (fboundp 'consult-gh-search-repos)))
                            :annotate nil)

#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-gh' module

(provide 'consult-omni-gh)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-gh)
;;; consult-omni-gh.el ends here
#+end_src



*** consult-mu
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-mu4e.el
:END:
**** header

#+begin_src emacs-lisp
;;; consult-omni-mu4e.el --- Consulting Mu4e -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-mu "1.0")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-mu4e enables searching emails in consult-omni.
;; It provides commands to search emails using consult-mu as the backend.
;;
;; For more info on consult-mu see:
;; URL `https://github.com/armindarvish/consult-mu'

;;; Code:

(require 'consult-omni)
(require 'consult-mu)

#+end_src
**** helper functions
***** format
#+begin_src emacs-lisp
(defun consult-omni-mu--format-candidate (cand highlight)
  "Format CAND from `consult-omni-mu4e'.

Description of Arguments:

  CAND      a string; candidate from consult-mu
  HIGHLIGHT a boolean; when non-nil highlights the query term in
            the minibuffer"
  (let* ((string (car cand))
         (info (cadr cand))
         (msg (plist-get info :msg))
         (query (plist-get info :query))
         (match-str (if (and (stringp query) (not (equal query ".*"))) (consult--split-escaped (car (consult--command-split query))) nil))
         (headers-template (consult-mu--headers-template))
         (str (if headers-template
                  (consult-mu--expand-headers-template msg headers-template)
                string))
         (str (propertize str :msg msg :query query :type :dynamic :source "mu4e" :title string)))
    (if (and consult-mu-highlight-matches highlight)
        (cond
         ((listp match-str)
          (mapc (lambda (match) (setq str (consult-mu--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-mu--highlight-match match-str str t))))
      str)
    (when msg
      (cons str (list :msg msg :query query :type :dynamic)))))

#+end_src

***** preview
#+begin_src emacs-lisp
(defun consult-omni--mu-preview (cand)
  "Preview function for CAND from `consult-omni-mu4e'."
  (when-let* ((info (text-properties-at 0 (cdr (get-text-property 0 'multi-category cand))))
              (msg (plist-get info :msg))
              (query (plist-get info :query))
              (msgid (substring-no-properties (plist-get msg :message-id)))
              (match-str (car (consult--command-split query)))
              (match-str (car (consult--command-split query)))
              (mu4e-headers-buffer-name consult-mu-headers-buffer-name)
              (buffer consult-mu-view-buffer-name))
    (add-to-list 'consult-mu--view-buffers-list buffer)
    (funcall (consult--buffer-preview) 'preview
             (consult-mu--view msg t consult-mu-mark-previewed-as-read match-str))
    (with-current-buffer consult-mu-view-buffer-name
      (unless (one-window-p) (delete-other-windows)))))

#+end_src
***** return
#+begin_src emacs-lisp
(defun consult-omni--mu-return (cand)
  "Return function for CAND from `consult-omni-mu4e'."
  (save-mark-and-excursion
    (consult-mu--execute-all-marks))
  (setq consult-mu--override-group nil)
  cand)

#+end_src
***** callback
#+begin_src emacs-lisp
(defun consult-omni--mu-callback (cand)
  "Callback function for CAND from `consult-omni-mu4e'."
  (let* ((info (text-properties-at 0 (cdr (get-text-property 0 'multi-category cand))))
         (msg (plist-get info :msg))
         (query (plist-get info :query))
         (match-str (car (consult--command-split query))))
    (consult-mu--view msg nil consult-mu-mark-viewed-as-read match-str)
    (consult-mu-overlays-toggle consult-mu-view-buffer-name)))

#+end_src
**** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--mu-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch results for searching INPUT in “mu4e” with ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (save-window-excursion
    (consult-mu--execute-all-marks)
    (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
                 (opts (car-safe opts))
                 (count (plist-get opts :count))
                 (count (or (and count (integerp (read count)) (string-to-number count))
                            consult-omni-default-count))
                 (mu-input (format "%s -- --maxnum %s" query count))
                 (messages))
      (consult-mu--update-headers mu-input nil nil :dynamic)
      (with-current-buffer consult-mu-headers-buffer-name
        (goto-char (point-min))
        (setq messages (remove nil
                               (cl-loop until (eobp)
                                        collect (let ((msg (ignore-errors (mu4e-message-at-point))))
                                                  (consult-omni-mu--format-candidate `(,(buffer-substring (point) (line-end-position)) (:msg ,(ignore-errors (mu4e-message-at-point)) :query ,input)) t))
                                        do (forward-line 1)))))
      (when (and messages callback)
        (funcall callback messages)))))

#+end_src
**** define source
#+begin_src emacs-lisp
;; Define the Mu4e source
(consult-omni-define-source "mu4e"
                            :narrow-char ?m
                            :type 'dynamic
                            :require-match nil
                            :category 'consult-mu-messages
                            :face 'consult-omni-engine-title-face
                            :request #'consult-omni--mu-fetch-results
                            :lookup #'consult-mu--lookup
                            :on-preview #'consult-omni--mu-preview
                            :on-return #'consult-omni--mu-return
                            :on-callback #'consult-omni--mu-callback
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--email-select-history
                            :enabled (lambda () (and (executable-find "mu")
                                                     (fboundp 'consult-mu)))
                            :group #'consult-omni--group-function
                            :sort t
                            :interactive consult-omni-intereactive-commands-type
                            :annotate nil)

#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-mu4e' module

(provide 'consult-omni-mu4e)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-gh)
;;; consult-omni-mu4e.el ends here
#+end_src



*** Dictionary
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-dict.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-dict.el --- Consulting Dictionary -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (gptel "0.7.0")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-dict enables searching in the dictionary with
;; consult-omni.  It provides commands to search Emacs's built-in
;; dictionary and see the results directly in the minibuffer.

;;; Code:

(require 'dictionary)
(require 'consult-omni)
(ignore-errors (with-temp-buffer (dictionary-mode)))

#+end_src
**** variables
***** custom
#+begin_src emacs-lisp
;;; User Options (a.k.a. Custom Variables)


(defcustom consult-omni-dict-server (or (and (bound-and-true-p dictionary-server) dictionary-server) "dict.org")
  "This server is contacted for searching the dictionary.

For details see `dictionary-server'."
  :group 'consult-omni
  :type '(choice (const :tag "Automatic" nil)
                 (const :tag "localhost" "localhost")
                 (const :tag "dict.org" "dict.org")
                 (string :tag "User-defined")))


(defcustom consult-omni-dict-use-single-buffer (or (and (bound-and-true-p dictionary-use-single-buffer) dictionary-use-single-buffer) t)
  "Should the dictionary command reuse previous dictionary buffers?

See `dictionary-use-single-buffer' for reference"
  :group 'consult-omni
  :type 'boolean)


(defcustom consult-omni-dict-search-interface (or (and (bound-and-true-p dictionary-search-interface) dictionary-search-interface) 'help)
  "How `dictionary-search' prompts for words and displays definitions.

See `dictionary-search-interface' for details."
  :group 'consult-omni
  :type '(choice (const :tag "Dictionary buffer" nil)
                 (const :tag "Help buffer" help)))

(defcustom consult-omni-dict-default-strategy (or (and (bound-and-true-p dictionary-default-strategy) dictionary-default-strategy) ".")
  "The default strategy for listing matching words.

See `dictionary-default-strategy' for details."
  :group 'consult-omni
  :type 'string)

(defcustom consult-omni-dict-short-definition-wordcount 1000
  "Number of words to use in a short definition."
  :group 'consult-omni
  :type 'integer)

(defcustom consult-omni-dict-number-of-lines nil
  "How many lines of definition to show in the minibuffer?

Truncate the definition to this many lines in the minibuffer."
  :group 'consult-omni
  :type '(choice (const :tag "(Default) Do not truncate" nil)
                 (const :tag "Just use the first line" 1)
                 (int :tag "Custom Number of Lines")))

(defcustom consult-omni-dict-external-dictionary-url "https://www.merriam-webster.com/dictionary/%s"
  "Format string for external dictionary website.

This is a string with url and %s as placeholder for the query term."
  :group 'consult-omni
  :type '(choice (const :tag "(Defualt) Meriam Webster" "https://www.merriam-webster.com/dictionary/%s")
                 (const :tag "GNU Collaborative International Dictionary of English" "https://gcide.gnu.org.ua/?q=%s")
                 (const :tag "The American Heritage Dictionary" "https://www.ahdictionary.com/word/search.html?q=%s")
                 (const :tag "Cambridge English Dictionary" "dictionary.cambridge.org/dictionary/english/%s")
                 (const :tag "Oxford English Dictionary" "https://www.oed.com/search/dictionary/?&q=%s")
                 (const :tag "Dictionary.com" "https://www.dictionary.com/browse/%s")))


(defcustom consult-omni-dict-default-predicate-lead "define"
  "The leading string in a query that is intended for the Dictionary.

By default, consult-omni will only search in the Dictionary if this string
is in front of the minibuffer content.  This is used in
`consult-omni-dict-default-pred-func'."
  :group 'consult-omni
  :type '(choice (string :tag "Define" "define")
                 (string :tag "Lookup" "lookup")
                 (string :tag "Dict" "dict")
                 (string :tag "User-defined")))

(defcustom consult-omni-dict-predicate #'consult-omni-dict-default-pred-func
  "Function to use as predicate for dictionary source.

This is called as (funcall consult-omni-dict-predicate query) to
determine if the query should be checked in the dictionary."
  :group 'consult-omni
  :type '(choice (function :tag "(Default) use “define ” prefix" consult-omni-dict-default-pred-func)
                 (function :tag "Custom Function")))

#+end_src

**** helper function
***** format
#+begin_src emacs-lisp
(cl-defun consult-omni--dict-format-candidates (&rest args &key source query dict def buffer pos idx face &allow-other-keys)
  "Return a formatted string for Dictionary candidates with ARGS.

Description of Arguments:

  SOURCE a string; the name to use (e.g. “Dictionary”)
  QUERY  a string; query input from the user
  DICT   a string; name of dictionary for current item
  DEF    a string; definition of current item
  BUFFER a buffer; the current buffer for dictionary
  POS    an integer; position of definition in BUFFER
  IDX    an integer; index of definition in current definitions
  FACE   a symbol; the face to apply to DEFINITION"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (if (stringp source) (propertize source 'face 'consult-omni-source-type-face)))
         (match-str (and (stringp query) (not (equal query ".*")) (consult--split-escaped query)))
         (dict (and (stringp dict) (propertize dict 'face 'consult-omni-date-face)))
         (search-url (format consult-omni-dict-external-dictionary-url (url-hexify-string query)))
         (face (or (consult-omni--get-source-prop source :face) face 'consult-omni-default-face))
         (answer (and (stringp def) (if (length> def consult-omni-dict-short-definition-wordcount) (substring def 0 consult-omni-dict-short-definition-wordcount) def)))
         (items (and (stringp answer) (split-string answer "\n")))
         (items (and items (if (integerp consult-omni-dict-number-of-lines) (seq-take items consult-omni-dict-number-of-lines) items)))
         (first-item t))
    (mapcar (lambda (item)
              (if-let ((str (propertize item 'face face)))
                  (progn
                    (if consult-omni-highlight-matches-in-minibuffer
                        (cond
                         ((listp match-str)
                          (mapc (lambda (match)
                                  (setq str (consult-omni--highlight-match match str t)))
                                match-str))
                         ((stringp match-str)
                          (setq str (consult-omni--highlight-match match-str str t)))))
                    (setq str (if first-item
                                  (concat dict "\t" str)
                                (concat (make-string (length dict) ?\s) "\t" str)))
                    (setq first-item nil)
                    (propertize str
                                :source source
                                :query query
                                :title def
                                :dict dict
                                :url nil
                                :search-url search-url
                                :buffer buffer
                                :pos pos))))
            items)))

#+end_src
***** predicate
#+begin_src emacs-lisp
(defun consult-omni-dict-default-pred-func (query)
  "Check if a QUERY is intended for `consult-omni-dictionary'.

Tests if the QUERY string starts with
`consult-omni-dict-default-predicate-lead' and if so, returns a new query
without the predicate lead."
  (cond
   ((string-prefix-p (concat consult-omni-dict-default-predicate-lead " ") query)
    (string-remove-prefix (concat consult-omni-dict-default-predicate-lead " ") query))
   (t nil)))

#+end_src
***** preview
#+begin_src emacs-lisp
(defun consult-omni--dict-preview (cand)
  "Show a preview buffer of CAND for `consult-omni-dict'."
  (if (listp cand) (setq cand (or (car-safe cand) cand)))
  (let*  ((query (get-text-property 0 :query cand))
          (buffer (get-text-property 0 :buffer cand))
          (pos (get-text-property 0 :pos cand)))
    (when buffer
      (with-current-buffer buffer (when pos (goto-char pos))))
    (funcall (consult--buffer-preview) 'preview
             buffer)
    (save-excursion
      (with-selected-window (get-buffer-window buffer)
        (recenter 1 t)))
    (consult-omni--pulse-line 0.15)))

#+end_src
***** return
#+begin_src emacs-lisp
(defun consult-omni--dict-return (cand)
  "Return definition string of CAND for `consult-omni-dict'."
  (if-let  ((def (get-text-property 0 :title cand)))
      def
    cand))

#+end_src
***** new
#+begin_src emacs-lisp
(defun consult-omni--dict-new (cand)
  "Callback function for “new” CAND in `consult-omni-dict'.

“new” CAND, here means a term that is not found in the Dictionary.  In
this case CAND is searched in a browser using
`consult-omni-dict-external-dictionary-url' as the online dictionary."
  (let ((url (format consult-omni-dict-external-dictionary-url (url-hexify-string cand))))
    (funcall consult-omni-default-browse-function url)))

#+end_src
**** fetching items/results
***** get suggestions
#+begin_src emacs-lisp
(defun consult-omni-dict-word-suggestions-maybe (query buffer &optional maxcount)
  "Get list of word suggestions for QUERY up to MAXCOUNT from Dictionary.

BUFFER is the buffer for the Emacs dictionary."
  (goto-char (point-min))
  (let ((source "Dictionary")
        (annotated-results)
        (idx 0))
    (while (re-search-forward "Matches from \\(?1:.*?\\):\n\\(?2:[[:ascii:][:nonascii:]]*?\\)\n\n" nil t)
      (when-let* ((dict (match-string 1))
                  (def (match-string 2))
                  (line (+ (match-end 1) 2)))
        (when (or (not maxcount) (and maxcount (< idx maxcount))) (setq annotated-results (append annotated-results (consult-omni--dict-format-candidates :source source :query query :dict dict :def def :pos line :buffer buffer :idx idx))))
        (cl-incf idx)))
    annotated-results))

#+end_src
***** search query
#+begin_src emacs-lisp
(defun consult-omni--dict-search-query (query &optional maxcount)
  "Find definitions for QUERY using `dictionary'.

if MAXCOUNT is non-nil, only find top MAXCOUNT number of definitions."
  (let* ((dictionary-server consult-omni-dict-server)
         (dictionary-search-interface consult-omni-dict-search-interface)
         (dictionary-use-single-buffer consult-omni-dict-use-single-buffer)
         (buffer (save-mark-and-excursion (dictionary) (current-buffer)))
         (annotated-results))
    (when (and buffer (buffer-live-p buffer))
      (with-current-buffer buffer
        (condition-case err
            (progn
              (setq-local dictionary-default-strategy consult-omni-dict-default-strategy)
              (setq-local dictionary-server consult-omni-dict-server)
              (dictionary-new-search-internal query "*"
                                              (lambda (result)
                                                (let ((inhibit-read-only t)
                                                      (source "Dictionary")
                                                      (idx 0)
                                                      (reply (if result (dictionary-read-reply-and-split))))
                                                  (when reply
                                                    (while (dictionary-check-reply reply 151)
                                                      (let* ((reply-list (dictionary-reply-list reply))
                                                             (dictionary (nth 2 reply-list))
	                                                     (description (nth 3 reply-list))
	                                                     (word (nth 1 reply-list))
                                                             (def)
                                                             (dict)
                                                             (line))
                                                        (dictionary-display-word-entry dictionary description)
	                                                (setq reply (dictionary-read-answer))
	                                                (setq def (dictionary-decode-charset reply dictionary))
                                                        (setq line (point))
                                                        (dictionary-display-word-definition reply word dictionary)

                                                        (setq reply (dictionary-read-reply-and-split))
                                                        (when (or (not maxcount) (and maxcount (< idx maxcount))) (setq annotated-results (append annotated-results (consult-omni--dict-format-candidates :source source :query query :dict dictionary :def def :pos line :buffer buffer :idx idx) )))
                                                        (cl-incf idx)))
                                                    (when (> idx 0) (dictionary-post-buffer))))))
              (consult-omni--overlay-match query nil consult-omni-highlight-match-ignore-case)
              (unless annotated-results
                (setq annotated-results (consult-omni-dict-word-suggestions-maybe query buffer maxcount))))
          (user-error
           (progn
             (message (format "Dictionary: %s" (error-message-string err)))
             (unless annotated-results
               (setq annotated-results (consult-omni-dict-word-suggestions-maybe query buffer maxcount)))))
          (error (message (if consult-omni-log-level
                              (format "Dictionary: %s" (error-message-string err))))))
        (quit-window)))
    annotated-results))

#+end_src
***** fetch items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--dict-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch word definitions for INPUT from `dictionary' with ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (query (if (and consult-omni-dict-predicate (stringp query)) (funcall consult-omni-dict-predicate query)
                        query))
               (query (if (stringp query) (unless (string-empty-p (string-trim query)) (string-trim-left query)) nil))
               (annotated-results (and query (not (string-empty-p query)) (consult-omni--dict-search-query query (if count count)))))
    (when (and annotated-results (functionp callback))
      (funcall callback (nreverse annotated-results))
      annotated-results)))

#+end_src
**** define source
#+begin_src emacs-lisp
;; Define the Dictionary source
(consult-omni-define-source "Dictionary"
                            :narrow-char ?D
                            :category 'consult-omni-dictionary
                            :type 'dynamic
                            :require-match nil
                            :face 'consult-omni-snippet-face
                            :request #'consult-omni--dict-fetch-results
                            :on-preview #'consult-omni--dict-preview
                            :on-return #'consult-omni--dict-return
                            :on-callback #'consult-omni--dict-preview
                            :on-new #'consult-omni--dict-new
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :enabled (lambda () (fboundp 'dictionary))
                            :group #'consult-omni--group-function
                            :sort nil
                            :interactive consult-omni-intereactive-commands-type
                            :annotate nil)

#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-dict' module

(provide 'consult-omni-dict)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-dict)
;;; consult-omni-dict.el ends here
#+end_src


*** Doi.org
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-doi.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-doi.el --- Consulting DOI.org -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-doi enables looking up DOIs in consult-omni.
;; It provides commands to search DOIs using DOI.org as the backend.
;;
;; For more info DOI see:
;; URL `https://www.doi.org/'

;;; Code:

(require 'consult-omni)

#+end_src
**** variables
***** others
#+begin_src emacs-lisp
(defvar consult-omni-doiorg-api-url "https://doi.org/api/handles/"
  "API URL for “DOI.org”.")

(defvar consult-omni-doiorg-search-url "https://doi.org/"
  "Search URL for “DOI.org”.")

#+end_src
***** history variables
#+begin_src emacs-lisp
(defvar consult-omni--doi-search-history (list)
  "History variables for search terms of `consult-omni-doi'.")

(defvar consult-omni--doi-selection-history (list)
  "History variables for selected items of `consult-omni-doi'.")

#+end_src
**** helper functions
***** doi to url
#+begin_src emacs-lisp
(defun consult-omni--doi-to-url (doi)
  "Convert DOI value to target url."
  (let ((out))
    (let* ((doi (if doi (format "%s" doi)))
           (url (concat consult-omni-doiorg-api-url doi)))
      (consult-omni--fetch-url url consult-omni-http-retrieve-backend
                               :sync t
                               :encoding 'utf-8
                               :parser #'consult-omni--json-parse-buffer
                               :callback
                               (lambda (attrs)
                                 (let* ((raw-results (map-nested-elt attrs '("values")))
                                        (result (car-safe (remove nil
                                                                  (mapcar
                                                                   (lambda (item)
                                                                     (if-let* ((type (gethash "type" item))
                                                                               (link (if (equal type "URL") (map-nested-elt item '("data" "value")))))
                                                                         link))
                                                                   raw-results)))))
                                   result))))))
#+end_src
**** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--doiorg-fetch-results (doi &rest args &key callback &allow-other-keys)
  "Fetch target url of DOI with ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command doi (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (source "doiorg")
               (url (consult-omni--doi-to-url query))
               (title (if url (format "%s" url) (format "%s - Not Found" query)))
               (search-url (concat consult-omni-doiorg-search-url query))
               (decorated (funcall consult-omni-default-format-candidate :source source :query query :url url :search-url search-url :title title))
               (annotated-results (propertize decorated
                                              :source source
                                              :title title
                                              :url url
                                              :search-url search-url
                                              :query query)))
    (when url
      (list annotated-results))))

#+end_src
**** define source
#+begin_src emacs-lisp
;; Define the doiorg (for DOI.org) source
(consult-omni-define-source "doiorg"
                            :narrow-char ?D
                            :type 'sync
                            :require-match t
                            :face 'link
                            :request #'consult-omni--doiorg-fetch-results
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--doi-search-history
                            :select-hist 'consult-omni--doi-selection-history
                            :enabled (lambda () (bound-and-true-p consult-omni-doiorg-search-url))
                            :group #'consult-omni--group-function
                            :sort t
                            :interactive consult-omni-intereactive-commands-type)

#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-doi' module

(provide 'consult-omni-doi)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-doi)
;;; consult-omni-doi.el ends here
#+end_src


*** DuckDuckGo
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-duckduckgo.el
:END:
**** header

#+begin_src emacs-lisp
;;; consult-omni-duckduckgo.el --- Consulting DuckDuckGo -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-duckduckgo provides commands for searching DuckDuckGo's
;; “limited” API in Emacs using consult-omni.

;;; Code:

(require 'consult-omni)

#+end_src
**** variables
***** other
#+begin_src emacs-lisp
(defvar consult-omni-duckduckgo-api-url "http://api.duckduckgo.com/"
  "API URL for DuckDuckGo.")

(defvar consult-omni-duckduckgo-search-url "https://duckduckgo.com/"
  "Search URL for DuckDuckGo.")

#+end_src
**** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--duckduckgoapi-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch search results for INPUT from DuckDuckGo limited API with ARGS.

See URL `https://duckduckgo.com/duckduckgo-help-pages/settings/params/'
for some limited documentation.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (extra-args (seq-difference (append opts args) '(:count count :page page)))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (page (or (and page (integerp (read page)) (string-to-number page))
                         consult-omni-default-page))
               (count (min count 10))
               (page (+ (* page count) 1))
               (params `(("q" . ,(replace-regexp-in-string " " "+" query))
                         ("format" . "json")))
               (headers `(("Accept" . "application/json"))))
    (consult-omni--fetch-url consult-omni-duckduckgo-api-url consult-omni-http-retrieve-backend
                             :encoding 'utf-8
                             :params params
                             :headers headers
                             :parser #'consult-omni--json-parse-buffer
                             :callback
                             (lambda (attrs)
                               (let* ((raw-results (gethash "RelatedTopics" attrs))
                                      (annotated-results
                                       (remove nil (mapcar (lambda (item)
                                                             (let*
                                                                 ((source "DuckDuckGo API")
                                                                  (url (gethash "FirstURL" item))
                                                                  (title (gethash "Result" item))
                                                                  (title (if (and title (stringp title) (string-match "<a href=.*>\\(?1:.*\\)</a>.*" title)) (match-string 1 title) nil))
                                                                  (snippet (format "%s" (gethash "Text" item)))
                                                                  (search-url (consult-omni--make-url-string consult-omni-duckduckgo-search-url params '("format")))
                                                                  (decorated (if title (funcall consult-omni-default-format-candidate :source source :query query :url url :search-url search-url :title title :snippet snippet) nil)))
                                                               (if decorated (propertize decorated
                                                                                         :source source
                                                                                         :title title
                                                                                         :url url
                                                                                         :search-url search-url
                                                                                         :query query
                                                                                         ))))
                                                           raw-results))))
                                 (when (and annotated-results (functionp callback))
                                   (funcall callback annotated-results))
                                 annotated-results)))))

#+end_src
**** define source
#+begin_src emacs-lisp
;; Define the DuckDuckGo API source
(consult-omni-define-source "DuckDuckGo API"
                            :narrow-char ?d
                            :type 'dynamic
                            :require-match nil
                            :face 'consult-omni-engine-title-face
                            :request #'consult-omni--duckduckgoapi-fetch-results
                            :on-new (apply-partially #'consult-omni-external-search-with-engine "DuckDuckGo")
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :enabled (lambda () (bound-and-true-p consult-omni-duckduckgo-search-url))
                            :group #'consult-omni--group-function
                            :sort t
                            :interactive consult-omni-intereactive-commands-type
                            :annotate nil)

#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-duckduckgo' module

(provide 'consult-omni-duckduckgo)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-duckduckgo)
;;; consult-omni-duckduckgo.el ends here
#+end_src


*** elfeed
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-elfeed.el
:END:
**** header

#+begin_src emacs-lisp
;;; consult-omni-elfeed.el --- Consulting Elfeed -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (elfeed "3.4.1")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni/blob/main/consult-omni-sources
;; Keywords: convenience

;;; Commentary:
;; consult-omni-elfeed enables searching Elfeed's feeds in consult-omni.
;; It provides commands to search feeds and getting the results
;; directly in the minibuffer.
;;
;; For more info on Elfeed see:
;; URL `https://github.com/skeeto/elfeed'

;;; Code:

(require 'elfeed)
(require 'consult-omni)

#+end_src

**** variables
***** custom
#+begin_src emacs-lisp
;;; User Options (a.k.a. Custom Variables)

(defcustom consult-omni-elfeed-search-buffer-name "*consult-omni-elfeed-search*"
  "Name for `consult-omni-elfeed-search' buffer."
  :group 'consult-omni
  :type 'string)

(defcustom consult-omni-elfeed-default-filter nil
  "Default Filter for `consult-omni-elfeed-search'."
  :group 'consult-omni
  :type 'string)

#+end_src
**** helper functions
***** format
#+begin_src emacs-lisp
(defun consult-omni--elfeed-format-candidate (entries query)
  "Format the ENTRIES for QUERY from `consult-omni-elfeed'.

Description of Arguments:

  ENTRIES a list; list of entries from `consult-omni--elfeed-fetch-result'.
  QUERY   a string; the query input from the user"
  (let ((annotated-entries))
    (dolist (entry entries annotated-entries)
      (let* ((url (elfeed-entry-link entry))
             (urlobj (if url (url-generic-parse-url url)))
             (domain (if (url-p urlobj) (url-domain urlobj)))
             (domain (if (stringp domain) (propertize domain 'face 'consult-omni-domain-face)))
             (path (if (url-p urlobj) (url-filename urlobj)))
             (path (if (stringp path) (propertize path 'face 'consult-omni-path-face)))
             (title (or (elfeed-entry-title entry) ""))
             (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
             (feed (elfeed-entry-feed entry))
             (feed-title (when feed (elfeed-feed-title feed)))
             (date (format-time-string "%Y-%m-%d %H:%M" (elfeed-entry-date entry)))
             (id (elfeed-entry-id entry))
             (tags (mapcar #'symbol-name (elfeed-entry-tags entry)))
             (tags-str (mapconcat
                        (lambda (s) (propertize s 'face 'elfeed-search-tag-face))
                        tags ","))
             (title-width (- (floor (* (frame-width) 0.7)) elfeed-search-trailing-width))
             (title-column (elfeed-format-column
                            title (elfeed-clamp
                                   elfeed-search-title-min-width
                                   title-width
                                   elfeed-search-title-max-width)
                            :left))
             (match-str (if (and (stringp query) (not (equal query ".*"))) (consult--split-escaped (car (consult--command-split query))) nil))
             (str (concat (propertize title-column 'face title-faces 'kbd-help title) " "
                          (propertize date 'face 'elfeed-search-date-face)
                          (when feed-title
                            (concat " " (propertize feed-title 'face 'elfeed-search-feed-face)))
                          (when tags (concat " " "(" tags-str ")"))
                          (when domain (concat "\t" domain (when path path)))
                          (concat "\t" (propertize "elfeed" 'face 'consult-omni-source-type-face)))))
        (if consult-omni-highlight-matches-in-minibuffer
            (cond
             ((listp match-str)
              (mapc (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
             ((stringp match-str)
              (setq str (consult-omni--highlight-match match-str str t)))))
        (push (propertize str
                          :source "elfeed"
                          :title title
                          :url url
                          :search-url nil
                          :query query
                          :entry entry
                          :tags tags
                          :date date
                          :id id
                          :feed feed)
              annotated-entries)))))

#+end_src
***** make dedicated search buffer
#+begin_src emacs-lisp
(defun consult-omni--elfeed-search-buffer ()
  "Get or create buffer for `consult-omni-elfeed'."
  (get-buffer-create (or consult-omni-elfeed-search-buffer-name "*consult-omni-elfeed-search*")))

#+end_src
***** preview
#+begin_src emacs-lisp
(defun consult-omni--elfeed-preview (cand)
  "Preview function for CAND from `consult-omni-elfeed'.

Uses `elfeed-show-entry'."
  (if (listp cand) (setq cand (or (car-safe cand) cand)))
  (let* ((entry (get-text-property 0 :entry cand))
         (buff (get-buffer-create (elfeed-show--buffer-name entry))))
    (with-current-buffer buff
      (elfeed-show-mode)
      (setq elfeed-show-entry entry)
      (elfeed-show-refresh))
    (funcall (consult--buffer-preview) 'preview
             buff)))

#+end_src
**** fetching items/results

#+begin_src emacs-lisp
(cl-defun consult-omni--elfeed-fetch-results (input &rest args &key callback &allow-other-keys)
  "Return entries matching INPUT in elfeed database with ARGS.

Use INPUT as filter to find entries in elfeed database.  If
`consult-omni-elfeed-default-filter' is non-nil, it is used as additional
filter parameters.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (cl-letf* (((symbol-function #'elfeed-search-buffer) #'consult-omni--elfeed-search-buffer))
    (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
                 (opts (car-safe opts))
                 (maxcount (plist-get opts :count))
                 (filter (and (plist-member opts :filter) (plist-get opts :filter)))
                 (maxcount (or (and (integerp maxcount) maxcount)
                               (and maxcount (string-to-number (format "%s" maxcount)))
                               consult-omni-default-count))
                 (elfeed-search-filter (concat (if maxcount (format "#%d " maxcount))
                                               (if filter (format "%s" filter)
                                                 consult-omni-elfeed-default-filter)
                                               (if query (format "%s" query))))
                 (filter (elfeed-search-parse-filter elfeed-search-filter))
                 (head (list nil))
                 (tail head)
                 (count 0)
                 (lexical-binding t)
                 (search-func (byte-compile (elfeed-search-compile-filter filter))))
      (with-elfeed-db-visit (entry feed)
        (when (funcall search-func entry feed count)
          (setf (cdr tail) (list entry)
                tail (cdr tail)
                count (1+ count))))
      (when-let ((entries (cdr head)))
        (consult-omni--elfeed-format-candidate entries query)))))

#+end_src
**** define source
#+begin_src emacs-lisp
;; Define the elfeed source
(consult-omni-define-source "elfeed"
                            :narrow-char ?e
                            :type 'sync
                            :require-match t
                            :face 'elfeed-search-unread-title-face
                            :request #'consult-omni--elfeed-fetch-results
                            :on-preview #'consult-omni--elfeed-preview
                            :on-return #'identity
                            :on-callback #'consult-omni--elfeed-preview
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :enabled (lambda () (boundp 'elfeed-db))
                            :group #'consult-omni--group-function
                            :sort t
                            :interactive consult-omni-intereactive-commands-type
                            :annotate nil)

#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-elfeed' module

(provide 'consult-omni-elfeed)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-elfeed)
;;; consult-omni-elfeed.el ends here
#+end_src

*** Google
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-google.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-google.el --- Consulting Google -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-google provides commands for searching Goggle in Emacs
;; using consult-omni.

;;; Code:

(require 'consult-omni)

#+end_src
**** variables
***** custom
#+begin_src emacs-lisp
(defcustom consult-omni-google-customsearch-key nil
  "Key for Google custom search API.

Can be a key string or a function that returns a key string.

Refer to URL `https://developers.google.com/custom-search/' and
URL `https://developers.google.com/custom-search/v1/introduction' for
getting an API key."
  :group 'consult-omni
  :type '(choice (string :tag "API Key")
                 (function :tag "Custom Function")))

(defcustom consult-omni-google-customsearch-cx nil
  "CX for Google custom search API.

Can be a key string or a function that returns a key string.

See URL `https://developers.google.com/custom-search/' and
URL `https://developers.google.com/custom-search/v1/introduction' for getting a custom search CX number."
  :group 'consult-omni
  :type '(choice (string :tag "CX String")
                 (function :tag "Custom Function")))

#+end_src
***** other
#+begin_src emacs-lisp
(defvar consult-omni-google-search-url "https://www.google.com/search"
  "Search URL for Google.")

(defvar consult-omni-google-customsearch-api-url "https://www.googleapis.com/customsearch/v1"
  "API URL for “Google Custom Search”.")

#+end_src
**** fetching items/results

#+begin_src emacs-lisp
(cl-defun consult-omni--google-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch search results from “Google Custom Search” for INPUT with ARGS.

Refer to URL `https://programmablesearchengine.google.com/about/' and
URL `https://developers.google.com/custom-search/' for more info on
“Google Custom Search”.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (filter (plist-get opts :filter))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (page (or (and page (integerp (read page)) (string-to-number page))
                         consult-omni-default-page))
               (filter (or (and (integerp filter) filter)
                           (and filter (string-to-number (format "%s" filter)))
                           1))
               (filter (if (member filter '(0 1)) filter 1))
               (count (min count 10))
               (page (+ (* page count) 1))
               (page (min page (- 100 count)))
               (params `(("q" . ,(replace-regexp-in-string " " "+" query))
                         ("key" . ,(consult-omni-expand-variable-function consult-omni-google-customsearch-key))
                         ("cx" . ,(consult-omni-expand-variable-function consult-omni-google-customsearch-cx))
                         ("gl" . "en")
                         ("filter" . ,(format "%s" filter))
                         ("num" . ,(format "%s" count))
                         ("start" . ,(format "%s" page))))
               (headers '(("Accept" . "application/json")
                          ("Accept-Encoding" . "gzip")
                          ("User-Agent" . "consult-omni (gzip)"))))
    (consult-omni--fetch-url consult-omni-google-customsearch-api-url consult-omni-http-retrieve-backend
                             :encoding 'utf-8
                             :params params
                             :headers headers
                             :parser #'consult-omni--json-parse-buffer
                             :callback
                             (lambda (attrs)
                               (let* ((raw-results (gethash "items" attrs))
                                      (annotated-results
                                       (mapcar (lambda (item)
                                                 (let*
                                                     ((source "Google")
                                                      (url (format "%s" (gethash "link" item)))
                                                      (title (format "%s" (gethash "title" item)))
                                                      (snippet (string-trim (format "%s" (gethash "snippet" item))))
                                                      (search-url (consult-omni--make-url-string consult-omni-google-search-url params '("key" "cx" "gl")))
                                                      (decorated (funcall consult-omni-default-format-candidate :source source :query query :url url :search-url search-url :title title :snippet snippet)))
                                                   (propertize decorated
                                                               :source source
                                                               :title title
                                                               :url url
                                                               :search-url search-url
                                                               :query query
                                                               :snippet snippet)))
                                               raw-results)))
                                 (when (and annotated-results (functionp callback))
                                   (funcall callback annotated-results))
                                 annotated-results)))))

#+end_src
**** define source
#+begin_src emacs-lisp
;; Define the Google source
(consult-omni-define-source "Google"
                            :narrow-char ?g
                            :type 'dynamic
                            :require-match nil
                            :face 'consult-omni-engine-title-face
                            :request #'consult-omni--google-fetch-results
                            :on-new (apply-partially #'consult-omni-external-search-with-engine "Google")
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :enabled (lambda () (bound-and-true-p consult-omni-google-customsearch-key))
                            :group #'consult-omni--group-function
                            :sort t
                            :interactive consult-omni-intereactive-commands-type
                            :annotate nil)

#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-google' module

(provide 'consult-omni-google)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-google)
;;; consult-omni-google.el ends here
#+end_src


*** Google Autosuggest
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-google-autosuggest.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-google-autosuggest.el --- Consulting Google Autosuggest -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-google-autosuggest provides commands for getting
;; autosuggestion from Google in Emacs using consult-omni.

;;; Code:

(require 'consult-omni)

#+end_src
**** variables
#+begin_src emacs-lisp
(defvar consult-omni-google-autosuggest-api-url "http://suggestqueries.google.com/complete/search"
  "API URL for Google AutoSuggest.")

#+end_src
**** helper functions
***** new
#+begin_src emacs-lisp
(defun consult-omni--google-autosuggest-new (cand)
  "Return CAND for NEW non-existing candidates."
  (when (listp cand) (setq cand (car-safe cand)))
  (or (and (stringp cand) (string-trim cand (consult--async-split-initial nil)))
      cand))

#+end_src
**** fetching items/results

#+begin_src emacs-lisp
(cl-defun consult-omni--google-autosuggest-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch search results from Google Autosuggest for INPUT with ARGS.

Uses `consult-omni-google-autosuggest-api-url' as autosuggest api url.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (page (or (and (integerp page) page)
                         (and page (string-to-number (format "%s" page)))
                         consult-omni-default-count))
               (params `(("q" . ,query)
                         ("client" . "chrome")))
               (headers '(("Accept" . "application/json"))))
    (consult-omni--fetch-url consult-omni-google-autosuggest-api-url consult-omni-http-retrieve-backend
                             :encoding 'utf-8
                             :params params
                             :headers headers
                             :parser #'consult-omni--json-parse-buffer
                             :callback
                             (lambda (attrs)
                               (when-let* ((raw-results (append (list (car-safe attrs)) (car-safe (cdr-safe attrs))))
                                           (annotated-results
                                            (mapcar (lambda (item)
                                                      (let* ((source "Google AutoSuggest")
                                                             (word item)
                                                             (url                                  (concat "https://www.google.com/search?q="  (replace-regexp-in-string " " "+" word)))
                                                             (urlobj (and url (url-generic-parse-url url)))
                                                             (domain (and (url-p urlobj) (url-domain urlobj)))
                                                             (domain (and (stringp domain)
                                                                          (propertize domain 'face 'font-lock-variable-name-face)))
                                                             (path (and (url-p urlobj) (url-filename urlobj)))
                                                             (path (and (stringp path)
                                                                        (propertize path 'face 'font-lock-warning-face)))
                                                             (search-url nil)
                                                             (decorated (propertize word 'face 'consult-omni-default-face)))
                                                        (propertize decorated
                                                                    :source source
                                                                    :title word
                                                                    :url url
                                                                    :search-url search-url
                                                                    :query query)))
                                                    raw-results)))
                                 (funcall callback annotated-results)
                                 annotated-results)))))

#+end_src

**** define source
#+begin_src emacs-lisp
;; Define the Google AutoSuggest source
(consult-omni-define-source "Google AutoSuggest"
                            :narrow-char ?G
                            :type 'dynamic
                            :require-match nil
                            :face 'consult-omni-engine-title-face
                            :request #'consult-omni--google-autosuggest-fetch-results
                            :on-preview #'ignore
                            :on-return #'identity
                            :on-callback #'string-trim
                            :on-new #'consult-omni--google-autosuggest-new
                            :search-hist 'consult-omni--search-history
                            :select-hist t
                            :group #'consult-omni--group-function
                            :enabled (lambda () (bound-and-true-p consult-omni-google-autosuggest-api-url))
                            :sort t
                            :interactive consult-omni-intereactive-commands-type)

#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-google-autosuggest' module

(provide 'consult-omni-google-autosuggest)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-google-autosuggest)
;;; consult-omni-google-autosuggest.el ends here
#+end_src


*** gptel
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-gptel.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-gptel.el --- Consulting gptel -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (gptel "0.7.0")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-gptel enables searching LLMS in consult-omni using gptel.
;; It provides commands to get gptel results directly in the minibuffer.
;;
;; For more info on gptel see:
;; URL `https://github.com/karthink/gptel'

;;; Code:

(require 'gptel)
(require 'consult-omni)

#+end_src
**** variables
***** custom
#+begin_src emacs-lisp
;;; User Options (a.k.a. Custom Variables)

(defcustom consult-omni-gptel-backend (or gptel-backend gptel--openai)
  "LLM backend to use in consult-omni-gptel.

By default inherits from `gptel-backend'.
See `gptel-backend' for more info."
  :group 'consult-omni
  :type `(choice
          (const :tag "ChatGPT" ,gptel--openai)
          (restricted-sexp :match-alternatives (gptel-backend-p 'nil)
                           :tag "Other backend")))

(defcustom consult-omni-gptel-model (or gptel-model "gpt-3.5-turbo")
  "GPT Model for use in consult-omni-gptel.

By default inherits from `gptel-model'.
See `gptel-model' for more info."
  :group 'consult-omni
  :type '(choice
          (string :tag "Specify model name")
          (const :tag "GPT 3.5 turbo" "gpt-3.5-turbo")
          (const :tag "GPT 3.5 turbo 16k" "gpt-3.5-turbo-16k")
          (const :tag "GPT 4" "gpt-4")
          (const :tag "GPT 4 turbo (preview)" "gpt-4-turbo-preview")
          (const :tag "GPT 4 32k" "gpt-4-32k")
          (const :tag "GPT 4 1106 (preview)" "gpt-4-1106-preview")))

(defcustom consult-omni-gptel-buffer-name  "*consult-omni-gptel*"
  "Name for consult-omni-gptel buffer."
  :group 'consult-omni
  :type '(choice (string :tag "A string for buffer name")
                 (function :tag "A custom function taking prompt (and other args) as input and returning buffer name string")))

(defcustom consult-omni-gptel-cand-title #'consult-omni--gptel-make-title-short-answer
  "What to show as the title in in the minibuffer?"
  :group 'consult-omni
  :type '(choice (function :tag "(Default) Get a quick short answer (Sends the prompt to LLM) and shows a short response.)" #'consult-omni--gptel-make-title-short-answer)
                 (function :tag "Placeholder string with prompt (Does not send prompt to LLM until the candidate is selected.)" #'consult-omni--gptel-make-title-placeholder)
                 (function :tag "A custom function taking input (and other args) as input and returning a string")
                 (string :tag "A custom fixed string")))

(defcustom consult-omni-gptel-short-answer-wordcount 10
  "Number of words to use in a short answer."
  :group 'consult-omni
  :type 'integer)

#+end_src

**** helper function
***** format
#+begin_src emacs-lisp
(cl-defun consult-omni--gptel-format-candidate (&rest args &key source query title model backend stream face &allow-other-keys)
  "Return a formatted string for gptel's candidates with ARGS.

Description of Arguments:

  SOURCE   the name to use (e.g. “gptel”)
  QUERY    query input from the user
           the search results of QUERY on the SOURCE website
  TITLE    the string of the candidate.
  MODEL    the model to use for gptel.  See `gptel-mode' for details.
  BACKEND  the backend to use for gptel.  See `gptel-backend' for details.
  STREAM   boolean to determine whether to use strem or not.
           see`gptel-stream' for details.
  FACE     the face to apply to TITLE"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (and (stringp source) (propertize source 'face 'consult-omni-source-type-face)))
         (match-str (and (stringp query) (not (equal query ".*")) (consult--split-escaped query)))
         (backend (and (stringp backend) (propertize backend 'face 'consult-omni-domain-face)))
         (model (and (stringp model) (propertize model 'face 'consult-omni-path-face)))
         (stream (and stream (propertize "~stream~" 'face 'consult-omni-snippet-face)))
         (face (or (consult-omni--get-source-prop source :face) face 'consult-omni-default-face))
         (title-str (and title (stringp title) (propertize title 'face face)))
         (title-str (consult-omni--set-string-width title-str (* 5 frame-width-percent)))
         (str (concat title-str
                      (when backend (concat "\t" backend))
                      (when model (concat ":" model))
                      (when stream (concat "\s" stream "\s")))))
    (if consult-omni-highlight-matches-in-minibuffer
        (cond
         ((listp match-str)
          (mapc (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-omni--highlight-match match-str str t)))))
    str))

#+end_src

***** gptel buffer name
#+begin_src emacs-lisp
(defun consult-omni--gptel-buffer-name (&optional query &rest args)
  "Return a string for `consult-omni-gptel' buffer name with QUERY and ARGS.

QUERY is a string, the prompt to send to gptel."
  (cond
   ((functionp consult-omni-gptel-buffer-name)
    (funcall consult-omni-gptel-buffer-name query args))
   ((stringp consult-omni-gptel-buffer-name)
    consult-omni-gptel-buffer-name)
   (t "*consult-omni-gptel*")))

#+end_src
***** preview
#+begin_src emacs-lisp
(cl-defun consult-omni--gptel-response-preview (query &rest args &key backend model stream &allow-other-keys)
  "Return a `gptel' buffer for QUERY and ARGS.

Description of Arguments:
  QUERY  a string; the prompt that is sent to gptel
  BACKEND a symbol; the backend used for gptel (see `gptel-backend')
  MODEL  a string; the model to use for gptel (see `gptel-model')
  STREAM a boolean; when non-nil, the response is streamed"
  (save-excursion
    (with-current-buffer (gptel (consult-omni--gptel-buffer-name query args) nil nil nil)
      (let* ((query-sent)
             (backend (and backend (car (seq-filter (lambda (item) (when (string-match (format "%s" backend) item) item)) (mapcar #'car gptel--known-backends)))))
             (backend (or backend (gptel-backend-name consult-omni-gptel-backend)))
             (backend (cdr (assoc (format "%s" backend) gptel--known-backends)))
             (model (or (and model (format "%s" model))
                        (and backend (car (cl-struct-slot-value (type-of backend) 'models backend)))
                        consult-omni-gptel-model))
             (stream (if stream t nil)))
        (setq-local gptel-backend backend)
        (setq-local gptel-model model)
        (setq-local gptel-stream stream)
        (erase-buffer)
        (insert (gptel-prompt-prefix-string))
        (insert (format "%s" query))
        (unless query-sent
          (erase-buffer)
          (insert (gptel-prompt-prefix-string) query)
          (setq query-sent t)
          (gptel-send)))
      (current-buffer))))

(defun consult-omni--gptel-preview (cand)
  "Show a preview buffer of CAND from `consult-omni-gptel'.

The preview buffer is from `consult-omni--gptel-response-preview'."
  (if (listp cand) (setq cand (or (car-safe cand) cand)))
  (let*  ((query (get-text-property 0 :query cand))
          (backend (get-text-property 0 :backend cand))
          (model (get-text-property 0 :model cand))
          (stream (get-text-property 0 :stream cand))
          (buff (consult-omni--gptel-response-preview query :model model :backend backend :stream stream)))
    (if buff
        (funcall (consult--buffer-preview) 'preview
                 buff))))

#+end_src
***** title with placeholder
#+begin_src emacs-lisp
(cl-defun consult-omni--gptel-make-title-placeholder (input &rest args &key callback &allow-other-keys)
  "Make a placeholder for sending INPUT to gptel with ARGS.

This makes a placeholder string “ask gptel: %s” %s=INPUT with
metadata so it can be send to `gptel'.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (if callback (seq-difference args (list :callback callback)) args)))
               (opts (car-safe opts))
               (source "gptel")
               (backend (and (plist-member opts :backend) (format "%s" (plist-get opts :backend))))
               (backend (and backend (car (seq-filter (lambda (item) (when (string-match (format "%s" backend) item) item)) (mapcar #'car gptel--known-backends)))))
               (backend (or backend (gptel-backend-name consult-omni-gptel-backend)))
               (backend-struct  (cdr (assoc (format "%s" backend) gptel--known-backends)))
               (model (and (plist-member opts :model) (format "%s" (plist-get opts :model))))
               (model (or (and model backend-struct (member model (cl-struct-slot-value (type-of backend-struct) 'models backend-struct)) model)
                          (and backend-struct (car (cl-struct-slot-value (type-of backend-struct) 'models backend-struct)))))
               (stream (or (and (plist-member opts :stream) (plist-get opts :stream)) gptel-stream))
               (placeholder (format "ask gptel: %s" (if query (string-trim-right query) "")))
               (decorated (consult-omni--gptel-format-candidate :source source :query query :title placeholder :model model :backend backend :stream stream))
               (annotated-results
                (propertize decorated
                            :source source
                            :title query
                            :url nil
                            :query query
                            :model model
                            :stream stream
                            :backend backend)))
    (when (and annotated-results (functionp callback))
      (funcall callback (list annotated-results)))
    (list annotated-results)))

#+end_src
***** title with  short answer
#+begin_src emacs-lisp
(cl-defun consult-omni--gptel-make-title-short-answer (input &rest args &key callback &allow-other-keys)
  "Get a short preview answer from gptel for INPUT with ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (if callback (seq-difference args (list :callback callback)) args)))
               (opts (car-safe opts))
               (source "gptel")
               (backend (and (plist-member opts :backend) (format "%s" (plist-get opts :backend))))
               (backend (and backend (car (seq-filter (lambda (item) (when (string-match (format "%s" backend) item) item)) (mapcar #'car gptel--known-backends)))))
               (backend (or backend (gptel-backend-name consult-omni-gptel-backend)))
               (backend-struct (cdr (assoc (format "%s" backend) gptel--known-backends)))
               (model (and (plist-member opts :model) (format "%s" (plist-get opts :model))))
               (model (or (and model backend-struct (member model (cl-struct-slot-value (type-of backend-struct) 'models backend-struct)) model)
                          (and backend-struct (car (cl-struct-slot-value (type-of backend-struct) 'models backend-struct)))
                          consult-omni-gptel-model))
               (stream (or (and (plist-member opts :stream) (plist-get opts :stream)) gptel-stream))
               (gptel-backend backend-struct)
               (gptel-model model)
               (gptel-stream (if stream t nil))
               (output))
    (gptel-request query
      :system (format "Respond in %s words or less." consult-omni-gptel-short-answer-wordcount)
      :callback
      (lambda (response _)
        (when response
          (let* ((decorated
                  (consult-omni--gptel-format-candidate :source source :query query :title (string-trim-right response) :model model :backend backend :stream stream))
                 (annotated-result (propertize decorated
                                               :title response
                                               :source "gptel"
                                               :url nil
                                               :query query
                                               :model model
                                               :stream stream
                                               :backend backend)))
            (when annotated-result
              (when callback
                (funcall callback (list annotated-result)))
              (setq output (list annotated-result)))))))
    output))

#+end_src
**** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--gptel-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch chat response for INPUT from gptel with ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (unless (featurep 'gptel)
    (error "Consult-omni: gptel is not available.  Make sure to install and load `gptel'"))
  (let ((results))
    (cond
     ((stringp consult-omni-gptel-cand-title) (setq results (list consult-omni-gptel-cand-title)))
     ((functionp consult-omni-gptel-cand-title)
      (setq results (apply consult-omni-gptel-cand-title input :callback callback args))))
    results))

#+end_src
**** define source
#+begin_src emacs-lisp
;; Define the gptel source
(consult-omni-define-source "gptel"
                            :narrow-char ?a
                            :type 'dynamic
                            :require-match t
                            :face 'consult-omni-ai-title-face
                            :request #'consult-omni--gptel-fetch-results
                            :on-preview #'consult-omni--gptel-preview
                            :on-return #'identity
                            :on-callback #'consult-omni--gptel-preview
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :enabled (lambda () (fboundp 'gptel))
                            :group #'consult-omni--group-function
                            :sort t
                            :interactive consult-omni-intereactive-commands-type
                            :annotate nil)

#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-gptel' module

(provide 'consult-omni-gptel)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-gptel)
;;; consult-omni-gptel.el ends here
#+end_src


*** Invidious
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-invidious.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-invidious.el --- Consulting Invidious -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-invidious provides commands for searching Invidious in Emacs
;; using consult-omni.

;;; Code:

(require 'consult-omni)

#+end_src
**** variabels
***** other
#+begin_src emacs-lisp
(defvar consult-omni-invidious-servers nil
  "List of “Invidious” API servers.")

(defvar consult-omni-invidious-server-url "https://api.invidious.io/instances.json"
  "URL to fetch “Invidious” API servers.")

#+end_src
**** helper functions
***** get servers
#+begin_src emacs-lisp
(defun consult-omni--invidious-get-servers (&optional rotate)
  "Get list of Invidious API servers.

When ROTATE is no-nil roate the order of items in
`consult-omni-invidious-server'."
  (when (and consult-omni-invidious-servers rotate)
    (setq consult-omni-invidious-servers
          (nconc (cdr consult-omni-invidious-servers)
                 (list (car consult-omni-invidious-servers)))))
  (or consult-omni-invidious-servers
      (setq consult-omni-invidious-servers
            (let ((params `(("pretty" . "1")
                            ("sort_by" . "type"))))
              (consult-omni--fetch-url
               consult-omni-invidious-server-url
               consult-omni-http-retrieve-backend
               :params params
               :sync t
               :parser #'consult-omni--json-parse-buffer
               :callback (lambda (attrs)
                           (delq nil (mapcar (lambda (item)
                                               (when (equal (gethash "api" (cadr item)) t)
                                                 (gethash "uri" (cadr item))))
                                             attrs))))))))

#+end_src

***** format
#+begin_src emacs-lisp
(cl-defun consult-omni--invidious-format-candidate (&rest args &key source type query title snippet channeltitle date subcount videocount viewcount length face &allow-other-keys)
  "Format a candidate for `consult-omni-invidious' commands with ARGS.

Description of Arguments:

  SOURCE       a string; the name to use (e.g. “Invidious”)
  TYPE         a string; the type of candidate
               (e.g. video, channel, playlist)
  QUERY        a string; query input from the user
  TITLE        a string; the title of the video
  SNIPPET      a string; a snippet/description of the video
  CHANNELTITLE a string; the name of the channel for the video
  DATE         a string; the publish date of the video
  SUBCOUNT     an integer; the subscriber count fpr a channel
  VIDEOCOUNT   an integer; the number of videos in a playlist
  VIEWCOUNT    an integer; the number of times a video is viewed
  LENGTH       a number; the duration of a video in seconds
  FACE         a symbol; the face to apply to TITLE"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (propertize source 'face 'consult-omni-source-type-face))
         (match-str (if (and (stringp query) (not (equal query ".*"))) (consult--split-escaped query) nil))
         (videocount-str (and videocount (consult-omni--numbers-human-readable (or videocount 0) "videos")))
         (viewcount-str (and viewcount (consult-omni--numbers-human-readable (or viewcount 0) "views")))
         (subcount-str (and subcount (consult-omni--numbers-human-readable (or subcount 0) "subs")))
         (stats (and type
                     (stringp type)
                     (propertize
                      (consult-omni--set-string-width
                       (pcase type
                         ("video" (format "%s" (or viewcount-str "0 views")))
                         ("playlist" (format "%s" (or videocount-str "0 videos")))
                         ("channel" (format "%s" (or subcount-str "0 subscriptions")))
                         (_ ""))
                       10)
                      'face 'consult-omni-domain-face)))
         (length (or
                  (and (numberp length) (seconds-to-string length))
                  (and (equal type "playlist") "[PLAYLIST]")
                  (and (equal type "channel") "(CHANNEL)")))
         (length (and (stringp length) (consult-omni--set-string-width (propertize length 'face 'consult-omni-comment-face) 10)))
         (date (propertize (or (and (stringp date) date) (make-string 10 ?\s)) 'face 'consult-omni-date-face))
         (channeltitle (and channeltitle (stringp channeltitle) (propertize channeltitle 'face 'consult-omni-path-face)))
         (channeltitle (consult-omni--set-string-width channeltitle (* 2 frame-width-percent)))
         (snippet (if (stringp snippet) (consult-omni--set-string-width (replace-regexp-in-string "\n" "  " snippet) (* 2 frame-width-percent))))
         (snippet (and snippet (stringp snippet) (propertize snippet 'face 'consult-omni-snippet-face)))
         (face (or (consult-omni--get-source-prop source :face) face 'consult-omni-default-face))
         (title-str (and title (propertize title 'face face)))
         (title-str (consult-omni--set-string-width title-str (* 5 frame-width-percent)))
         (str (concat title-str
                      (when date (concat "\s" date))
                      (when channeltitle (concat " " channeltitle))
                      (propertize " " 'display `(space :align-to ,(+ (* 5 frame-width-percent)                                                                      11)))
                      (when length (concat "\s" length))
                      (unless (string-empty-p stats) (concat "\s" stats))
                      (when snippet (concat "\s\s" snippet))
                      (concat "\t" source))))
    (if consult-omni-highlight-matches-in-minibuffer
        (cond
         ((listp match-str)
          (mapc (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-omni--highlight-match match-str str t)))))
    str))

#+end_src

**** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--invidious-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch search results for INPUT from “Invidious” service with ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (type (plist-get opts :type))
               (order (or (plist-get opts :order) (plist-get opts :sort)))
               (channel (or (plist-get opts :channel) (plist-get opts :user)))
               (subs (or (plist-get opts :subs) (plist-get opts :subscriptions)))
               (searchdate (plist-get opts :date))
               (searchdate (if searchdate (format "%s" searchdate)))
               (features (plist-get opts :features))
               (features (if features (format "%s" features)))
               (duration (plist-get opts :dur))
               (duration (if duration (format "%s" duration)))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (page (or (and (integerp page) page)
                         (and page (string-to-number (format "%s" page)))
                         consult-omni-default-count))
               (page (+ (* page count) 1))
               (order  (if (and order (member (format "%s" order) '("date" "rating" "relevance" "upload_date" "views" "view_count"))) (format "%s" order) "relevance"))
               (type (if (and type (member (format "%s" type) '("channel" "playlist" "video" "movie" "show" "all"))) (format "%s" type) "video"))
               (params (delq nil `(("q" . ,(replace-regexp-in-string " " "+" query))
                                   ("sort_by" . ,order)
                                   ("type" . ,type)
                                   ("max_results" . ,(format "%s" count))
                                   ,(when searchdate `("date" . ,searchdate))
                                   ,(when features `("features" . ,features))
                                   ,(when duration `("duration" . ,duration))
                                   ,(when subs `("subscriptions" . ,(if subs "true" "false"))))))
               (server-url (car (consult-omni--invidious-get-servers)))
               (api-url (concat server-url "/api/v1/search?")))
    (consult-omni--fetch-url api-url consult-omni-http-retrieve-backend
                             :encoding 'utf-8
                             :params params
                             :parser #'consult-omni--json-parse-buffer
                             :callback
                             (lambda (attrs)
                               (let* ((raw-results attrs)
                                      (annotated-results
                                       (mapcar (lambda (item)
                                                 (let*
                                                     ((source "Invidious")
                                                      (item-type (gethash "type" item))
                                                      (channelhandle (gethash "channelHandle" item))
                                                      (title (or (gethash "title" item)
                                                                 (unless (eq channelhandle :null) channelhandle)
                                                                 (gethash "author" item)
                                                                 ))
                                                      (videos  (gethash "videos" item))
                                                      (videoid (or (gethash "videoId" item)
                                                                   (and videos (gethash "videoId" (car videos)))))
                                                      (channeltitle (gethash "author" item))
                                                      (channelid (gethash "authorId" item))
                                                      (playlistid (gethash "playlistId" item))
                                                      (videocount (gethash "videoCount" item))
                                                      (subcount (gethash "subCount" item))
                                                      (viewcount (gethash "viewCount" item))
                                                      (videolength (gethash "lengthSeconds" item))
                                                      (date (gethash "published" item))
                                                      (date (when date (format-time-string "%Y-%m-%d" (seconds-to-time date))))
                                                      (url (cond
                                                            ((and playlistid videoid)
                                                             (consult-omni--make-url-string
                                                              consult-omni-youtube-watch-url
                                                              `(("v" . ,videoid)
                                                                ("list" . ,playlistid))))
                                                            (playlistid (consult-omni--make-url-string consult-omni-youtube-watch-url `(("list" . ,playlistid))))
                                                            (videoid (consult-omni--make-url-string consult-omni-youtube-watch-url `(("v" . ,videoid))))
                                                            (channelid (concat consult-omni-youtube-channel-url channelid))))
                                                      (search-url (consult-omni--make-url-string server-url params))
                                                      (description (gethash "description" item))
                                                      (decorated (consult-omni--invidious-format-candidate :source source :type item-type :query query :title title :snippet description :channeltitle channeltitle :date date :subcount subcount :videocount videocount :viewcount viewcount :length videolength)))
                                                   (propertize decorated
                                                               :source source
                                                               :title title
                                                               :url url
                                                               :search-url search-url
                                                               :query query
                                                               :snippet description
                                                               :videoid videoid
                                                               :channeltitle channeltitle
                                                               :channelid channelid
                                                               :duration duration
                                                               :views viewcount
                                                               :videocount videocount
                                                               :subscriptions subcount)))
                                               raw-results)))
                                 (when (and annotated-results (functionp callback))
                                   (funcall callback annotated-results))
                                 annotated-results)))))

#+end_src
**** define source
#+begin_src emacs-lisp
;; Define the Invidious source
(consult-omni-define-source "Invidious"
                            :narrow-char ?y
                            :type 'dynamic
                            :require-match t
                            :category 'consult-omni-video
                            :face 'consult-omni-engine-title-face
                            :request #'consult-omni--invidious-fetch-results
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :enabled (lambda () (bound-and-true-p consult-omni-invidious-server-url))
                            :group #'consult-omni--group-function
                            :sort t
                            :interactive consult-omni-intereactive-commands-type
                            :annotate nil)

#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-invidious' module

(provide 'consult-omni-invidious)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-invidious)
;;; consult-omni-invidious.el ends here
#+end_src


*** notes
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-notes.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-notes.el --- Consulting Note Files -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-notes enables searching note files in consult-omni.
;; It provides commands to search notes using grep-like process (e.g. grep, ;; ripgrep, ...) and getting the results directly in the minibuffer.
;;
;; This is simply a convenient wrapper for `consult-omni-grep' and some
;; utilities to define a specific set of files/folders as notes and run
;; grep on the those files/folders.

;;; Code:

(require 'consult-omni)
(require 'consult-omni-grep)
(require 'consult-omni-ripgrep-all)

#+end_src

**** custom variables
#+begin_src emacs-lisp
(defcustom consult-omni-notes-files (append
                                     (when (bound-and-true-p consult-notes-file-dir-sources)
                                       ;; dir sources
                                       (apply #'append (mapcar #'cddr consult-notes-file-dir-sources)))
                                     ;; org roam
                                     (when (bound-and-true-p org-roam-directory)
                                       (list (expand-file-name org-roam-directory)))
                                     ;; denote
                                     (when (bound-and-true-p denote-directory)
                                       (list (expand-file-name denote-directory)))
                                     ;; org agenda files
                                     (when (bound-and-true-p consult-notes-org-headings-mode)
                                       (mapcar #'expand-file-name consult-notes-org-headings-files)))
  "List of all note files for consult-omni-notes."
  :group 'consult-omni
  :type '(repeat (string :tag "list of files")))

(defcustom consult-omni-notes-backend-command (or (and (executable-find "rga") "rga")
                                                  (and (executable-find "rg") "rg")
                                                  (and (executable-find "grep") "grep"))
  "What command-line program to use for searching files?

Can be either:
  grep  uses grep as backend command
  rg    uses ripgrep as backend command
  rga   uses ripgrep-all as backend command"
  :group 'consult-omni
  :type 'boolean)

(defcustom consult-omni--notes-new-func #'consult-omni--notes-new-capture-org
  "Function to use to create new notes.

This is used when a new candidate is selected (e.g. by `vertico-exit-input'.)"
  :group 'consult-omni
  :type '(choice (function :tag "(Default) Use Org Capture" consult-omni--notes-new-capture-org)
                 (function :tag "Use Org Roam" consult-omni--notes-new-capture-org-roam)
                 (function :tag "Use Denote" consult-omni--notes-new-create-denote)
                 (function :tag "Custom Function")))

#+end_src

**** helper functions
***** transform
#+begin_src emacs-lisp
(defun consult-omni--notes-transform (candidates &optional query)
  "Format CANDIDATES for QUERY from `consult-omni-notes'."
  (cond
   ((and (equal consult-omni-notes-backend-command "rga") (executable-find consult-omni-notes-backend-command))
    (consult-omni--ripgrep-all-format candidates :source "Notes Search" :query query :regexp-pattern consult-omni-ripgrep-all-match-regexp)
    )
   ((and (or (equal consult-omni-notes-backend-command "rg") (equal consult-omni-notes-backend-command "grep")) (executable-find consult-omni-notes-backend-command))
    (consult-omni--grep-format candidates :source "Notes Search" :query query :regexp-pattern consult--grep-match-regexp))
   (t nil)))

#+end_src

***** preview
#+begin_src emacs-lisp
(defun consult-omni--notes-preview (cand)
  "Preview function for CAND from `consult-omni-ripgrep-all'."
  (if (equal consult-omni-notes-backend-command "rga")
      (consult-omni--ripgrep-all-preview cand)
    (consult-omni--grep-preview cand)))

#+end_src

***** callback
#+begin_src emacs-lisp
(defun consult-omni--notes-callback (cand)
  "Callback function for CAND from `consult-omni-ripgrep-all'."
  (if (equal consult-omni-notes-backend-command "rga")
      (consult-omni--ripgrep-all-preview cand)
    (consult-omni--grep-preview cand)))

#+end_src

***** new
****** capture org
#+begin_src emacs-lisp
(defun consult-omni--notes-new-capture-org (&optional title)
  "Make a new org note with TITLE."
  (let ((old-marker org-capture-last-stored-marker))
    (org-capture-string title)
    (consult-omni-propertize-by-plist string `(:title ,title :source "Notes Search" :url nil :search-url nil :query ,title :file ,(cadr (org-capture-get :target))) 0 1)))

#+end_src
****** capture org-roam
#+begin_src emacs-lisp
(defun consult-omni--notes-new-capture-org-roam (&optional title)
  "Make new org-roam note with TITLE."
  (when (org-roam-node-find nil title)
    (consult-omni-propertize-by-plist title `(:title ,title :source "Notes Search" :url nil :search-url nil :query ,title :file ,(file-truename (buffer-file-name))) 0 1)))

#+end_src
****** open or create denote
#+begin_src emacs-lisp
(defun consult-omni--notes-new-create-denote (&optional title)
  "Make a new denote note with TITLE."
  (if-let* ((_ (push title denote-title-history))
            (file (denote--command-with-features #'denote nil nil t nil)))
      (consult-omni-propertize-by-plist title `(:title ,title :source "Notes Search" :url nil :search-url nil :query ,title :file ,(file-truename file)))))

#+end_src
****** new func
#+begin_src emacs-lisp
(defun consult-omni--notes-new (cand)
  "New function for new non-existing CAND from `consult-omni-notes'."
  (funcall consult-omni--notes-new-func cand))

#+end_src
**** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--notes-builder (input &rest args &key callback &allow-other-keys)
  "Make builder command line with INPUT and ARGS for `consult-omni-notes'.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input args))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (dir (plist-get opts :dir))
               (dir (if dir (file-truename (format "%s" dir))))
               (dir (or dir consult-omni-notes-files))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (backend-builder (cond
                                 ((and (or (equal consult-omni-notes-backend-command "rga") (equal consult-omni-notes-backend-command "rg")) (executable-find consult-omni-notes-backend-command))
                                  #'consult--ripgrep-make-builder)
                                 ((and (equal consult-omni-notes-backend-command "grep") (executable-find "grep")) #'consult--ripgrep-make-builder)
                                 (t nil))))
    (let ((consult-ripgrep-args (if (equal consult-omni-notes-backend-command "rga") consult-omni-ripgrep-all-args consult-ripgrep-args)))
      (when backend-builder
        (funcall (consult-omni--grep-make-builder backend-builder dir) query)))))

#+end_src


**** define source
#+begin_src emacs-lisp
;; Define the Notes Search source
(consult-omni-define-source "Notes Search"
                            :narrow-char ?n
                            :type 'async
                            :require-match nil
                            :face 'consult-omni-engine-title-face
                            :request #'consult-omni--notes-builder
                            :transform #'consult-omni--notes-transform
                            :on-preview #'consult-omni--notes-preview
                            :on-return #'identity
                            :on-callback #'consult-omni--notes-callback
                            :on-new #'consult-omni--notes-new
                            :preview-key (or consult-omni-preview-key any)
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :group #'consult-omni--group-function
                            :sort t
                            :interactive consult-omni-intereactive-commands-type
                            :annotate nil
                            :enabled (lambda () (bound-and-true-p consult-omni-notes-files)))

#+end_src


**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-notes' module

(provide 'consult-omni-notes)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-notes)
;;; consult-omni-notes.el ends here
#+end_src


*** notmuch
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-notmuch.el
:END:
**** header

#+begin_src emacs-lisp
;;; consult-omni-notmuch.el --- Consulting Notmuch Command -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-notmuch "0.8.1")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-notmuch enables searching notmuch emails in consult-omni.
;; It provides commands to search emails and getting the results
;; directly in the minibuffer.
;;
;; For more info on notmuch see the following URLs:
;; URL `https://github.com/notmuch/notmuch'
;; URL `https://notmuchmail.org/notmuch-emacs/'

;;; Code:

(require 'consult-omni)
(require 'notmuch)

#+end_src
**** variables
***** custom
#+begin_src emacs-lisp
(defcustom consult-omni-notmuch-message-buffer-name "*consult-omni-notmuch-message*"
  "Name of consult-omni-notmuch preview buffer."
  :group 'consult-omni
  :type 'string)

(defcustom consult-omni-notmuch-tree-buffer-name "*consult-omni-notmuch-tree*"
  "Name of consult-omni-notmuch tree buffer."
  :group 'consult-omni
  :type 'string)

(defcustom consult-omni-notmuch-command (or notmuch-command "notmuch")
  "Name of the notmuch binary.

By default inherits from `notmuch-command'."
  :group 'consult-omni
  :type 'string)

(defcustom consult-omni-notmuch-default-command-arg "search"
  "Default notmuch commandline arg for finding messages.
Can be either “search” or “show”"
  :group 'consult-omni
  :type  '(choice (const :tag "(Default) search" "search")
                  (const :tag "show" "show")))

(defcustom consult-omni-notmuch-extra-command-args (list)
  "Extra notmuch commandline arguments."
  :group 'consult-omni
  :type '(repeat (choice string)))

(defcustom consult-omni-notmuch-default-count consult-omni-default-count
  "Number of notmuch search results to retrieve.

By default inherits from `consult-omni-default-count'."
  :group 'consult-omni
  :type 'integer)

#+end_src
***** other
#+begin_src emacs-lisp
(defvar consult-omni--notmuch-format-func-alist '(("show" . consult-omni--notmuch-show-transform)
                                                  ("search" . consult-omni--notmuch-search-transform))
  "Alist of transfrom functions for notmuch commandline output.")

#+end_src
**** helper functions
***** transform/format
****** format cnadidates
#+begin_src emacs-lisp
(cl-defun consult-omni--notmuch-format-candidate (&rest args &key source query title from date tags face &allow-other-keys)
  "Format a candidate from `consult-omni-notmuch' with ARGS.

Description of Arguments:

  SOURCE a string; the name to use (e.g. “YouTube”)
  QUERY  a string; the query input from the user
  TITLE  a string; the notmuch title string of the message
  FROM   a string; the notmuch sender string of the message
  DATE   a string; the notmuch date string of the message
  TAGS   a list; a list of notmuch tag string(s) for message
  FACE   a symbol; the face to apply to TITLE"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (if (stringp source) (propertize source 'face 'consult-omni-source-type-face) nil))
         (match-str (if (and (stringp query) (not (equal query ".*"))) (consult--split-escaped query) nil))
         (date (if (stringp date) (propertize date 'face 'consult-omni-date-face) "            "))
         (from (if (stringp from) (propertize from 'face 'consult-omni-path-face) ""))
         (from-str (and (stringp from) (consult-omni--set-string-width from (* 2 frame-width-percent))))
         (tags (cond ((and tags (listp tags)) (format "(%s)" (mapconcat #'identity tags ", ")))
                     ((and tags (stringp tags)) tags)
                     (t nil)))
         (tags (and tags (stringp tags) (propertize tags 'face 'consult-omni-keyword-face)))
         (face (or (consult-omni--get-source-prop source :face) face 'consult-omni-default-face))
         (title-str (if (stringp title) (propertize title 'face face)))
         (title-str (if (stringp title-str) (consult-omni--set-string-width title-str (* 5 frame-width-percent))))
         (str (if (string-empty-p from) ""
                (concat (if date (format "%s" date))
                        (if from-str (format "\s%s" from-str))
                        "\t"
                        (if title-str title-str)
                        (if tags (format "\s\s%s" tags))
                        (if source (concat "\t" source))))))
    (if consult-omni-highlight-matches-in-minibuffer
        (cond
         ((and (listp match-str) (stringp str))
          (mapc (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((and (stringp match-str) (stringp str))
          (setq str (consult-omni--highlight-match match-str str t)))))
    str))

#+end_src
****** transform show
#+begin_src emacs-lisp
(defun consult-omni--notmuch-search-transform (candidates &optional query)
  "Transform CANDIDATES from “notmuch search” to consult-omni's style.

QUERY is the user input string.

Parses the output from command “notmuch search” and passes its
components to  `consult-omni--notmuch-format-candidate'."
  (remove nil (remove "" (mapcar (lambda (item)
                                   (when (and (stringp item) (string-match "thread:" item))
                                     (let* ((source "notmuch")
                                            (id (car (split-string item "\\ +")))
                                            (date (substring item 24 37))
                                            (mid (substring item 24))
                                            (c0 (string-match "[[]" mid))
                                            (c1 (string-match "[]]" mid))
                                            (count (substring mid c0 (1+ c1)))
                                            (senders (string-trim (nth 1 (split-string mid "[];]"))))
                                            (subject (string-trim (nth 1 (split-string mid "[;]"))))
                                            (headers (list :Subject subject :From senders))
                                            (t0 (string-match "([^)]*)\\s-*$" mid))
                                            (tags (split-string (substring mid (1+  t0) -1)))
                                            (decorated (consult-omni--notmuch-format-candidate :source source :query query :title subject :from senders :date date :tags tags)))
                                       (when (and (stringp decorated) (not (string-empty-p decorated)))
                                         (propertize decorated
                                                     :source source
                                                     :query query
                                                     :title subject
                                                     :url nil
                                                     :search-url nil
                                                     :id id
                                                     :from senders
                                                     :date date
                                                     :match t
                                                     :headers headers
                                                     :count count
                                                     :tags tags
                                                     )))))
                                 candidates))))

#+end_src
****** transform search
#+begin_src emacs-lisp
(defun consult-omni--notmuch-show-transform (candidates &optional query)
  "Transform CANDIDATES from “notmuch show” to consult-omni's style.

QUERY is the user input string.

Parses the output from command “notmuch show” and passes its components
to `consult-omni--notmuch-format-candidate'."
  (let ((source "notmuch") (id) (headers) (subject) (senders) (cc) (to) (count) (date) (tags) (match) (info))
    (remove nil (mapcar (lambda (item)
                          (if (string-prefix-p "message}" item)
                              (prog1
                                  (let* ((subject (or subject (plist-get headers :Subject)))
                                         (date  (or date (plist-get headers :Date)))
                                         (senders (or senders (plist-get headers :From)))
                                         (cc  (or cc (plist-get headers :Cc)))
                                         (to  (or to (plist-get headers :To)))
                                         (decorated (consult-omni--notmuch-format-candidate :source source :query query :title subject :from senders :date date :tags tags)))
                                    (when (and (stringp decorated) (not (string-empty-p decorated)))
                                      (propertize decorated
                                                  :source source
                                                  :query query
                                                  :title subject
                                                  :url nil
                                                  :search-url nil
                                                  :id id
                                                  :from senders
                                                  :date date
                                                  :match t
                                                  :headers headers
                                                  :count count
                                                  :tags tags
                                                  )))
                                (setq id nil
                                      headers nil
                                      senders nil
                                      subject nil
                                      count nil
                                      date nil
                                      tags nil
                                      match nil
                                      info nil))
                            (cond ((string-match "message{ \\(id:[^ ]+\\) .+" item)
                                   (setq id (match-string 1 item))
                                   (setq match t))
                                  ((string-prefix-p "header{" item)
                                   (setq info t))
                                  ((and item info)
                                   (cond ((string-match "\\(.+\\) (\\([^)]+\\)) (\\([^)]*\\))$" item)
                                          (setq senders (match-string 1 item))
                                          (setq date (match-string 2 item))
                                          (setq tags (split-string (match-string 3 item))))
                                         ((string-match "\\(Subject\\|From\\|To\\|Cc\\|Date\\): \\(.+\\)?" item)
                                          (let ((k (intern (format ":%s" (match-string 1 item))))
                                                (v (or (match-string 2 item) "")))
                                            (setq headers
                                                  (plist-put headers k v))))))
                                  ((string-prefix-p "header}" item)
                                   (setq info nil)))
                            nil))
                        candidates))))

#+end_src
****** default transform
#+begin_src emacs-lisp
(defun consult-omni--notmuch-get-transform-func (&rest args)
  "Get the appropriate transform function for notmuch commands with ARGS.

This is needed to get the right function for
parsing outputs of “notmuch search”, and
“notmuch show” accordingly."
  (cdr (assoc consult-omni-notmuch-default-command-arg consult-omni--notmuch-format-func-alist)))

#+end_src
***** preview
#+begin_src emacs-lisp
(defun consult-omni--notmuch--preview (cand)
  "Preview function for CAND from `consult-omni-notmuch'."
  (let* ((query (get-text-property 0 :query cand))
         (id (get-text-property 0 :id cand)))
    (when id
      (when (get-buffer consult-omni-notmuch-message-buffer-name)
        (kill-buffer consult-omni-notmuch-message-buffer-namee))
      (notmuch-show id nil nil query consult-omni-notmuch-message-buffer-name))))

#+end_src
***** callback
#+begin_src emacs-lisp
(defun consult-omni--notmuch-callback (cand)
  "Callback function for CAND from `consult-omni-notmuch'."
  (let* ((query (get-text-property 0 :query cand))
         (id (get-text-property 0 :id cand)))
    (when id
      (when (get-buffer consult-omni-notmuch-message-buffer-name)
        (kill-buffer consult-omni-notmuch-message-buffer-name))
      (notmuch-tree query nil id consult-omni-notmuch-tree-buffer-name t nil nil nil))))

#+end_src
**** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--notmuch-command-builder (input &rest args &key callback &allow-other-keys)
  "Make builder command line args for “notmuch” with INPUT and ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (setq consult-notmuch--partial-parse nil)
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-notmuch-default-count))
               (page (or (and page (integerp (read page)) (string-to-number page))
                         consult-omni-default-page))
               (page (* count page))
               (consult-omni-notmuch-extra-command-args (unless (listp consult-omni-notmuch-extra-command-args) (list consult-omni-notmuch-extra-command-args)))
               (cmd (append (list notmuch-command) (list consult-omni-notmuch-default-command-arg) (when count (list "--limit" (format "%s" count))) (when (and page (not (equal page 0))) (list "--offset" (format "%s" page))) consult-omni-notmuch-extra-command-args (list query))))
    cmd))

#+end_src
**** define source
#+begin_src emacs-lisp
;; Define the notmuch source
(consult-omni-define-source "notmuch"
                            :narrow-char ?m
                            :type 'async
                            :require-match nil
                            :category 'notmuch-result
                            :face 'consult-omni-engine-title-face
                            :request #'consult-omni--notmuch-command-builder
                            :on-preview #'consult-omni--notmuch--preview
                            :on-return #'identity
                            :on-callback #'consult-omni--notmuch-callback
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--email-select-history
                            :group #'consult-omni--group-function
                            :sort t
                            :interactive consult-omni-intereactive-commands-type
                            :transform (lambda (candidates &optional query) (funcall (consult-omni--notmuch-get-transform-func) candidates query))
                            :enabled (lambda () (and (bound-and-true-p notmuch-command)
                                                     (executable-find notmuch-command)))
                            :annotate nil)

#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-notmuch' module

(provide 'consult-omni-notmuch)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-notmuch)
;;; consult-omni-notmuch.el ends here

#+end_src

*** Numi
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-numi.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-numi.el --- Consulting numi Command -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-numi provides commands for doing calculations directly in
;; Emacs minibuffer using consult-omni as the frontend and numi-cli shell
;; commands as the backend.
;;
;; For more info on nuumi and numi-cli see the following URLs:
;; URL `https://numi.app'
;; URL `https://github.com/nikolaeu/numi'

;;; Code:

(require 'consult-omni)

#+end_src

**** custom variables
#+begin_src emacs-lisp
(defcustom consult-omni-numi-args "numi-cli"
  "Command line arguments for “numi-cli”.

Similar to other command line args for consult but for numi-cli.
See `consult-locate-args' for example."
  :group 'consult-omni
  :type '(choice string (repeat (choice string sexp))))

#+end_src

**** helper functions
***** preview
#+begin_src emacs-lisp
(defun consult-omni--numi-preview (cand)
  "Preview function for CAND from `consult-omni-numi'."
  (ignore))

#+end_src

***** callback
#+begin_src emacs-lisp
(defun consult-omni--numi-callback (cand)
  "Callback function for CAND from `consult-omni-numi'."
  (let ((result  (get-text-property 0 :title cand)))
    (kill-new result)))

#+end_src


***** filter
#+begin_src emacs-lisp
(defun consult-omni--numi-filter (candidates &optional query)
  "Filter CANDIDATES from `consult-omni-numi'.

QUERY is the user input string."
  (cl-loop for candidate in candidates
           when (not (equal candidate "?"))
           collect candidate))

#+end_src
**** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--numi-builder (input &rest args &key callback &allow-other-keys)
  "Make builder command line args for “numi-cli” with INPUT and ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts)))
    (funcall #'consult-omni--async-builder (shell-quote-argument query) consult-omni-numi-args)))

#+end_src

**** define source
#+begin_src emacs-lisp
;; Define the Numi source
(consult-omni-define-source "Numi"
                            :narrow-char ?N
                            :category 'consult-omni-calc
                            :type 'async
                            :require-match t
                            :face 'consult-omni-engine-title-face
                            :request #'consult-omni--numi-builder
                            :filter #'consult-omni--numi-filter
                            :on-preview #'ignore
                            :on-return #'identity
                            :on-callback #'consult-omni--numi-callback
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :group #'consult-omni--group-function
                            :enabled (lambda () (executable-find "numi-cli"))
                            :sort t
                            :interactive consult-omni-intereactive-commands-type
                            :annotate nil)

#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-numi module

(provide 'consult-omni-numi)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-numi)
;;; consult-omni-numi.el ends here
#+end_src



*** Org Agenda
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-org-agenda.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-org-agenda.el --- Consulting Org Agenda -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-org-agenda enables searching `org-agenda' directly in Emacs ;; minibuffer using consult-omni.  It provides commands to search aegnda
;; items and see relevant items in the minibuffer and has support for
;; filter and narrow down based on dates or tags, etc.

;;; Code:

(require 'consult-omni)

#+end_src
**** variables
***** custom
#+begin_src emacs-lisp
(defcustom consult-omni-org-agenda-number-of-days-around 7
  "Number of days to use for listing agenda items around a date.

agenda items for +/- days around a given date will be listed.
See `consult-omni--org-agenda-around' for more details."
  :group 'consult-omni
  :type 'integer)


(defcustom consult-omni-org-agenda-transform-prefix "?"
  "Prefix in query to trigger transformation.

If the user input includes this prefix string, `consult-omni-org-agenda'
tries to transform the query if needed.  This is used to transform search terms
like “today”, “this week”, “around last month”, etc. to date and date ranges.
See `consult-omni--org-agenda-query-dwim-transform' for details."
  :group 'consult-omni
  :type 'string)


(defcustom consult-omni-org-agenda-timestamp-format (or (and (bound-and-true-p org-timestamp-formats) (car org-timestamp-formats)) "%Y-%m-%d %a")
  "Timestamp format for time string in `consult-omni-org-agenda'.

This string is used to format timestamps in the marginalia info.
See `org-timestamp-formats' and `org-time-stamp-format'
for org fomrating, and `format-time-string' for more details."
  :group 'consult-omni
  :type 'string)


(defcustom consult-omni-org-agenda-regexp-builder #'consult-omni--org-agenda-split-by-space
  "Function to transform query to a regexp pattern.

This funciton is called with the input query to get a
matching regexp pattern."
  :group 'consult-omni
  :type '(choice (const :tag "(Default) match any word sepearated by space" consult-omni--org-agenda-split-by-space)
                 (funciton :tag "custom function")))

#+end_src
**** helper functions

***** transform dates and queries

****** format time-strings
#+begin_src emacs-lisp
(defun consult-omni--org-agenda-format-time-string (date &optional format)
  "Format DATE according to FORMAT using `format-time-string'.

If FORMAT is nil, uses `consult-omni-org-agenda-timestamp-format' as
fallback."
  (condition-case err
      (format-time-string (or format consult-omni-org-agenda-timestamp-format) date)
    (error (progn (message (error-message-string err))
                  nil))))

#+end_src

****** regexp for date ranges
#+begin_src emacs-lisp
(defun consult-omni--org-agenda-date-range-regexp (date-strings &optional format-func)
  "Make a regexp matching DATE-STRINGS.

DATE-STRINGS a list; list of date strings.
FORMAT-FUNC  a function; function to format each date in DATE-STRINGS
             FORMAT-FUNC defaults to
             `consult-omni--org-agenda-format-time-string'."
  (let ((format-func (or format-func #'consult-omni--org-agenda-format-time-string)))
    (mapconcat (lambda (date) (if (stringp date) date (funcall format-func date))) date-strings "\\|")))

#+end_src

****** relative date
#+begin_src emacs-lisp
(defun consult-omni--org-agenda-relative-date (date int unit)
  "Get the date for INT*UNIT relative to DATE.

Description of Arguments:

  INT an integer; number UNITS (days, months or years)
  UNIT a constant; either :day, :month or :year."
  (if (stringp date) (setq date  (date-to-time date)))
  (setq int (or (and (numberp int) int)
                (and (stringp int) (string-to-number int))))
  (unless (member unit '(:day :month :year :week)) (setq unit (intern (concat ":" (format "%s" unit)))))
  (when (eq unit :week) (setq int (* int 7)
                              unit :day))
  (if (member unit '(:day :month :year))
      (encode-time (decoded-time-add (decode-time date) (make-decoded-time unit int)))
    (message "Cannot use %s in calculating relative date." unit)))

#+end_src
****** previous day
#+begin_src emacs-lisp
(defun consult-omni--org-agenda-previous-day (date)
  "Get the date for one day before DATE."
  (consult-omni--org-agenda-relative-date date -1 :day))

#+end_src
****** next day
#+begin_src emacs-lisp
(defun consult-omni--org-agenda-next-day (date)
  "Get the date for the next day after DATE."
  (consult-omni--org-agenda-relative-date date 1 :day))

#+end_src
****** begin of week
#+begin_src emacs-lisp
(defun consult-omni--org-agenda-begin-week (date)
  "Get the date of the first day of the week for DATE."
  (if (stringp date) (setq date  (date-to-time date)))
  (let ((day-of-week (decoded-time-weekday (decode-time date))))
    (consult-omni--org-agenda-relative-date date (- 0 day-of-week) :day)))

#+end_src
****** begin work week
#+begin_src emacs-lisp
(defun consult-omni--org-agenda-begin-work-week (date)
  "Get the date of the first working day of the week for DATE."
  (consult-omni--org-agenda-next-day (consult-omni--org-agenda-begin-week date)))

#+end_src
****** week from
#+begin_src emacs-lisp
(defun consult-omni--org-agenda-week-from (date)
  "Get the dates for one week starting at DATE."
  (cl-loop for d from 0 to 6
           collect (consult-omni--org-agenda-relative-date date d :day)))

#+end_src
****** week of
#+begin_src emacs-lisp
(defun consult-omni--org-agenda-week-of (date)
  "Get the dates for the calendar week of DATE."
  (consult-omni--org-agenda-week-from (consult-omni--org-agenda-begin-week date)))

#+end_src
****** work week of
#+begin_src emacs-lisp
(defun consult-omni--org-agenda-work-week-of (date)
  "Get the dates for the working week of DATE."
  (cl-loop for d from 0 to 4
           collect (consult-omni--org-agenda-relative-date
                    (consult-omni--org-agenda-begin-work-week date) d :day)))

#+end_src

****** next week
#+begin_src emacs-lisp
(defun consult-omni--org-agenda-next-week (date)
  "Get the list of dates for the calendar week after DATE."
  (consult-omni--org-agenda-week-of (consult-omni--org-agenda-relative-date date 7 :day)))

#+end_src
****** next work week
#+begin_src emacs-lisp
(defun consult-omni--org-agenda-next-work-week (date)
  "Get the list of dates for the working week after DATE."
  (consult-omni--org-agenda-work-week-of (consult-omni--org-agenda-relative-date date 7 :day)))

#+end_src
****** previous week
#+begin_src emacs-lisp
(defun consult-omni--org-agenda-previous-week (date)
  "Get the list of dates for the calendar week before DATE."
  (consult-omni--org-agenda-week-of (consult-omni--org-agenda-relative-date date -7 :day)))

#+end_src
****** previous work week
#+begin_src emacs-lisp
(defun consult-omni--org-agenda-previous-work-week (date)
  "Get the list of dates for the working week before DATE."
  (consult-omni--org-agenda-work-week-of (consult-omni--org-agenda-relative-date date -7 :day)))

#+end_src
****** next month
#+begin_src emacs-lisp
(defun consult-omni--org-agenda-next-month (date)
  "Get the year-month string for one month after the DATE."
  (consult-omni--org-agenda-relative-date date 1 :month))

#+end_src

****** previous month
#+begin_src emacs-lisp
(defun consult-omni--org-agenda-previous-month (date)
  "Get the year-month string for one month before the DATE."
  (consult-omni--org-agenda-relative-date date -1 :month))

#+end_src


****** next year
#+begin_src emacs-lisp
(defun consult-omni--org-agenda-next-year (date)
  "Get the year-month string for one year after the DATE."
  (consult-omni--org-agenda-relative-date date 1 :year))

#+end_src

****** previous year
#+begin_src emacs-lisp
(defun consult-omni--org-agenda-previous-year (date)
  "Get the year-month string for one year before the DATE."
  (consult-omni--org-agenda-relative-date date -1 :year))

#+end_src



****** around day
#+begin_src emacs-lisp
(defun consult-omni--org-agenda-around (date int unit)
  "Get the dates for (+/-)INT*UNIT around the DATE.

Description of Arguments:
  INT  an integer; number of days, or months or years
  UNIT a constant; either :day, :month or :year"
  (cl-loop for d from (- 0 int) to int
           collect (consult-omni--org-agenda-relative-date date d unit)))

#+end_src
****** transform dwim query
#+begin_src emacs-lisp
(defun consult-omni--org-agenda-query-dwim-transform (query)
  "Transform QUERY to what the user means.

Try to guess the dates based on user input query.
For example to get the date for tommorrow, next week, ..."
  (save-match-data
    (if consult-omni-org-agenda-transform-prefix
        (cond
         ((string-prefix-p consult-omni-org-agenda-transform-prefix query)
          (setq query (s-downcase (string-remove-prefix consult-omni-org-agenda-transform-prefix query))))
         (t
          (setq query nil))))
    (if query
        (cond
         ((string-match "around \\(.*\\)" query)
          (when-let ((date (consult-omni--org-agenda-query-dwim-transform (concat consult-omni-org-agenda-transform-prefix (match-string 1 query)))))
            (consult-omni--org-agenda-date-range-regexp (consult-omni--org-agenda-around (or (car-safe date) date) consult-omni-org-agenda-number-of-days-around :day))))
         ((equal query "yesterday") (consult-omni--org-agenda-format-time-string
                                     (consult-omni--org-agenda-previous-day (current-time))))
         ((equal query "today") (consult-omni--org-agenda-format-time-string (current-time)))
         ((equal query "tomorrow") (consult-omni--org-agenda-format-time-string
                                    (consult-omni--org-agenda-next-day (current-time))))
         ((equal query "this week") (consult-omni--org-agenda-date-range-regexp
                                     (consult-omni--org-agenda-week-of (current-time))))
         ((equal query "this work week") (consult-omni--org-agenda-date-range-regexp
                                          (consult-omni--org-agenda-work-week-of (current-time))))
         ((equal query "next week") (consult-omni--org-agenda-date-range-regexp
                                     (consult-omni--org-agenda-next-week (current-time))))
         ((equal query "next work week") (consult-omni--org-agenda-date-range-regexp
                                          (consult-omni--org-agenda-next-work-week (current-time))))
         ((equal query "last week") (consult-omni--org-agenda-date-range-regexp
                                     (consult-omni--org-agenda-previous-week (current-time))))
         ((equal query "last work week") (consult-omni--org-agenda-date-range-regexp
                                          (consult-omni--org-agenda-previous-work-week (current-time))))
         ((equal query "this month") (consult-omni--org-agenda-format-time-string (current-time) "%Y-%m"))
         ((equal query "next month") (consult-omni--org-agenda-format-time-string
                                      (consult-omni--org-agenda-next-month (current-time))
                                      "%Y-%m"))
         ((equal query "last month") (consult-omni--org-agenda-format-time-string
                                      (consult-omni--org-agenda-previous-month (current-time))
                                      "%Y-%m"))
         ((equal query "this year") (consult-omni--org-agenda-format-time-string
                                     (current-time)
                                     "%Y"))
         ((equal query "next year") (consult-omni--org-agenda-format-time-string
                                     (consult-omni--org-agenda-next-year (current-time))
                                     "%Y"))
         ((equal query "last year") (consult-omni--org-agenda-format-time-string
                                     (consult-omni--org-agenda-previous-year (current-time))
                                     "%Y"))
         ((string-match "\\([0-9]+\\) \\(.+?\\)[s]? ago" query)
          (consult-omni--org-agenda-format-time-string
           (consult-omni--org-agenda-relative-date (current-time) (- 0 (string-to-number (match-string 1 query))) (match-string 2 query))))
         ((string-match "\\([0-9]+\\) \\(.+?\\)[s]? from now" query)
          (consult-omni--org-agenda-format-time-string
           (consult-omni--org-agenda-relative-date (current-time) (string-to-number (match-string 1 query)) (match-string 2 query))))
         (t query))
      nil)))

#+end_src
***** format agenda items
#+begin_src emacs-lisp
(cl-defun consult-omni--org-agenda-format-candidate (&rest args &key source query title buffer todo prio tags filepath snippet sched dead face &allow-other-keys)
  "Format a candidate for `consult-omni-org-agenda' with ARGS.

Description of Arguments:

  SOURCE   a string; the name of the source (e.g. “Org Agenda”)
  QUERY    a string; the query input from the user
  TITLE    a string; the title of the agenda item
  BUFFER   a string; name of the buffer
  TODO     a string; todo keyword of the org heading for agenda item
  PRIO     a string; priority level of the org heading for agenda item
  TAGS     a list of strings; tags of the org agenda item
  FILEPATH a string; filepath of the org agenda item
  SNIPPET  a string; a snippet/description of the agenda item
  SCHED    a string; the scheduled date of the agenda item
  DEAD     a string; the deadline date of the agenda item
  FACE     a symbol; the face to apply to TITLE"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (propertize source 'face 'consult-omni-source-type-face))
         (match-str (if (and (stringp query) (not (equal query ".*"))) (consult--split-escaped query) nil))
         (buffer (and buffer (propertize (format "%s" buffer) 'face 'consult-omni-domain-face)))
         (prio (and (stringp prio) (propertize (format "[#%s]" prio) 'face 'consult-omni-prompt-face)))
         (todo (or (and (stringp todo) (propertize todo 'face (or (and org-todo-keyword-faces (cdr (assoc todo org-todo-keyword-faces)))
                                                                  (and (member todo org-done-keywords) 'org-done)
                                                                  'org-todo))) ""))
         (tags (and tags (stringp tags) (propertize tags 'face 'consult-omni-keyword-face)))
         (snippet (and snippet (stringp snippet) (propertize snippet 'face 'consult-omni-snippet-face)))
         (snippet (if (stringp snippet) (consult-omni--set-string-width (replace-regexp-in-string "\n" "  " snippet) (* 2 frame-width-percent))))
         (sched (or (and sched (stringp sched) (propertize sched 'face (or 'org-agenda-date 'consult-omni-date-face))) (make-string 16 ?\s)))
         (fraction (and dead (- 1 (min (/ (float (- (org-agenda--timestamp-to-absolute dead) (org-today))) (max (org-get-wdays dead) 1)) 1.0))))
         (dead-face (and dead
                         (org-agenda-deadline-face
			  fraction)))
         (dead (or (and dead (stringp dead) (propertize dead 'face (or dead-face 'consult-omni-warning-face))) (make-string 16 ?\s)))
         (date (concat (and (stringp sched) sched) (and (stringp sched) " ") (and (stringp dead) dead)))
         (face (or (consult-omni--get-source-prop source :face) face))
         (todo-str (concat (or prio "    ") " " todo))
         (todo-str (and (stringp todo-str) (consult-omni--set-string-width todo-str 15)))
         (title (if (and face (stringp title)) (propertize title 'face face) title))
         (title-str (if (and (stringp tags) (stringp title)) (concat title " " tags) title))
         (title-str (and (stringp title-str)
                         (consult-omni--set-string-width title-str (* 4 frame-width-percent))))
         (str (concat title-str
                      (and todo-str "\t") todo-str
                      (and buffer "\s") buffer
                      (and date "\s\s") date
                      (and snippet "\s\s") snippet
                      (and source "\t") source)))
    (if consult-omni-highlight-matches-in-minibuffer
        (cond
         ((listp match-str)
          (mapc (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-omni--highlight-match match-str str t)))))
    str))

#+end_src
***** consult-omni--org-agenda-regexp-pattern
#+begin_src emacs-lisp
(defun consult-omni--org-agenda-split-by-space (query)
  "Split QUERY string by spaces."
  (string-join (split-string query "\s" t) "\\|"))

#+end_src
***** consult-omni--org-agenda-items
#+begin_src emacs-lisp

(defun consult-omni--org-agenda-items (query &optional match &rest skip)
  "Return a list of Org heading candidates thatv match the QUERY.

MATCH, is as in `org-map-entries'
SKIP, is as in `org-map-entries'

Adopted from `consult-org--headings'."
  (let (buffer
        (source "Org Agenda"))
    (apply
     #'org-map-entries
     (lambda ()
       ;; Reset the cache when the buffer changes, since `org-get-outline-path' uses the cache
       (unless (eq buffer (buffer-name))
         (setq buffer (buffer-name)
               org-outline-path-cache nil))
       (pcase-let* ((`(_ ,level ,todo ,prio ,_hl ,tags) (org-heading-components))
                    (filename (buffer-file-name))
                    (filepath (file-truename filename))
                    (tags (if org-use-tag-inheritance
                              (when-let ((tags (org-get-tags)))
                                (concat ":" (string-join tags ":") ":"))
                            tags))
                    (title (org-format-outline-path
                            (org-get-outline-path 'with-self 'use-cache)
                            most-positive-fixnum))
                    (prio (and (characterp prio) (char-to-string prio)))
                    (marker (point-marker))
                    (props (org-entry-properties))
                    (sched (cdr (assoc "TIMESTAMP" props)))
                    (dead (cdr (assoc "DEADLINE" props)))
                    (snippet nil)
                    (transform (or (consult-omni--org-agenda-query-dwim-transform query) query)))
         (if (string-match-p (or transform (funcall consult-omni-org-agenda-regexp-builder query)) (concat todo " " prio " " _hl " " sched " " dead " " tags))
             (propertize (consult-omni--org-agenda-format-candidate :source source :query (or transform query) :title title :buffer buffer :todo todo :prio prio :tags tags :filepath filepath :snippet snippet :sched sched :dead dead) :source source :title title :query query :url nil :search-url nil :tags tags :filepath filepath :marker marker))))
     match 'agenda skip)))

#+end_src


***** preview
#+begin_src emacs-lisp
(defun consult-omni--org-agenda-preview (cand)
  "Preview function for CAND from `consult-omni-org-agenda'."
  (if-let ((marker (get-text-property 0 :marker cand)))
      (consult--jump marker)))

#+end_src

***** callback
#+begin_src emacs-lisp
(defun consult-omni--org-agenda-callback (cand)
  "Callback function for CAND from `consult-omni-org-agenda'."
  (if-let ((marker (get-text-property 0 :marker cand)))
      (consult--jump marker)))

#+end_src

***** new
#+begin_src emacs-lisp
(defun consult-omni--org-agenda-new (cand)
  "Callback function for new CAND from `consult-omni-org-agenda'."
  (let ((title (substring-no-properties cand))
        (old-marker org-capture-last-stored-marker))
    (org-capture-string title)
    (consult-omni-propertize-by-plist title `(:title ,title :source "Org Agenda" :url nil :search-url nil :query ,title :sched nil :dead nil :tags nil :filepath ,(cadr (org-capture-get :target)) :marker ,(unless (equal old-marker org-capture-last-stored-marker) org-capture-last-stored-marker)) 0 1)))

#+end_src
**** fetching items/results
***** consult-omni--org-agenda-fetch-results
#+begin_src emacs-lisp
(cl-defun consult-omni--org-agenda-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch `org-agenda' items matching INPUT and ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (match (or (and (plist-member opts :match) (plist-get opts :match))
                          (and (plist-member opts :filter) (plist-get opts :filter))))
               (annotated-results (delq nil (consult-omni--org-agenda-items query match))))
    (when annotated-results
      (when (functionp callback)
        (funcall callback annotated-results))
      annotated-results)))

#+end_src
**** define source
#+begin_src emacs-lisp
;; Define the Org Agenda source
(consult-omni-define-source "Org Agenda"
                            :narrow-char ?o
                            :category 'org-heading
                            :type 'dynamic
                            :require-match nil
                            :request #'consult-omni--org-agenda-fetch-results
                            :on-preview #'consult-omni--org-agenda-preview
                            :on-return #'identity
                            :on-callback #'consult-omni--org-agenda-callback
                            :on-new #'consult-omni--org-agenda-new
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :enabled (lambda () (bound-and-true-p org-agenda-files))
                            :group #'consult-omni--group-function
                            :sort t
                            :interactive consult-omni-intereactive-commands-type)

#+end_src



**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-org-agenda' module

(provide 'consult-omni-org-agenda)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-org-agenda)
;;; consult-omni-org-agenda.el ends here
#+end_src

*** Projects
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-projects.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-projects.el --- Consulting project.el -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-projects enables searching projects directly in Emacs
;; minibuffer using consult-omni.  It uses projects.el as the backend
;; and provides commands to find projects, switch to them or create new
;; ones using consult-omni as the frontend.

;;; Code:

(require 'project)
(require 'consult-omni)

#+end_src
**** variables
***** custom
#+begin_src emacs-lisp
(defcustom consult-omni-projects-vc-backend 'vc
  "Backend to use for git operations.

Can be either:
  \='vc  uses built-in vc library
  \='magit  uses magit"
  :group 'consult-omni
  :type '(choice (const :tag "(Default) Use built-in vc" vc)
                 (const :tag "Use Magit" magit)))

(defcustom consult-omni-projects-default-projects-folder nil
  "Parent directory for making new projects."
  :group 'consult-omni
  :type 'directory)


(defcustom consult-omni-projects-default-fallback-switch-command #'dired
  "Function to call when `project-switch-project' is not available.

The function should accept one argument, a project directory"
  :group 'consult-omni
  :type '(choice (function :tag "Open directory in dired" dired)
                 (function :tag "Custom Function")))


(defcustom consult-omni-projects-preview-func #'consult-omni--projects-default-preview
  "Function to call for previewing projects.

The function should accept one argument, a project candidate
\(e.g. propertized string from `consult-omni-projects'\)."
  :group 'consult-omni
  :type '(choice (function :tag "Open project root in dired" consult-omni--projects-default-preview)
                 (function :tag "Custom Function")))

(defcustom consult-omni-projects-callback-func #'consult-omni--projects-default-callback
  "Function to call when selecting a project.

The function should accept one argument, a project candidate
\(e.g. propertized string from `consult-omni-projects'\)."
  :group 'consult-omni
  :type '(choice (function :tag "Call project-switch-project with project root" consult-omni--projects-default-callback)
                 (function :tag "Custom Function")))

(defcustom consult-omni-projects-new-func #'consult-omni--projects-make-new-project-dwim
  "Function to call when selecting a new non-existinng project.

The function should accept one argument, a project candidate
\(e.g. propertized string from `consult-omni-projects'\)."
  :group 'consult-omni
  :type '(choice (function :tag "(Default) Add existing folder or make a new project folder" consult-omni--projects-make-new-project-dwim)
                 (function :tag "Find and add existing project folder" consult-omni--projects-add-project-to-list)
                 (function :tag "Make a new project folder" consult-omni--projects-make-new-project)
                 (function :tag "Custom Function")))

(defcustom consult-omni-projects-create-new-func #'consult-omni--projects-create-new-git-project
  "Function to use for making new projects.

The function should accept one argument, a string with
the directory path where the new project will be created."
  :group 'consult-omni
  :type '(choice (function :tag "(Default) Use magit-init if availbale otherwise fall back to make-directory" consult-omni--projects-create-new-git-project)
                 (function :tag "Make a new Git directory with magit" magit-init)
                 (function :tag "Make directory" make-directory)
                 (function :tag "Custom Function")))

#+end_src

***** other
#+begin_src emacs-lisp
(defvar consult-omni--projects-create-new-project-hook nil
  "Functions called after `consult-omni-projects-create-new-func'.

The returned value from `onsult-omni-projects-default-new-func'
is passed to these functions as input arg.")

#+end_src
**** helper functions
***** format
#+begin_src emacs-lisp
(cl-defun consult-omni--projects-format-candidate (&rest args &key source query path name nfiles size face &allow-other-keys)
  "Format candidates from `consult-omni-projects' with ARGS.

Description of Arguments:

  SOURCE a string; the souurce name (e.g. “Projects”)
  QUERY  a string; the query input from the user
  PATH   a string; the filepath of the project
  NAME   a string; name of the project
  NFILES an integer; number of files in the project
  SIZE   a string; total size of the project in human readbale format
         \(e.g. output from `file-size-human-readable' on project dir\)
  FACE   the face to apply to TITLE"

  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (if (stringp source) (propertize source 'face 'consult-omni-source-type-face) nil))
         (match-str (if (and (stringp query) (not (equal query ".*"))) (consult--split-escaped query) nil))
         (face (or (consult-omni--get-source-prop source :face) face 'consult-omni-default-face))
         (name (if (stringp name) (propertize name 'face 'consult-omni-keyword-face)))
         (nfiles (if (numberp nfiles) (propertize (format "%s Files" nfiles) 'face 'consult-omni-path-face)))
         (size (if (stringp size) (propertize (format "%s" size) 'face 'consult-omni-domain-face)))
         (path (and (stringp path) (file-exists-p path) path))
         (title-str (and (stringp path) (propertize path 'face face)))
         (title-str (and (stringp title-str) (consult-omni--set-string-width title-str (* 4 frame-width-percent))))
         (str (if title-str (concat title-str
                                    (and name (concat "\t" name))
                                    (and nfiles (concat "\s\s" nfiles))
                                    (and nfiles (concat "\s\s" size))
                                    (and source (concat "\t" source))))))
    (if (and str consult-omni-highlight-matches-in-minibuffer)
        (cond
         ((listp match-str)
          (mapc (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-omni--highlight-match match-str str t)))))
    str))

#+end_src


***** preview
#+begin_src emacs-lisp
(defun consult-omni--projects-default-preview (cand)
  "Preview function for CAND from `consult-omni-projects'."
  (if-let* ((dir (get-text-property 0 :title cand)))
      (dired dir)))

#+end_src

***** callback
#+begin_src emacs-lisp
(defun consult-omni--projects-default-callback (cand)
  "Callback function for CAND from `consult-omni-projects'."
  (let* ((dir (get-text-property 0 :title cand))
         (project (get-text-property 0 :project cand))
         (root (and project (project-root project))))
    (if root (project-switch-project root)
      (funcall consult-omni-projects-default-fallback-switch-command dir))))

#+end_src

***** new
****** add existing project
#+begin_src emacs-lisp
(defun consult-omni--projects-add-project-to-list (cand)
  "Add the missing project CAND to `project--list'."
  (let* ((dir (read-directory-name (format "Find Project Directory for %s: " (propertize cand 'face 'font-lock-keyword-face)) default-directory nil t))
         (project (project--find-in-directory dir))
         (root (and project (project-root project))))
    (when (file-exists-p dir) (project--remember-dir dir)
          (if root (project-switch-project root)
            (funcall consult-omni-projects-default-fallback-switch-command dir)))
    dir))

#+end_src

****** default create git project function
#+begin_src emacs-lisp
(defun consult-omni--projects-create-new-git-project (dir)
  "Make a new Git project at DIR."
  (pcase consult-omni-projects-vc-backend
    ('vc
     (if (and (featurep 'vc-git) (require 'vc-git nil nil))
         (progn (make-directory dir t)
                (if-let ((default-directory dir)
                         (cmd (executable-find "git")))
                    (or (and (file-expand-wildcards (expand-file-name ".git" dir))
                             (y-or-n-p "There is already a .git folder there, do you want to re-initialize?")
                             (vc-git-create-repo))
                        (vc-git-create-repo))))
       (message "vc not available. Change `consult-omni-projects-vc-backend' to use a different backend!"))
     (funcall consult-omni-projects-default-fallback-switch-command dir))
    ('magit
     (if (and (featurep 'magit) (require 'magit nil nil))
         (or (and (file-expand-wildcards (expand-file-name ".git" dir))
                  (y-or-n-p "There is already a .git folder there, do you want to re-initialize?")
                  (funcall-interactively #'magit-init dir))
             (funcall-interactively #'magit-init dir))
       (message "Magit not available. Change `consult-omni-projects-vc-backend' to use a different backend!"))
     (funcall consult-omni-projects-default-fallback-switch-command dir)))
  dir)

#+end_src

****** make new project
#+begin_src emacs-lisp
(defun consult-omni--projects-make-new-project (cand)
  "Make new project for project name CAND."
  (let* ((dir (read-directory-name (concat "Select Parent Directory for %s: " (propertize cand 'face 'font-lock-keyword-face)) (or (and consult-omni-projects-default-projects-folder (file-name-as-directory consult-omni-projects-default-projects-folder)) default-directory) nil nil))
         (name (read-string (concat "Project Name for %s: " (propertize cand 'face 'font-lock-keyword-face)) cand))
         (target (expand-file-name (file-name-as-directory name) dir)))
    (funcall consult-omni-projects-create-new-func target)
    (when (file-exists-p target) (project--remember-dir target))
    target))

#+end_src

****** Make new project or add existing (dwim)
#+begin_src emacs-lisp
(defun consult-omni--projects-make-new-project-dwim (cand)
  "Add existing ro make new project for CAND."
  (let* ((dir (read-directory-name (format "Select Directory for %s: " (propertize cand 'face 'font-lock-keyword-face)) (or (and consult-omni-projects-default-projects-folder (file-name-as-directory consult-omni-projects-default-projects-folder)) default-directory) nil t))
         (project (project--find-in-directory dir))
         (root (and project (project-root project)))
         (existing  (if project
                        (y-or-n-p "There is an existing project in that directory.  Do you want to open that project?")))
         (new (unless existing (y-or-n-p (format "Do you want to make a new project under %s?" dir)))))
    (cond
     (existing
      (when (file-exists-p dir) (project--remember-dir dir)
            (if root (project-switch-project root)
              (funcall consult-omni-projects-default-fallback-switch-command dir))))
     (new
      (let* ((name (read-string (format "Project Name for %s: " (propertize cand 'face 'font-lock-keyword-face)) cand))
             (target (expand-file-name (file-name-as-directory name) dir)))
        (funcall consult-omni-projects-create-new-func target)
        (when (file-exists-p target)
          (project--remember-dir target)
          (setq dir target)))))
    dir))

#+end_src

**** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--projects-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch list of projects matching INPUT in `project--list' with ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts)))
    (delq nil (mapcar (lambda (item)
                        (let* ((source "Projects")
                               (path (car item))
                               (project (and (stringp path) (file-exists-p path) (project--find-in-directory path)))
                               (title (or (and project (project-root project)) path))
                               (name (or (and project (project-name project)) (file-name-nondirectory path)))
                               (p-files (and project (project-files project)))
                               (nfiles (and (listp p-files) (length p-files)))
                               (size (and (stringp title) (file-exists-p title) (file-size-human-readable (file-attribute-size (file-attributes title)))))
                               (decorated (consult-omni--projects-format-candidate :source source :title title  :name name :nfiles nfiles :size size)))
                          (when (stringp decorated) (add-text-properties 0 1 `(:source ,source :title ,title :query ,query :project ,project :dir ,title :name ,name) decorated))
                          decorated))
                      (cl-remove-if-not (lambda (item) (string-match (format ".*%s.*" query) (car item))) project--list)))))

#+end_src

**** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--projects-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch list of projects matching INPUT in `project--list' with ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (projects (cl-remove-if-not (lambda (item) (string-match (format ".*%s.*" query) (car item))) project--list)))
    (delq nil (cl-loop for item in  projects
                       collect (let* ((source "Projects")
                               (path (car item))
                               (_ (print path))
                               (project (and (stringp path) (file-exists-p path) (project--find-in-directory path)))
                               (title (or (and project (project-root project)) path))
                               (name (or (and project (project-name project)) (file-name-nondirectory path)))
                               (p-files (and project (project-files project)))
                               (nfiles (and (listp p-files) (length p-files)))
                               (size (and (stringp title) (file-exists-p title) (file-size-human-readable (file-attribute-size (file-attributes title)))))
                               (decorated (consult-omni--projects-format-candidate :source source :path title  :name name :nfiles nfiles :size size)))
                                  ;; (print decorated)
                          (when (stringp decorated) (add-text-properties 0 1 `(:source ,source :title ,title :query ,query :project ,project :dir ,title :name ,name) decorated))
                          decorated)))))

#+end_src

**** define source
#+begin_src emacs-lisp
;; Define the Projects source
(consult-omni-define-source "Projects"
                            :narrow-char ?P
                            :type 'sync
                            :require-match nil
                            :category 'project
                            ;; :face 'consult-omni-files-title-face
                            :on-setup #'project--read-project-list
                            :request #'consult-omni--projects-fetch-results
                            :on-preview (lambda (cand) (funcall consult-omni-projects-preview-func cand))
                            :on-callback (lambda (cand) (funcall consult-omni-projects-callback-func cand))
                            :on-new (lambda (cand) (run-hook-with-args 'consult-omni-create-project-hook (funcall consult-omni-projects-new-func cand)))
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :enabled (lambda () (bound-and-true-p project--list))
                            :group #'consult-omni--group-function
                            :sort t
                            :interactive consult-omni-intereactive-commands-type
                            :annotate nil)

#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-projects' module

(provide 'consult-omni-projects)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-projects)
;;; consult-omni-projects.el ends here
#+end_src



*** PubMed
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-pubmed.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-pubmed.el --- Consulting PubMed -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-pubmed provides commands for searching PubMed database
;; directly in Emacs using consult-omni as the frontend.

;;; Code:

(require 'consult-omni)

#+end_src
**** variables
***** custom
#+begin_src emacs-lisp
(defcustom consult-omni-pubmed-api-key nil
  "Key for Pubmed Entrez API.

See URL `https://www.ncbi.nlm.nih.gov/books/NBK25501/' for more info"
  :group 'consult-omni
  :type '(choice (const :tag "API Key" string)
                 (function :tag "Custom Function")))

#+end_src
***** other
#+begin_src emacs-lisp
(defvar consult-omni-pubmed-search-url "https://pubmed.ncbi.nlm.nih.gov/"
  "Search URL for PubMed.")

(defvar  consult-omni-pubmed-esearch-api-url "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi"
  "API URL for PubMed Eutils Entrez Esearch.")

(defvar consult-omni-pubmed-esummary-api-url "https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi"
  "API URL for PubMed Eutils Entrez Esummary.")

#+end_src
**** helper functions
***** format
#+begin_src emacs-lisp
(cl-defun consult-omni-dynamic--pubmed-format-candidate (&rest args &key source query url search-url title authors date journal doi face &allow-other-keys)
  "Format candidates from `consult-omni-pubmed' with ARGS.

Description of Arguments:

  SOURCE     the name to use (e.g. “PubMed”)
  QUERY      query input from the user
  URL        the url of  candidate
  SEARCH-URL the web search url
             (e.g. https://pubmed.ncbi.nlm.nih.gov/?term=QUERY)
  TITLE      the title of the result/paper (e.g. title of paper)
  AUTHORS    the authors of the result/paper
  DATE       the publish date of the result/paper
  JOURNAL    the journal that the result/paper is published in
  DOI        the doi of the result/paper
  FACE       the face to apply to TITLE"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (if (stringp source) (propertize source 'face 'consult-omni-source-type-face) nil))
         (date (if (stringp date) (propertize date 'face 'consult-omni-date-face) nil))
         (journal (if (stringp journal) (propertize journal 'face 'consult-omni-domain-face) nil))
         (authors (cond
                   ((and authors (listp authors))
                    (concat (first authors) ",..., " (car (last authors))))
                   ((stringp authors)
                    authors)
                   (t nil)))
         (authors (if (and authors (stringp authors)) (propertize authors 'face 'consult-omni-source-type-face)))
         (doi (if (stringp doi) (propertize doi 'face 'link)))
         (match-str (if (and (stringp query) (not (equal query ".*"))) (consult--split-escaped query) nil))
         (face (or (consult-omni--get-source-prop source :face) face 'consult-omni-default-face))
         (title-str (propertize title 'face face))
         (title-str (consult-omni--set-string-width title-str (* 5 frame-width-percent)))
         (str (concat title-str
                      (if journal (format "\t%s" journal))
                      (if date (format "\s\s%s" date))
                      (if authors (format "\s\s%s" authors))
                      (if source (concat "\t" source)))))
    (if consult-omni-highlight-matches-in-minibuffer
        (cond
         ((listp match-str)
          (mapc (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-omni--highlight-match match-str str t)))))
    str))

#+end_src
**** fetching items/results
***** esearch
#+begin_src emacs-lisp
(cl-defun consult-omni--pubmed-esearch-fetch-results (input &rest args &key db &allow-other-keys)
  "Fetch “esearch” results for INPUT and ARGS from PubMed Entrez Utilities.

DB is passed as db in query parameters \(This is the database to search\).

Refer to URL `https://www.ncbi.nlm.nih.gov/books/NBK25501/'
for more info."

  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :db db))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (page (or (and page (integerp (read page)) (string-to-number page))
                         consult-omni-default-page))
               (count (min count 20))
               (page (* page count))
               (db (if db (format "%s" db) "pubmed"))
               (params `(("db" . ,db)
                         ("term" . ,(replace-regexp-in-string " " "+" query))
                         ("usehistory" . "y")
                         ("retmax" . ,(format "%s" count))
                         ("retstart" . ,(format "%s" page))
                         ("retmode" . "json")))
               (headers `(("tool" . "consult-omni")
                          ("email" . "contact@armindarvish.com")
                          ("api_key" . ,(consult-omni-expand-variable-function consult-omni-pubmed-api-key)))))
    (consult-omni--fetch-url
     consult-omni-pubmed-esearch-api-url consult-omni-http-retrieve-backend
     :sync t
     :params params
     :headers headers
     :parser #'consult-omni--json-parse-buffer
     :callback
     (lambda (attrs)
       (let* ((results (gethash "esearchresult" attrs))
              (webenv (gethash "webenv" results))
              (qk (gethash "querykey" results))
              (idlist (gethash "idlist" results)))
         `(:webenv ,webenv :qk ,qk :idlist ,idlist))))))

#+end_src
***** esummary
#+begin_src emacs-lisp
(cl-defun consult-omni--pubmed-esummary-fetch-results (input &rest args &key callback webenv qk db &allow-other-keys)
  "Fetch “esummary” results for INPUT and ARGS from PubMed Entrez.

Description of Arguments:

  WEBENV a string; passed as webenv in query parameters
  qk     a string; passed as qk in query parameters
  DB     a string; passed as db in query parameters.

Refer to URL `https://www.ncbi.nlm.nih.gov/books/NBK25501/'
for more info.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback :webenv webenv :qk qk :db db))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (page (or (and page (integerp (read page)) (string-to-number page))
                         consult-omni-default-page))
               (page (* page count))
               (webenv (if webenv (format "%s" webenv)))
               (qk (if qk (format "%s" qk)))
               (retmax (min count 500))
               (retstart (max 0 page))
               (db (if db (format "%s" db) "pubmed"))
               (params `(("db" . ,db)
                         ("query_key" . ,qk)
                         ("WebEnv" . ,webenv)
                         ("retmax" . ,(format "%s" retmax))
                         ("retstart" . ,(format "%s" retstart))
                         ("retmode" . "json")))
               (headers `(("tool" . "consult-omni")
                          ("email" . "contact@armindarvish.com")
                          ("api_key" . ,(consult-omni-expand-variable-function consult-omni-pubmed-api-key)))))
    (consult-omni--fetch-url consult-omni-pubmed-esummary-api-url consult-omni-http-retrieve-backend
                             :encoding 'utf-8
                             :params params
                             :headers headers
                             :parser #'consult-omni--json-parse-buffer
                             :callback
                             (lambda (attrs)
                               (let* ((results (gethash "result" attrs))
                                      (uids (gethash "uids" results))
                                      (annotated-results
                                       (mapcar
                                        (lambda (uid)
                                          (let*
                                              ((source "PubMed")
                                               (url (url-unhex-string (concat consult-omni-pubmed-search-url (format "%s" uid))))
                                               (search-url (consult-omni--make-url-string consult-omni-pubmed-search-url `(("term" . ,(replace-regexp-in-string " " "+" query)))))
                                               (data (gethash uid results))
                                               (title (gethash "title" data))
                                               (pubdate (date-to-time (gethash "pubdate" data)))
                                               (date (format-time-string "%Y-%m-%d" pubdate))
                                               (journal (gethash "fulljournalname" data))
                                               (authors (mapcar (lambda (item) (gethash "name" item)) (gethash "authors" data)))
                                               (ids (gethash "articleids" data))
                                               (doi (car (remove nil (mapcar (lambda (item) (if (equal (gethash "idtype" item) "doi") (gethash "value" item))) ids))))
                                               (decorated (consult-omni-dynamic--pubmed-format-candidate :source source :query query :url url :search-url search-url :title title :authors authors :date date :journal journal :doi doi)))
                                            (propertize decorated
                                                        :source source
                                                        :url url
                                                        :title title
                                                        :search-url search-url
                                                        :query query
                                                        :journal journal
                                                        :authors authors
                                                        :date date
                                                        :doi doi)))
                                        uids)))
                                 (when (and annotated-results (functionp callback))
                                   (funcall callback annotated-results))
                                 annotated-results)))))

#+end_src
***** main
#+begin_src emacs-lisp
(cl-defun consult-omni--pubmed-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch results for INPUT and ARGS from PubMed Entrez Utilities.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (let* ((esearch (consult-omni--pubmed-esearch-fetch-results input))
         (webenv (plist-get esearch :webenv))
         (qk (plist-get esearch :qk)))
    (consult-omni--pubmed-esummary-fetch-results input :callback callback :webenv webenv :qk qk)))

#+end_src
**** define source
#+begin_src emacs-lisp
;; Define the PubMed source
(consult-omni-define-source "PubMed"
                            :narrow-char ?p
                            :type 'dynamic
                            :require-match nil
                            :category 'consult-omni-scholar
                            :face 'consult-omni-scholar-title-face
                            :request #'consult-omni--pubmed-fetch-results
                            :on-new (apply-partially #'consult-omni-external-search-with-engine "PubMed")
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :enabled (lambda () (bound-and-true-p consult-omni-pubmed-api-key))
                            :group #'consult-omni--group-function
                            :sort t
                            :interactive consult-omni-intereactive-commands-type
                            :annotate nil)

#+end_src
**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-pubmed' module

(provide 'consult-omni-pubmed)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-pubmed)
;;; consult-omni-pubmed.el ends here
#+end_src


*** Scopus
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-scopus.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-scopus.el --- Consulting Scopus -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-scopus provides commands for searching Scopus database
;; directly in Emacs using consult-omni as the frontend.
;;
;; See URL `https://dev.elsevier.com/' for more info on using Scopus.

;;; Code:

(require 'consult-omni)

#+end_src
**** variables
***** custom
#+begin_src emacs-lisp
(defcustom consult-omni-scopus-api-key nil
  "Key for Scopus API.

Can be a key string or a function that returns a key string.

See URL `https://dev.elsevier.com/documentation/SCOPUSSearchAPI.wadl' for more info"
  :group 'consult-omni
  :type '(choice (const :tag "Scopus API Key" string)
                 (function :tag "Custom Function")))

#+end_src
***** other
#+begin_src emacs-lisp
(defvar consult-omni-scopus-search-url "https://www.scopus.com/record/display.uri?"
  "Search URL for Scopus.")

(defvar consult-omni-scopus-api-url "https://api.elsevier.com/content/search/scopus"
  "API URL for Scopus.")

#+end_src
**** helper functions
***** format
#+begin_src emacs-lisp
(cl-defun consult-omni--scopus-format-candidate (&rest args &key source query url search-url title authors date journal doi face &allow-other-keys)
  "Format a candidate from `consult-omni-scopus' with ARGS.

Description of Arguments:

  SOURCE     a string; the name to use (e.g. “Scopus”)
  QUERY      a string; query input from the user
  URL        a string; the url of  candidate
  SEARCH-URL a string; the web search url
             \(e.g. https://www.scopus.com/record/display.uri?&eid=%s\)
  TITLE      a string; the title of the result/paper
  AUTHORS    a string or list of strings; the authors of the result/paper
  DATE       a string; the publish date of the result/paper
  JOURNAL    a string; the journal that the result/paper is published in
  DOI        a string; the doi of the result/paper
  FACE       a symbol; the face to apply to TITLE"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (if (stringp source) (propertize source 'face 'consult-omni-source-type-face) nil))
         (date (if (stringp date) (propertize date 'face 'consult-omni-date-face) nil))
         (journal (if (stringp journal) (propertize journal 'face 'consult-omni-domain-face) nil))
         (authors (cond
                   ((and authors (listp authors))
                    (concat (first authors) ",..., " (car (last authors))))
                   ((stringp authors)
                    authors)
                   (t nil)))
         (authors (if (and authors (stringp authors)) (propertize authors 'face 'consult-omni-source-type-face)))
         (doi (if (stringp doi) (propertize doi 'face 'link) nil))
         (match-str (if (and (stringp query) (not (equal query ".*"))) (consult--split-escaped query) nil))
         (face (or (consult-omni--get-source-prop source :face) face 'consult-omni-default-face))
         (title-str (propertize title 'face face))
         (title-str (consult-omni--set-string-width title-str (* 5 frame-width-percent)))
         (str (concat title-str
                      (if journal (format "\t%s" journal))
                      (if date (format "\s\s%s" date))
                      (if authors (format "\s\s%s" authors))
                      (if source (concat "\t" source)))))
    (if consult-omni-highlight-matches-in-minibuffer
        (cond
         ((listp match-str)
          (mapc (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-omni--highlight-match match-str str t)))))
    str))

#+end_src
***** callback
#+begin_src emacs-lisp
(defun consult-omni--scopus-callback (cand)
  "Callback function for CAND from `consult-omni-scopus'."
  (let* ((doi (get-text-property 0 :doi cand))
         (url (if doi (consult-omni--doi-to-url doi)
                (get-text-property 0 :url cand))))
    (funcall consult-omni-default-browse-function url)))

#+end_src
***** preview
#+begin_src emacs-lisp
(defun consult-omni--scopus-preview (cand)
  "Preview function for CAND from `consult-omni-scopus'."
  (let* ((doi (get-text-property 0 :doi cand))
         (url (if doi (consult-omni--doi-to-url doi)
                (get-text-property 0 :url cand))))
    (funcall consult-omni-default-preview-function url)))

#+end_src
**** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--scopus-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch search results from SCOPUS for INPUT and ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (page (or (and page (integerp (read page)) (string-to-number page))
                         consult-omni-default-page))
               (count (min (max count 1) 25))
               (page (* count page))
               (params `(("query" . ,(replace-regexp-in-string " " "+" query))
                         ("count" . ,(format "%s" count))
                         ("start" . ,(format "%s" page))
                         ("apiKey" . ,(consult-omni-expand-variable-function consult-omni-scopus-api-key))))
               (headers `(("Accept" . "application/json"))))
    (consult-omni--fetch-url consult-omni-scopus-api-url consult-omni-http-retrieve-backend
                             :encoding 'utf-8
                             :params params
                             :headers headers
                             :parser #'consult-omni--json-parse-buffer
                             :callback
                             (lambda (attrs)
                               (when-let* ((raw-results (map-nested-elt attrs '("search-results" "entry")))
                                           (annotated-results
                                            (mapcar
                                             (lambda (item)
                                               (let*
                                                   ((source "Scopus")
                                                    (title (gethash "dc:title" item))
                                                    (journal (gethash "prism:publicationName" item))
                                                    (volume (gethash "prism:volume" item))
                                                    (pages (gethash "prism:pageRange" item))
                                                    (authors (gethash "dc:creator" item))
                                                    (authors (cond
                                                              ((stringp authors) (list authors))
                                                              (t authors)))
                                                    (date (gethash "prism:coverDate" item))
                                                    (eid (gethash "eid" item))
                                                    (doi (gethash "prism:doi" item))
                                                    (url (concat consult-omni-scopus-search-url "&eid=" eid "&origin=inward"))
                                                    (search-url (concat consult-omni-scopus-search-url "&eid=" eid "&origin=inward"))
                                                    (decorated (consult-omni--scopus-format-candidate :source source :query query :url url :search-url search-url :title title :authors authors :date date :journal journal :doi doi)))
                                                 (propertize decorated
                                                             :source source
                                                             :url url
                                                             :title title
                                                             :search-url search-url
                                                             :query query
                                                             :journal journal
                                                             :volume volume
                                                             :pages pages
                                                             :authors authors
                                                             :date date
                                                             :doi doi
                                                             :eid eid)))
                                             raw-results)))
                                 (funcall callback annotated-results))))))

#+end_src
**** define source
#+begin_src emacs-lisp
;; Define the Scopus source
(consult-omni-define-source "Scopus"
                            :narrow-char ?s
                            :type 'dynamic
                            :require-match nil
                            :category 'consult-omni-scholar
                            :face 'consult-omni-scholar-title-face
                            :request #'consult-omni--scopus-fetch-results
                            :preview-key consult-omni-preview-key
                            :on-preview #'consult-omni--scopus-preview
                            :on-return #'identity
                            :on-callback #'consult-omni--scopus-callback
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :enabled (lambda () (bound-and-true-p consult-omni-scopus-api-key))
                            :group #'consult-omni--group-function
                            :sort t
                            :interactive consult-omni-intereactive-commands-type
                            :annotate nil)

#+end_src

**** provide and footer

#+begin_src emacs-lisp
;;; provide `consult-omni-scopus' module

(provide 'consult-omni-scopus)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-scopus)
;;; consult-omni-scopus.el ends here
#+end_src
*** Stackoverflow
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-stackoverflow.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-stackoverflow.el --- Consulting StackOverflow -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-stackoverflow provides commands for searching StackOverflow
;; directly in Emacs using consult-omni as the frontend.

;;; Code:

(require 'consult-omni)

#+end_src
**** variables
***** custom
#+begin_src emacs-lisp
(defcustom consult-omni-stackexchange-api-key nil
  "Key for Stack Exchange API.

Can be a key string or a function that returns a key string.

See URL `https://api.stackexchange.com/', and
URL `https://stackapps.com/' for more info."
  :group 'consult-omni
  :type '(choice (const :tag "API Key" string)
                 (function :tag "Custom Function")))

#+end_src
***** other
#+begin_src emacs-lisp
(defvar consult-omni-stackoverflow-search-url "https://stackoverflow.com/search"
  "Search URL for StackOverflow.")

(defvar consult-omni-stackoverflow-api-url "https://api.stackexchange.com/2.3/search/advanced"
  "API URL for StackOverflow.")

(defvar consult-omni-stackoverflow-answered-mark "+"
  "Mark for answered StackOverflow's questions.")

(defvar consult-omni-stackoverflow-unanswered-mark "x"
  "Mark for unanswered StackOverflow's questions.")

#+end_src
**** helper functions
***** format
#+begin_src emacs-lisp
(cl-defun consult-omni--stackoverflow-format-candidate (&rest args &key source query url search-url title snippet date answered score face &allow-other-keys)
  "Format a candidate from “StackOverflow” search with ARGS.

Description of Arguments:

  SOURCE     a string; the source name \(e.g. “StackOveflow”\)
  QUERY      a string; query input from the user
  URL        a string; the URL of the candidate
  SEARCH-URL a string; the web search URL
  TITLE      a string; the title of the StackOverflow topic
  SNIPPET    a string; a snippet/description of the StackOverflow topic
  DATE       a string; the date string of the StackOverflow topic
  ANSWERED   a boolean; whether the question is answered on StackOveflow
  SCORE      a number; the score of the question on StackOverflow
  FACE       a symbol; the face to apply to TITLE"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (and (stringp source) (propertize source 'face 'consult-omni-source-type-face)))
         (date (and (stringp date) (propertize date 'face 'consult-omni-date-face)))
         (answered (if answered (propertize consult-omni-stackoverflow-answered-mark 'face 'consult-omni-domain-face)
                     (propertize consult-omni-stackoverflow-unanswered-mark 'face 'error)))
         (score (and score (propertize (format "%s" score) 'face 'consult-omni-path-face)))
         (match-str (and (stringp query) (not (equal query ".*")) (consult--split-escaped query)))
         (face (or (consult-omni--get-source-prop source :face) face 'consult-omni-default-face))
         (title-str (propertize title 'face face))
         (title-str (consult-omni--set-string-width title-str (* 7 frame-width-percent)))
         (str (concat title-str
                      (when date (concat "\s" date))
                      (when answered (concat "\s" answered))
                      (when score (concat "\s" score))
                      (when source (concat "\t" source)))))
    (if consult-omni-highlight-matches-in-minibuffer
        (cond
         ((listp match-str)
          (mapc (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-omni--highlight-match match-str str t)))))
    str))

#+end_src
**** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--stackoverflow-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch search results for INPUT from StackOverflow with ARGS.

See URL `https://api.stackexchange.com/' for more info.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (order (plist-get opts :order))
               (sort (plist-get opts :sort))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (page (or (and page (integerp (read page)) (string-to-number page))
                         consult-omni-default-page))
               (count (min count 25))
               (page (max page 1))
               (order (if (and order (member (format "%s" order) '("desc" "asc"))) (format "%s" order)))
               (sort (if (and sort (member (format "%s" sort) '("activity" "votes" "creation" "relevance"))) (format "%s" sort)))
               (params `(("order" . ,(or order "desc"))
                         ("sort" . ,(or sort "relevance"))
                         ("site" . "stackoverflow")
                         ("q" . ,(replace-regexp-in-string " " "+" query))
                         ("pagesize" . ,(format "%s" count))
                         ("page" . ,(format "%s" page))
                         ("key" . ,(consult-omni-expand-variable-function consult-omni-stackexchange-api-key))))
               (headers '(("Accept" . "application/json"))))
    (consult-omni--fetch-url consult-omni-stackoverflow-api-url consult-omni-http-retrieve-backend
                             :encoding 'utf-8
                             :params params
                             :headers headers
                             :parser #'consult-omni--json-parse-buffer
                             :callback
                             (lambda (attrs)
                               (let* ((raw-results (gethash "items" attrs))
                                      (annotated-results
                                       (mapcar (lambda (item)
                                                 (let*
                                                     ((source "StackOverflow")
                                                      (url (format "%s" (gethash "link" item)))
                                                      (title (format "%s" (gethash "title" item)))
                                                      (date (gethash "last_edit_date" item))
                                                      (date (format-time-string "%Y-%m-%d" (seconds-to-time date)))
                                                      (answered (gethash "is_answered" item))
                                                      (score (gethash "score" item))
                                                      (search-url (concat consult-omni-stackoverflow-search-url "?q=" input))
                                                      (decorated (consult-omni--stackoverflow-format-candidate :source source :query query :url url :search-url search-url :title title :date date :answered answered :score score)))
                                                   (propertize decorated
                                                               :source source
                                                               :title title
                                                               :url url
                                                               :search-url search-url
                                                               :query query
                                                               :date date
                                                               :answered answered
                                                               :score score
                                                               )))
                                               raw-results)))
                                 (when (and annotated-results (functionp callback))
                                   (funcall callback annotated-results))
                                 annotated-results)))))

#+end_src
**** define source
#+begin_src emacs-lisp
;; Define the StackOverflow source
(consult-omni-define-source "StackOverflow"
                            :narrow-char ?s
                            :type 'dynamic
                            :require-match nil
                            :face 'consult-omni-engine-title-face
                            :request #'consult-omni--stackoverflow-fetch-results
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :enabled (lambda () (bound-and-true-p consult-omni-stackexchange-api-key))
                            :group #'consult-omni--group-function
                            :sort t
                            :interactive consult-omni-intereactive-commands-type
                            :annotate nil)

#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-stackoverflow' module

(provide 'consult-omni-stackoverflow)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-stackoverflow)
;;; consult-omni-stackoverflow.el ends here
#+end_src


*** Wikipedia
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-wikipedia.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-wikipedia.el --- Consulting Wikipedia -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-wikipedia provides commands for searching Wikipedia in
;; Emacs using consult-omni as the frontend.

;;; Code:

(require 'consult-omni)

#+end_src
**** variables
***** other
#+begin_src emacs-lisp
(defvar consult-omni-wikipedia-search-url "https://www.wikipedia.org/search-redirect.php"
  "Search URL for Wikipedia.")

(defvar consult-omni-wikipedia-url "https://wikipedia.org/"
  "Main URL for Wikipedia.")

(defvar consult-omni-wikipedia-api-url "https://wikipedia.org/w/api.php"
  "API URL for Wikipedia.")

#+end_src
**** helper functions
***** format
#+begin_src emacs-lisp
(cl-defun consult-omni--wikipedia-format-candidate (&rest args &key source query url search-url title snippet date face &allow-other-keys)
  "Format a candidate from Wikipedia search with ARGS.

Description of Arguments:

  SOURCE     a string; the source name (e.g. “Wikipedia”)
  QUERY      a string; query input from the user
  URL        a string; the url of  candidate
  SEARCH-URL a string; the web search url
  TITLE      a string; the title of the result (e.g. a Wikipedia article)
  SNIPPET    a string; a snippet/description of the Wikipedia article
  DATE       a string; the date that the article was last updated
  FACE       a string; the face to apply to TITLE"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (and (stringp source) (propertize source 'face 'consult-omni-source-type-face)))
         (date (and (stringp date) (propertize date 'face 'consult-omni-date-face)))
         (match-str (and (stringp query) (not (equal query ".*")) (consult--split-escaped query)))
         (face (or (consult-omni--get-source-prop source :face) face 'consult-omni-default-face))
         (title-str (propertize title 'face face))
         (title-str (consult-omni--set-string-width title-str (* 3 frame-width-percent)))
         (snippet (and (stringp snippet) (consult-omni--set-string-width (string-trim snippet) (* 4 frame-width-percent))))
         (snippet (and (stringp snippet) (propertize snippet 'face 'consult-omni-snippet-face)))
         (str (concat title-str
                      (when date (concat "\s" date))
                      (when snippet (concat "\s\s" snippet))
                      (when source (concat "\t" source)))))
    (if consult-omni-highlight-matches-in-minibuffer
        (cond
         ((listp match-str)
          (mapcar (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-omni--highlight-match match-str str t)))))
    str))
#+end_src
**** fetching items/results
#+begin_src emacs-lisp
(cl-defun consult-omni--wikipedia-fetch-results (input &rest args &key callback &allow-other-keys)
  "Fetch search results from Wikipedia for INPUT and ARGS.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (page (or (and page (integerp (read page)) (string-to-number page))
                         consult-omni-default-page))
               (count (max count 1))
               (params `(("action" . "query")
                         ("format" . "json")
                         ("list" . "search")
                         ("formatversion" . "2")
                         ("prop" . "info")
                         ("inprop" . "url")
                         ("srwhat" . "text")
                         ("srsearch" . ,(url-hexify-string query))
                         ("srlimit" . ,(format "%s" count))
                         ("sroffset" . ,(format "%s" page))))
               (headers '(("User-Agent" . "Emacs:consult-omni/0.1 (https://github.com/armindarvish/consult-omni);"))))
    (consult-omni--fetch-url consult-omni-wikipedia-api-url consult-omni-http-retrieve-backend
                             :encoding 'utf-8
                             :params params
                             :headers headers
                             :parser #'consult-omni--json-parse-buffer
                             :callback
                             (lambda (attrs)
                               (when-let* ((raw-results (map-nested-elt attrs '("query" "search")))
                                           (annotated-results
                                            (mapcar (lambda (item)
                                                      (let*
                                                          ((source "Wikipedia")
                                                           (title (format "%s" (gethash "title" item)))
                                                           (url (concat consult-omni-wikipedia-url "wiki/" (string-replace " " "_" title)))
                                                           (date (gethash "timestamp" item))
                                                           (date (format-time-string "%Y-%m-%d" (date-to-time date)))
                                                           (snippet (replace-regexp-in-string "<span.*?>\\|</span>\\|&quot;" "" (format "%s" (gethash "snippet" item))))
                                                           (search-url (concat  consult-omni-wikipedia-search-url "?" "search=" query))
                                                           (decorated (consult-omni--wikipedia-format-candidate :source source :query query :url url :search-url search-url :title title :snippet snippet :date date)))
                                                        (propertize decorated
                                                                    :source source
                                                                    :title title
                                                                    :url url
                                                                    :search-url search-url
                                                                    :query query
                                                                    :date date)))
                                                    raw-results)))
                                 (funcall callback annotated-results)
                                 annotated-results)))))

#+end_src
**** define source
#+begin_src emacs-lisp
;; Define the Wikipedia source
(consult-omni-define-source "Wikipedia"
                            :narrow-char ?w
                            :type 'dynamic
                            :require-match nil
                            :face 'consult-omni-engine-title-face
                            :request #'consult-omni--wikipedia-fetch-results
                            :on-new (apply-partially #'consult-omni-external-search-with-engine "Wikipedia")
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :enabled (lambda () (bound-and-true-p consult-omni-wikipedia-api-url))
                            :group #'consult-omni--group-function
                            :sort t
                            :type 'dynamic
                            :interactive consult-omni-intereactive-commands-type)

#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-wikipedia' module

(provide 'consult-omni-wikipedia)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-wikipedia)
;;; consult-omni-wikipedia.el ends here
#+end_src
*** YouTube
:PROPERTIES:
:header-args:emacs-lisp: :results none :lexical t :mkdirp yes :link yes :tangle ./sources/consult-omni-youtube.el
:END:
**** header
#+begin_src emacs-lisp
;;; consult-omni-youtube.el --- Consulting YouTube -*- lexical-binding: t -*-

;; Copyright (C) 2024 Armin Darvish

;; Author: Armin Darvish
;; Maintainer: Armin Darvish
;; Created: 2024
;; Version: 0.1
;; Package-Requires: (
;;         (emacs "28.1")
;;         (consult "1.4")
;;         (consult-omni "0.1"))
;;
;; Homepage: https://github.com/armindarvish/consult-omni
;; Keywords: convenience

;;; Commentary:
;; consult-omni-youtube provides commands for searching YouTube in Emacs
;; using consult-omni as the frontend.

;;; Code:

(require 'consult-omni)

#+end_src
**** variables
***** custom
#+begin_src emacs-lisp
(defcustom consult-omni-youtube-search-key nil
  "Key for “YouTube Data API”.

Can be a key string or a function that returns a key string.

See URL `https://developers.google.com/youtube/v3/getting-started'
for details"
  :group 'consult-omni
  :type '(choice (const :tag "API Key" string)
                 (function :tag "Custom Function")))

(defcustom consult-omni-youtube-search-command #'consult-omni--youtube-fetch-results-details
  "Command to use to get results from “YouTube Data API”."
  :group 'consult-omni
  :type '(choice (function :tag "(Default) Detailed Results with stats" #'consult-omni--youtube-fetch-results-details)
                 (function :tag "Simple Results without stats"  #'consult-omni--youtube-fetch-results-simple)
                 (function :tag "Custom Function")))

#+end_src
***** other
#+begin_src emacs-lisp
(defvar consult-omni-youtube-base-url "https://www.youtube.com/"
  "Base URL of YouTube.")

(defvar consult-omni-youtube-watch-url "https://www.youtube.com/watch"
  "Watch URL of YouTube.")

(defvar consult-omni-youtube-channel-url "https://www.youtube.com/channel/"
  "Channel URL of YouTube.")

(defvar consult-omni-youtube-search-results-url "https://www.youtube.com/results"
  "Search Results URL of YouTube.")

(defvar consult-omni-youtube-search-api-url "https://www.googleapis.com/youtube/v3/search"
  "API URL of YouTube Search.")

(defvar consult-omni-youtube-videos-api-url "https://www.googleapis.com/youtube/v3/videos"
  "API URL for YouTube Videos.")

(defvar consult-omni-youtube-playlists-api-url "https://www.googleapis.com/youtube/v3/playlists"
  "API URL for YouTube Playlists.")

(defvar consult-omni-youtube-channels-api-url "https://www.googleapis.com/youtube/v3/channels"
  "API URL for YouTube Channels.")

#+end_src
**** helper functions
***** format
#+begin_src emacs-lisp
(cl-defun consult-omni--youtube-format-candidate (&rest args &key source type query title snippet channeltitle date length subcount videocount viewcount face &allow-other-keys)
  "Format a candidate from `consult-omni-youtube' with ARGS.

Description of Arguments:

  SOURCE       a string; the name to use (e.g. “YouTube”)
  TYPE         a string; the type of candidate
               \(e.g. video, channel, playlist\)
  QUERY        a string; the query input from the user
  TITLE        a string; the title of the video
  SNIPPET      a string; a snippet/description of the video
  CHANNELTITLE a string; the name of the channel for the video
  DATE         a string; the publish date of the video
  LENGTH       a number or string; the duration of a  video in seconds
  SUBCOUNT     an integer; the subscriber count for a channel
  VIDEOCOUNT   an integer; the number of videos in a playlist
  VIEWCOUNT    an integer; the number of times a video is viewed
  FACE         a symbol; the face to apply to TITLE"
  (let* ((frame-width-percent (floor (* (frame-width) 0.1)))
         (source (propertize source 'face 'consult-omni-source-type-face))
         (match-str (if (and (stringp query) (not (equal query ".*"))) (consult--split-escaped query) nil))
         (date (and (stringp date) (propertize date 'face 'consult-omni-date-face)))
         (channeltitle (and (stringp channeltitle) (propertize channeltitle 'face 'consult-omni-path-face)))
         (channeltitle (consult-omni--set-string-width channeltitle (* 2 frame-width-percent)))
         (snippet (if (stringp snippet) (consult-omni--set-string-width (replace-regexp-in-string "\n" "  " snippet) (* 2 frame-width-percent))))
         (snippet (and snippet (stringp snippet) (propertize snippet 'face 'consult-omni-snippet-face)))
         (videocount-str (and videocount (consult-omni--numbers-human-readable (or videocount 0) "videos")))
         (viewcount-str (and viewcount (consult-omni--numbers-human-readable (or viewcount 0) "views")))
         (subcount-str (and subcount (consult-omni--numbers-human-readable (or subcount 0) "subs")))
         (stats (and type
                     (stringp type)
                     (propertize
                      (consult-omni--set-string-width (pcase type
                                                        ("video" (format "%s" (or viewcount-str "0 views")))
                                                        ("playlist" (format "%s" (or videocount-str "0 videos")))
                                                        ("channel" (format "%s" (or subcount-str "0 subscriptions")))
                                                        (_ "")) 10)
                      'face 'consult-omni-domain-face)))
         (length (or
                  (and (equal type "playlist") "[PLAYLIST]")
                  (and (equal type "channel") "(CHANNEL)")
                  (and (numberp length) (seconds-to-string length))))
         (length (and (stringp length) (consult-omni--set-string-width (propertize length 'face 'consult-omni-comment-face) 10)))
         (face (or (consult-omni--get-source-prop source :face) face 'consult-omni-default-face))
         (title-str (propertize title 'face face))
         (title-str (consult-omni--set-string-width title-str (* 5 frame-width-percent)))
         (str (concat title-str
                      (when date (concat "\s" date))
                      (when channeltitle (concat " " channeltitle))
                      (when length (concat "\s" length))
                      (unless (string-empty-p stats) (concat "\s" stats))
                      (when snippet (concat "\s\s" snippet))
                      (concat "\t" source))))
    (if consult-omni-highlight-matches-in-minibuffer
        (cond
         ((listp match-str)
          (mapc (lambda (match) (setq str (consult-omni--highlight-match match str t))) match-str))
         ((stringp match-str)
          (setq str (consult-omni--highlight-match match-str str t)))))
    str))

#+end_src
**** fetching items/results
***** youtube search simple
#+begin_src emacs-lisp
(cl-defun consult-omni--youtube-fetch-results-simple (input &rest args &key callback &allow-other-keys)
  "Fetch search results for INPUT and ARGS from “YouTube Data API” service.

This is a simpler version that does not show details
such as view counts and duration, ... of videos/playlists, etc.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (def (plist-get opts :def))
               (type (plist-get opts :type))
               (vidtype (plist-get opts :vidtype))
               (order (or (plist-get opts :order) (plist-get opts :sort)))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (page (or (and page (integerp (read page)) (string-to-number page))
                         consult-omni-default-count))
               (def (if (and def (member (format "%s" def) '("any" "standard" "high"))) (format "%s" def) "any"))
               (type (if (and type (member (format "%s" type) '("channel" "playlist" "video"))) (format "%s" type) "video"))
               (vidtype (if (and vidtype (member (format "%s" vidtype) '("any" "episode" "movie"))) (format "%s" vidtype) "any"))
               (count (min count 10))
               (page (+ (* page count) 1))
               (order  (if (and order (member (format "%s" order) '("date" "rating" "relevance" "title" "videoCount" "viewCount"))) (format "%s" order) "relevance"))
               (params `(("q" . ,(replace-regexp-in-string " " "+" query))
                         ("part" . "snippet")
                         ("order" . ,order)
                         ("type" . ,type)
                         ("maxResults" . ,(format "%s" count))
                         ("videoDefinition" . ,def)
                         ("videoType" . ,vidtype)
                         ("key" . ,(consult-omni-expand-variable-function consult-omni-youtube-search-key))))
               (headers `(("Accept" . "application/json")
                          ("Accept-Encoding" . "gzip")
                          ("User-Agent" . "consult-omni (gzip)")
                          ("X-Goog-Api-Key" . ,(consult-omni-expand-variable-function consult-omni-youtube-search-key)))))
    (consult-omni--fetch-url consult-omni-youtube-search-api-url consult-omni-http-retrieve-backend
                             :encoding 'utf-8
                             :params params
                             :headers headers
                             :parser #'consult-omni--json-parse-buffer
                             :callback
                             (lambda (attrs)
                               (let* ((raw-results (gethash "items" attrs))
                                      (annotated-results
                                       (mapcar (lambda (item)
                                                 (let*
                                                     ((source "YouTube")
                                                      (videoid (gethash "videoId" (gethash "id" item)))
                                                      (snippet (gethash "snippet" item))
                                                      (channeltitle (gethash "channelTitle" snippet))
                                                      (channelid (gethash "channelId" snippet))
                                                      (title (gethash "title" snippet))
                                                      (date (gethash "publishedAt" snippet))
                                                      (date (format-time-string "%Y-%m-%d" (date-to-time date)))
                                                      (url (cond
                                                            (videoid (consult-omni--make-url-string consult-omni-youtube-watch-url `(("v" . ,videoid))))
                                                            (channelid (concat consult-omni-youtube-channel-url channelid))))
                                                      (search-url (consult-omni--make-url-string consult-omni-youtube-search-results-url `(("search_query" . ,query))))
                                                      (description (gethash "description" snippet))
                                                      (decorated (consult-omni--youtube-format-candidate :source source :query query :title title :snippet description :channeltitle channeltitle :date date)))
                                                   (propertize decorated
                                                               :source source
                                                               :title title
                                                               :url url
                                                               :search-url search-url
                                                               :query query
                                                               :snippet description
                                                               :videoid videoid
                                                               :channeltitle channeltitle
                                                               :channelid channelid)))
                                               raw-results)))
                                 (when (and annotated-results (functionp callback))
                                   (funcall callback annotated-results))
                                 annotated-results)))))

#+end_src
***** youtube search details
****** youtube videos
#+begin_src emacs-lisp
(cl-defun consult-omni--youtube-fetch-video-details (videoids &rest args &key callback query &allow-other-keys)
  "Fetch details with VIDEOIDS and ARGS from “YouTube Data API” service.

QUERY is the user input string.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((params `(("part" . "snippet,statistics,contentDetails")
                         ("key" . ,(consult-omni-expand-variable-function consult-omni-youtube-search-key))
                         ("id" . ,(string-join videoids ","))))
               (headers `(("Accept" . "application/json")
                          ("Accept-Encoding" . "gzip")
                          ("User-Agent" . "consult-omni (gzip)")
                          ("X-Goog-Api-Key" . ,(consult-omni-expand-variable-function consult-omni-youtube-search-key)))))
    (consult-omni--fetch-url consult-omni-youtube-videos-api-url consult-omni-http-retrieve-backend
                             :encoding 'utf-8
                             :params params
                             :headers headers
                             :parser #'consult-omni--json-parse-buffer
                             :callback
                             (lambda (attrs)
                               (let* ((raw-results (gethash "items" attrs))
                                      (annotated-results
                                       (mapcar (lambda (item)
                                                 (let*
                                                     ((source "YouTube")
                                                      (videoid (gethash "id" item))
                                                      (snippet (gethash "snippet" item))
                                                      (contentdetails (gethash "contentDetails" item))
                                                      (statistics (gethash "statistics" item))
                                                      (channeltitle (gethash "channelTitle" snippet))
                                                      (channelid (gethash "channelId" snippet))
                                                      (title (gethash "title" snippet))
                                                      (date (gethash "publishedAt" snippet))
                                                      (date (format-time-string "%Y-%m-%d" (date-to-time date)))
                                                      (url (consult-omni--make-url-string consult-omni-youtube-watch-url `(("v" . ,videoid))))
                                                      (search-url (consult-omni--make-url-string consult-omni-youtube-search-results-url `(("search_query" . ,query))))
                                                      (description (gethash "description" snippet))
                                                      (duration (gethash "duration" contentdetails))
                                                      (duration (if duration (iso8601-parse-duration duration)))
                                                      (duration (if duration (+ (* (caddr duration) 2600) (* (cadr duration) 60) (car duration))))
                                                      (viewcount (string-to-number (gethash "viewCount" statistics)))
                                                      (decorated (consult-omni--youtube-format-candidate :source source :type "video" :query query :title title :snippet description :channeltitle channeltitle :date date :length duration :viewcount viewcount)))
                                                   (propertize decorated
                                                               :source source
                                                               :title title
                                                               :url url
                                                               :search-url search-url
                                                               :query query
                                                               :snippet description
                                                               :id videoid
                                                               :channeltitle channeltitle
                                                               :channelid channelid)))
                                               raw-results)))
                                 (when (and annotated-results (functionp callback))
                                   (funcall callback annotated-results))
                                 annotated-results)))))

#+end_src

****** youtube playlists
#+begin_src emacs-lisp
(cl-defun consult-omni--youtube-fetch-playlist-details (playlistids &rest args &key callback query &allow-other-keys)
  "Fetch details with PLAYLISTIDS and ARGS from “YouTube Data API”.

QUERY is th euser input string and CANDIDATES
CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((params `(("part" . "snippet,contentDetails")
                         ("key" . ,(consult-omni-expand-variable-function consult-omni-youtube-search-key))
                         ("id" . ,(string-join playlistids ","))))
               (headers `(("Accept" . "application/json")
                          ("Accept-Encoding" . "gzip")
                          ("User-Agent" . "consult-omni (gzip)")
                          ("X-Goog-Api-Key" . ,(consult-omni-expand-variable-function consult-omni-youtube-search-key)))))
    (consult-omni--fetch-url consult-omni-youtube-playlists-api-url consult-omni-http-retrieve-backend
                             :encoding 'utf-8
                             :params params
                             :headers headers
                             :parser #'consult-omni--json-parse-buffer
                             :callback
                             (lambda (attrs)
                               (let* ((raw-results (gethash "items" attrs))
                                      (annotated-results
                                       (mapcar (lambda (item)
                                                 (let*
                                                     ((source "YouTube")
                                                      (playlistid (gethash "id" item))
                                                      (snippet (gethash "snippet" item))
                                                      (contentdetails (gethash "contentDetails" item))
                                                      (videocount (gethash "itemCount" contentdetails))
                                                      (channeltitle (gethash "channelTitle" snippet))
                                                      (channelid (gethash "channelId" snippet))
                                                      (title (gethash "title" snippet))
                                                      (date (gethash "publishedAt" snippet))
                                                      (date (format-time-string "%Y-%m-%d" (date-to-time date)))
                                                      (url (consult-omni--make-url-string consult-omni-youtube-watch-url `(("list" . ,playlistid))))
                                                      (search-url (consult-omni--make-url-string consult-omni-youtube-search-results-url `(("search_query" . ,query))))
                                                      (description (gethash "description" snippet))
                                                      (decorated (consult-omni--youtube-format-candidate :source source :type "playlist" :query query :title title :snippet description :channeltitle channeltitle :date date :videocount videocount)))
                                                   (propertize decorated
                                                               :source source
                                                               :title title
                                                               :url url
                                                               :search-url search-url
                                                               :query query
                                                               :snippet description
                                                               :id playlistid
                                                               :channeltitle channeltitle
                                                               :channelid channelid)))
                                               raw-results)))
                                 (when (and annotated-results (functionp callback))
                                   (funcall callback annotated-results))
                                 annotated-results)))))

#+end_src


****** youtube channels
#+begin_src emacs-lisp
(cl-defun consult-omni--youtube-fetch-channel-details (channelids &rest args &key callback query &allow-other-keys)
  "Fetch details with CHANNELIDS and ARGS from “YouTube Data API”.

QUERY is the user's input string.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((params `(("part" . "snippet,statistics")
                         ("key" . ,(consult-omni-expand-variable-function consult-omni-youtube-search-key))
                         ("id" . ,(string-join channelids ","))))
               (headers `(("Accept" . "application/json")
                          ("Accept-Encoding" . "gzip")
                          ("User-Agent" . "consult-omni (gzip)")
                          ("X-Goog-Api-Key" . ,(consult-omni-expand-variable-function consult-omni-youtube-search-key)))))
    (consult-omni--fetch-url consult-omni-youtube-channels-api-url consult-omni-http-retrieve-backend
                             :encoding 'utf-8
                             :params params
                             :headers headers
                             :parser #'consult-omni--json-parse-buffer
                             :callback
                             (lambda (attrs)
                               (let* ((raw-results (gethash "items" attrs))
                                      (annotated-results
                                       (mapcar (lambda (item)
                                                 (let*
                                                     ((source "YouTube")
                                                      (channelid (gethash "id" item))
                                                      (snippet (gethash "snippet" item))
                                                      (statistics (gethash "statistics" item))
                                                      (title (gethash "title" snippet))
                                                      (customurl (gethash "customUrl" snippet))
                                                      (date (gethash "publishedAt" snippet))
                                                      (date (format-time-string "%Y-%m-%d" (date-to-time date)))
                                                      (subcount (gethash "subscriberCount" statistics))
                                                      (url (if customurl
                                                               (concat consult-omni-youtube-base-url customurl)
                                                             (concat consult-omni-youtube-channel-url channelid)))
                                                      (search-url (consult-omni--make-url-string consult-omni-youtube-search-results-url `(("search_query" . ,query))))
                                                      (description (gethash "description" snippet))
                                                      (decorated (consult-omni--youtube-format-candidate :source source :type "channel" :query query :title title :snippet description :channeltitle title :date date :subcount subcount)))
                                                   (propertize decorated
                                                               :source source
                                                               :title title
                                                               :url url
                                                               :search-url search-url
                                                               :query query
                                                               :snippet description
                                                               :id channelid
                                                               :channeltitle title
                                                               :channelid channelid)))
                                               raw-results)))
                                 (when (and annotated-results (functionp callback))
                                   (funcall callback annotated-results))
                                 annotated-results)))))

#+end_src


****** youtube search with details
#+begin_src emacs-lisp
(cl-defun consult-omni--youtube-fetch-results-details (input &rest args &key callback &allow-other-keys)
  "Fetch search results for INPUT and ARGS from “YouTube Data API”.

This is a version with  statistics \(e.g. view counts\) and more details
on videos, playlsits, etc.

CALLBACK is a function used internally to update the list of candidates in
the minibuffer asynchronously.  It is called with a list of strings, which
are new annotated candidates \(e.g. as they arrive from an asynchronous
process\) to be added to the minibuffer completion cnadidates.  See the
section on REQUEST in documentation for `consult-omni-define-source' as
well as the function
`consult-omni--multi-update-dynamic-candidates' for how CALLBACK is used."
  (pcase-let* ((`(,query . ,opts) (consult-omni--split-command input (seq-difference args (list :callback callback))))
               (opts (car-safe opts))
               (videos (make-vector 1 (list)))
               (playlists (make-vector 1 (list)))
               (count (plist-get opts :count))
               (page (plist-get opts :page))
               (def (plist-get opts :def))
               (search-type (plist-get opts :type))
               (vidtype (plist-get opts :vidtype))
               (order (or (plist-get opts :order) (plist-get opts :sort)))
               (count (or (and count (integerp (read count)) (string-to-number count))
                          consult-omni-default-count))
               (page (or (and page (integerp (read page)) (string-to-number page))
                         consult-omni-default-count))
               (def (if (and def (member (format "%s" def) '("any" "standard" "high"))) (format "%s" def)))
               (vidtype (if (and vidtype (member (format "%s" vidtype) '("any" "episode" "movie"))) (format "%s" vidtype)))
               (search-type (cond
                             ((or def vidtype) "video")
                             ((and search-type (member (format "%s" search-type) '("channel" "playlist" "video"))) (format "%s" search-type))))
               (count (min count 100))
               (page (+ (* page count) 1))
               (order  (if (and order (member (format "%s" order) '("date" "rating" "relevance" "title" "videoCount" "viewCount"))) (format "%s" order) "relevance"))
               (params (delq nil `(("q" . ,(replace-regexp-in-string " " "+" query))
                                   ("part" . "snippet")
                                   ("order" . ,order)
                                   ("maxResults" . ,(format "%s" count))
                                   ,(when search-type `("type" . ,(format "%s" search-type)))
                                   ,(when def `("videoDefinition" . ,def))
                                   ,(when vidtype `("videoType" . ,vidtype))
                                   ("key" . ,(consult-omni-expand-variable-function consult-omni-youtube-search-key)))))
               (headers `(("Accept" . "application/json")
                          ("Accept-Encoding" . "gzip")
                          ("User-Agent" . "consult-omni (gzip)")
                          ("X-Goog-Api-Key" . ,(consult-omni-expand-variable-function consult-omni-youtube-search-key)))))
    (consult-omni--fetch-url consult-omni-youtube-search-api-url consult-omni-http-retrieve-backend
                             :encoding 'utf-8
                             :params params
                             :headers headers
                             :parser #'consult-omni--json-parse-buffer
                             :callback
                             (lambda (attrs)
                               (let* ((raw-results (gethash "items" attrs))
                                      (videoids (list))
                                      (playlistids (list))
                                      (channelids (list)))
                                 (mapc (lambda (item)
                                         (let* ((kind (gethash "kind" (gethash "id" item)))
                                                (type (string-trim-left kind "youtube#")))
                                           (pcase type
                                             ("video"
                                              (push (gethash "videoId" (gethash "id" item)) videoids))
                                             ("playlist"
                                              (push (gethash "playlistId" (gethash "id" item)) playlistids))
                                             ("channel"
                                              (push (gethash "channelId" (gethash "id" item)) channelids)))
                                           )) raw-results)
                                 (when videoids
                                   (consult-omni--youtube-fetch-video-details videoids :callback callback :query query))
                                 (when playlistids
                                   (consult-omni--youtube-fetch-playlist-details playlistids :callback callback :query query))
                                 (when channelids
                                   (consult-omni--youtube-fetch-channel-details channelids :callback callback :query query)))))))

#+end_src

**** define source
#+begin_src emacs-lisp
;; Define the YouTube source
(consult-omni-define-source "YouTube"
                            :narrow-char ?y
                            :type 'dynamic
                            :require-match t
                            :category 'consult-omni-video
                            :face 'consult-omni-engine-title-face
                            :request consult-omni-youtube-search-command
                            :on-new (apply-partially #'consult-omni-external-search-with-engine "YouTube")
                            :preview-key consult-omni-preview-key
                            :search-hist 'consult-omni--search-history
                            :select-hist 'consult-omni--selection-history
                            :enabled (lambda () (bound-and-true-p consult-omni-youtube-search-key))
                            :group #'consult-omni--group-function
                            :sort t
                            :interactive consult-omni-intereactive-commands-type
                            :annotate nil)

#+end_src

**** provide and footer
#+begin_src emacs-lisp
;;; provide `consult-omni-youtube' module

(provide 'consult-omni-youtube)

(add-to-list 'consult-omni-sources-modules-to-load 'consult-omni-youtube)
;;; consult-omni-youtube.el ends here
#+end_src
